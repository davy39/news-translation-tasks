---
title: Un récit d'avertissement sur l'apprentissage de la programmation. Le mien.
subtitle: ''
author: Quincy Larson
co_authors: []
series: null
date: '2014-11-14T00:00:00.000Z'
originalURL: https://freecodecamp.org/news/a-cautionary-tale-of-learning-to-code-my-own-eddb24d9d5a7
coverImage: https://cdn-media-1.freecodecamp.org/images/1*r7Zo59f6Zoy65GwVioQqug.jpeg
tags:
- name: Design
  slug: design
- name: education
  slug: education
- name: learning
  slug: learning
- name: 'self-improvement '
  slug: self-improvement
- name: technology
  slug: technology
seo_title: Un récit d'avertissement sur l'apprentissage de la programmation. Le mien.
seo_desc: 'I was just a guy in a suit in an office with a vague startup idea. Then
  I decided to learn to code.

  I overheard some guy at a happy hour bragging about how easily he was able to automate
  his office workflows by using a language called Ruby. I thought...'
---

Je n'étais qu'un homme en costume dans un bureau avec une idée de startup floue. Puis j'ai décidé d'apprendre à coder.

J'ai entendu un type lors d'un happy hour se vanter de la facilité avec laquelle il avait pu automatiser ses flux de travail de bureau en utilisant un langage appelé Ruby. J'ai pensé, "chuh, Ruby." Je suis rentré chez moi, j'ai googlé ça, et en 15 secondes, je suivais un tutoriel Ruby aléatoire.

Une semaine plus tard, je suis allé à ma première réunion d'espace de hackers. Tout le monde parlait de langages comme Scala, Clojure et Go. Il y avait tellement à apprendre. J'ai emprunté trois livres O'Reilly et j'en ai lu environ 50 pages chacun.

![Image](https://www.freecodecamp.org/news/content/images/2021/04/image-254.png)
_La plupart des livres techniques commencent gentiment avant de faire de grandes suppositions sur vos connaissances préalables._

Un ami m'a dit que je devrais maîtriser Emacs et m'a donné ses fichiers de configuration. J'ai passé quelques heures à apprendre la syntaxe de base de Lisp pour pouvoir le configurer davantage.

Puis un type est passé et m'a vu utiliser Emacs. "Pourquoi utilises-tu Emacs ?" m'a-t-il demandé. "Ne sais-tu pas que Vim est mieux ?" "Hm. Vim." Donc j'ai commencé à mémoriser des dizaines de raccourcis clavier Vim.

![Image](https://www.freecodecamp.org/news/content/images/2020/03/0_8Of4fgUMVCYvXzOD.png)
_La plupart des arguments sur les éditeurs de texte sont ce que les ingénieurs appellent des "guerres religieuses"  enracinées davantage dans des différences historiques que dans un mérite pratique._

À l'époque, il semblait raisonnable de penser que plus je pourrais taper vite, plus je pourrais coder vite. Je suis passé à un clavier Dvorak pour programmeurs parce que, hey, c'était objectivement le clavier le plus efficace qu'un programmeur puisse utiliser.

![Image](https://www.freecodecamp.org/news/content/images/2020/03/0_CxBvoOOrnTbG-jrp.png)
_Pouvez-vous compter combien de lettres, de chiffres et de symboles sont à leurs positions originales Qwerty ? Je vais vous donner un indice  c'est dans les bas chiffres uniques._

Les jours où je pouvais faire démarrer avec succès mon netbook sous Linux  et où je pouvais taper plus de 10 mots par minute , j'ai étudié Python en suivant des livres et des cours Udacity.

![Image](https://www.freecodecamp.org/news/content/images/2020/03/0_ksAF0A99qrP8GOII-1.jpg)
_J'ai pris ce selfie le samedi matin après mon dernier jour dans mon emploi corporate. Je me suis levé tôt et habillé en costume pour renforcer la sérieux de la tâche à accomplir : j'allais apprendre à coder ! Légende Facebook : "Mon nouveau bureau  la table de la cuisine ! Je pointe ici chaque matin à 8 heures et jusqu'à 18 heures, je ne me lève que pour les "bio-pauses"." Notez l'utilisation de guillemets autour du terme bio-pause. J'essayais d'être mignon et de parler comme un programmeur. Maintenant, je m'entends utiliser ce terme quotidiennement, sans ironie._

Après 7 mois d'auto-apprentissage intensif et de participation à des événements de codage, j'ai obtenu mon premier emploi en tant qu'ingénieur logiciel.

Lors de mon entretien avec le CTO, je lui ai parlé de tous les outils que j'avais appris et des configurations ésotériques que j'utilisais. Le CTO a hoché la tête et écouté poliment. Et une fois que j'eus fini de me vanter de l'étendue de mes connaissances, il m'a remis à ma place avec une simple observation polie. Il a dit, "Il y a beaucoup de façons de faire la plupart des choses, mais seulement quelques façons qui ont du sens." Sur ce, il m'a donné un MacBook usagé et m'a laissé libre dans l'enclos des développeurs.

Quatre ans plus tôt, l'entreprise avait décidé de construire leur produit en utilisant Ruby on Rails. Ils se sont engagés pleinement dans cette décision, et une grande partie de leur code original était toujours intacte. Tous les ingénieurs utilisaient des MacBooks, qui étaient à la fois fiables et similaires aux serveurs Ubuntu Linux qu'ils utilisaient en production.

Au lieu de discuter de Vim ou d'Emacs, tout le monde utilisait simplement RubyMine, un Environnement de Développement Intégré (IDE) puissant avec une configuration par défaut sensée. Cela signifiait que n'importe quel ingénieur pouvait s'asseoir à côté de n'importe quel autre ingénieur et commencer immédiatement à programmer en binôme sur une tâche sans avoir besoin de s'orienter dans l'environnement de développement de leur collègue. Ce fait seul a résolu une grande partie de l'inconfort et de la résistance inconsciente que deux développeurs ressentent lorsqu'ils essaient de collaborer.

L'entreprise était d'accord avec le fait que je ne connaissais pas Ruby on Rails. Comme je m'étais concentré suffisamment pour apprendre un peu de Python et Django et gagner un hackathon, ils ont pris cela comme un signe que je pourrais éventuellement apprendre Rails.

Les premières semaines ont été difficiles, et pas seulement parce que je travaillais avec une nouvelle équipe dans un nouveau langage, un nouveau framework et une nouvelle base de code. C'était difficile parce que partout où je regardais, je voyais des preuves que j'avais appris à coder de manière absurdement masochiste.

J'avais passé des mois assis seul dans des bibliothèques et des cafés, installant aveuglément des outils depuis la ligne de commande, déboguant des problèmes de pilotes Linux, et me cognant la tête sur des choses aussi triviales que des parenthèses manquantes.

J'ai touché à chaque programme de cours en ligne imaginable et commencé des dizaines de MOOCs. Je ne pense pas avoir vraiment mis quelque chose sur Internet sans le guidage d'un tutoriel avant le cinquième mois !

Cela m'a donné l'impression que la programmation était une lutte sisyphienne. J'étais convaincu que les programmeurs apparemment normaux que je rencontrais étaient en réalité des sociopathes qui avaient vécu, puis réprimé, le traumatisme d'apprendre à coder.

Contrastons cela avec mes collègues, qui rencontraient rarement des erreurs de syntaxe parce que leurs IDEs les attrapaient en premier. Les MacBooks de mes collègues fonctionnaient simplement. S'ils recevaient un message d'erreur et ne pouvaient pas le résoudre en quelques minutes de lecture et de recherche sur Google, ils s'envoyaient simplement des messages instantanés pour demander de l'aide pour le déboguer. Ils passaient de bureau en bureau et programmaient en binôme de manière décontractée.

Il n'y avait pas beaucoup d'ego ou d'élitisme. Il n'y avait pas cette impression que la programmation était une corvée. C'était simplement une série de conversations constructives entre des adultes amicaux, plusieurs d'entre eux ayant appris à coder par eux-mêmes comme moi.

L'équipe était engagée dans ses outils. Mis à part les jours de Passion Project et les hackathons où les développeurs pouvaient expérimenter de nouveaux frameworks JavaScript comme Angular.js, ils se concentraient principalement sur l'amélioration de leur technologie actuelle. Ils étaient conservateurs quant à ce qu'ils permettaient dans leur base de code.

On voit cette même éthique dans des endroits comme [ThoughtBot](http://playbook.thoughtbot.com/), où tout le monde reste avec une petite mais efficace chaîne d'outils (dans leur cas, Rails, Vim, Postgres et Redis). En se concentrant sur quelques outils clés, leurs ingénieurs deviennent des experts qui peuvent facilement interagir.

Donc la vraie question est, si des équipes très productives d'ingénieurs en logiciel travaillent mieux avec un ensemble d'outils concentré, les personnes apprenant à programmer ne pourraient-elles pas aussi apprendre mieux avec un ensemble d'outils concentré ? Les curricula de codage en ligne et les bootcamps de codage semblent certainement le penser.

Mais en tant qu'individu, avec autant d'options disponibles, il est vraiment difficile de décider quoi apprendre. Je le sais parce que j'étais ce chien tournant autour d'une intersection, courant après une voiture après l'autre. Les compétences d'un bon programmeur peuvent être décrites comme en forme de T, avec des connaissances superficielles dans de nombreux domaines, mais des connaissances approfondies dans au moins un. Mais après des mois de stress et de travail acharné, j'étais plutôt formé comme un underscore.

Pour chaque personne que j'ai rencontrée qui a commencé à apprendre de cette manière  et j'en ai rencontré beaucoup , il y a probablement des milliers de personnes qui ont commencé de cette manière, se sont découragées et ont abandonné leurs rêves de devenir programmeur. Je ne veux pas que cela vous arrive.

### Vous devez vous concentrer

![Image](https://www.freecodecamp.org/news/content/images/2020/03/1_QQXBnqz3RrvlySiBew5b9g.jpeg)

Sans plus attendre, voici les grandes erreurs que je vois les nouveaux codeurs faire tout le temps :

* Changer fréquemment de langages ou de frameworks, ou se duper en pensant pouvoir devenir compétent dans tous.
* Personnaliser leur environnement de développement avec des outils exotiques, plutôt que des outils plus conventionnels qui peuvent être utilisés de manière fiable lors de la collaboration avec d'autres.
* Essayer d'apprendre des outils comme Docker et Famo.us parce qu'ils sont nouveaux et excitants, même s'ils n'ont pas encore maîtrisé des technologies plus fondamentales.

Si je devais résumer mon conseil "faites comme je dis, pas comme j'ai fait" en un mot, ce serait : **concentration**.

Ma question pour vous est : décririez-vous vos plans pour apprendre à coder comme concentrés ? Si vous pensez que vos plans sont concentrés, vous devriez arrêter de lire maintenant et retourner à vos études, car je ne veux pas dire quelque chose qui pourrait vous faire perdre votre concentration. Si vous n'avez pas encore concentré vos plans pour apprendre à coder, j'ai une bonne nouvelle  vous pouvez le faire maintenant. Mais cela prendra quelques minutes et impliquera de prendre des décisions difficiles. Attendez ! Ne partez pas Oh, bien. Vous êtes toujours là. D'accord, voici les décisions que vous devez prendre :

1. Choisissez **un** type de développement logiciel qui vous intéresse suffisamment pour définir votre carrière : web, mobile, gaming ou embarqué. Je recommande le web parce qu'il est flexible. Il y a beaucoup d'emplois et beaucoup de ressources d'apprentissage. Si vous êtes passionné par autre chose que le développement web, quittez cet article de blog et cherchez "getting started in _____ development" et lancez-vous à fond !
2. Choisissez **un** langage à apprendre : JavaScript, Ruby ou Python. Chacun a ses forces. Chacun a des outils qui peuvent être utilisés pour construire des applications web (Node.js, Rails et Django respectivement). À moins que vous n'ayez déjà une forte préférence, je recommande JavaScript parce que c'est le langage le plus populaire.
3. Choisissez **un** curriculum en ligne à étudier. Si vous apprenez JavaScript, [freeCodeCamp.org](http://freecodecamp.com/) en a un complet. Faites confiance à la sagesse des enseignants qui ont conçu le curriculum que vous avez choisi, et travaillez-le dans l'ordre recommandé, sans sauter.

Une fois que vous aurez pris ces décisions, la voie à suivre est simple. Gardez votre santé mentale en ignorant le battage médiatique autour des nouveaux outils. Gardez votre élan en travaillant sur votre curriculum choisi sept jours par semaine, même si ce n'est que pendant trente minutes à la fois. Gardez votre confiance en faisant confiance au jugement que vous avez fait avec les décisions d'aujourd'hui.

Et rappelez-vous : avec de la patience, toute personne douée d'esprit peut devenir un grand codeur, et cela inclut vous.

**Je n'écris que sur la programmation et la technologie. Si vous [me suivez sur Twitter](https://twitter.com/ossia) je ne perdrai pas votre temps. ?**