---
title: Les algorithmes expliqués - Ce qu'ils sont et les algorithmes de tri courants
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2020-02-01T00:00:00.000Z'
originalURL: https://freecodecamp.org/news/algorithms-explained-what-they-are-and-common-sorting-algorithms
coverImage: https://cdn-media-2.freecodecamp.org/w1280/5f9c9cf4740569d1a4ca351d.jpg
tags:
- name: algorithms
  slug: algorithms
- name: toothbrush
  slug: toothbrush
seo_title: Les algorithmes expliqués - Ce qu'ils sont et les algorithmes de tri courants
seo_desc: 'In its most basic form, an algorithm is a set of detailed step-by-step
  instructions to complete a task. For example, an algorithm to make coffee in a french
  press would be:


  Pour water into the kettle, close the lid, and turn it on.

  Take the lid off ...'
---

Dans sa forme la plus basique, un algorithme est un ensemble d'instructions détaillées étape par étape pour accomplir une tâche. Par exemple, un algorithme pour faire du café dans une cafetière à piston serait :

1. Versez de l'eau dans la bouilloire, fermez le couvercle et allumez-la.
2. Retirez le couvercle de la cafetière à piston et versez 17 grammes de café moulu.
3. Lorsque l'eau dans la bouilloire bout, versez 290 grammes d'eau chaude dans la cafetière à piston.
4. Remettez le couvercle de la cafetière à piston avec le piston relevé.
5. Attendez 4 minutes.
6. Appuyez doucement sur le piston jusqu'à ce qu'il atteigne le fond.
7. Versez le café dans une tasse.

En informatique, les algorithmes courants ont des noms comme "Quicksort" et "Bogosort". Les algorithmes sont souvent regroupés en différentes catégories comme les algorithmes de recherche, de tri et de compression. De plus, les algorithmes peuvent être décrits par l'approche qu'ils utilisent pour accomplir une tâche, tels que récursif, retour sur trace, diviser pour régner, glouton et force brute.

Les algorithmes sont souvent associés aux structures de données, bien qu'ils soient fondamentalement différents. Les structures de données sont des méthodes de stockage de données afin qu'un algorithme puisse effectuer des opérations facilement.

Quelques exemples courants de structures de données sont les tableaux, les piles, les files d'attente, les listes chaînées, les arbres, les graphes, les tables de hachage et les tas.

## Efficacité

Les algorithmes sont souvent jugés et comparés en fonction de leur efficacité et des ressources qu'ils nécessitent. L'une des méthodes les plus courantes pour évaluer un algorithme est d'examiner sa complexité temporelle à travers une méthode appelée [notation Big O](https://www.freecodecamp.org/news/p/82641774-9214-44c7-8b92-469c2b56c2da/www.freecodecamp.org/news/big-o-notation-explained-with-examples/).

La notation Big O est un moyen de décrire la vitesse ou la complexité d'un algorithme, et montre le nombre maximal d'opérations pour une taille d'entrée donnée. Il est important de comprendre le temps d'exécution possible pour différents algorithmes, surtout lorsque l'on travaille avec des ensembles de données volumineux ou en croissance. La notation Big O facilite le choix du bon algorithme pour chaque tâche.

## Algorithmes de tri

Les algorithmes de tri viennent en différentes variantes selon vos besoins. Certains, très courants et largement utilisés sont :

### Tri rapide

Aucune discussion sur le tri n'est complète sans mentionner le [Tri rapide](https://www.freecodecamp.org/news/an-intro-to-advanced-sorting-algorithms-merge-quick-radix-sort-in-javascript-b65842194597/#tri-rapide).

### Tri par fusion

L'algorithme de [Tri par fusion](https://www.freecodecamp.org/news/an-intro-to-advanced-sorting-algorithms-merge-quick-radix-sort-in-javascript-b65842194597/#tri-par-fusion) repose sur la division et le tri de tableaux plus petits avant de les fusionner en un seul tableau trié.

Le programme de freeCodeCamp insiste fortement sur la création d'algorithmes. Cela est dû au fait que l'apprentissage des algorithmes est un bon moyen de pratiquer les compétences en programmation. Les recruteurs testent le plus souvent les candidats sur les algorithmes lors des entretiens d'embauche pour les développeurs.