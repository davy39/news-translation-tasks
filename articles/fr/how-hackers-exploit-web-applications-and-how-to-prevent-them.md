---
title: Principales méthodes utilisées par les hackers pour exploiter les applications
  web (et comment les prévenir)
subtitle: ''
author: Manish Shivanandhan
co_authors: []
series: null
date: '2025-05-13T14:18:45.581Z'
originalURL: https://freecodecamp.org/news/how-hackers-exploit-web-applications-and-how-to-prevent-them
coverImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1747060147180/03146ca3-bc12-4d00-bdde-985817a0893c.png
tags:
- name: Security
  slug: security
- name: cybersecurity
  slug: cybersecurity
seo_title: Principales méthodes utilisées par les hackers pour exploiter les applications
  web (et comment les prévenir)
seo_desc: 'Every website that takes user input is a potential target for an attacker.

  You might think your app is too small or too new to get noticed, but attackers use
  tools to scan the web for common security mistakes.

  If your site is online and has a login f...'
---

Chaque site web qui accepte des entrées utilisateur est une cible potentielle pour un attaquant.

Vous pourriez penser que votre application est trop petite ou trop récente pour être remarquée, mais les attaquants utilisent des outils pour scanner le web à la recherche d'erreurs de sécurité courantes.

Si votre site est en ligne et dispose d'un formulaire de connexion, d'une boîte de recherche ou d'une base de données, il est déjà en train d'être testé.

Mais voici la bonne nouvelle : vous n'avez pas besoin d'être un expert en cybersécurité pour protéger votre application. Vous devez simplement comprendre comment ces attaques fonctionnent et écrire un code plus sûr.

Passons en revue dix des méthodes les plus courantes utilisées par les hackers pour pirater les applications web – et comment corriger chacune d'entre elles, avec des exemples clairs.

### Voici ce que nous allons couvrir :

1. [Injection SQL](#heading-injection-sql)

2. [Cross-Site Scripting (XSS)](#heading-cross-site-scripting-xss)

3. [Cross-Site Request Forgery (CSRF)](#heading-cross-site-request-forgery-csrf)

4. [Authentification cassée ou faible](#heading-authentification-cassee-ou-faible)

5. [Références directes à des objets non sécurisées (IDOR)](#heading-references-directes-a-des-objets-non-securisees-idor)

6. [Mauvaise configuration de sécurité](#heading-mauvaise-configuration-de-securite)

7. [Exposition de données sensibles](#heading-exposition-de-donnees-sensibles)

8. [Utilisation de bibliothèques obsolètes](#heading-utilisation-de-bibliotheques-obsoletes)

9. [Contrôle d'accès défaillant](#heading-controle-dacces-defaillant)

10. [Absence de journalisation ou de surveillance](#heading-absence-de-journalisation-ou-de-surveillance)

11. [Conclusion](#heading-conclusion)

## Injection SQL

Les hackers exploitent cela lorsque votre application leur permet d'envoyer des commandes SQL brutes directement à votre base de données. Voici un exemple non sécurisé en PHP :

```php
$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password';
```

Si un utilisateur entre ceci comme nom d'utilisateur :

```plaintext
' OR 1=1 --
```

La requête devient :

```sql
SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = '';
```

Cela retourne tous les utilisateurs – car `1=1` est toujours vrai. Cela signifie que n'importe qui peut se connecter sans connaître de mot de passe.

Cela s'appelle la *construction de chaîne*, où l'entrée utilisateur est directement insérée dans la commande SQL. Elle traite l'entrée comme une partie du code, et non comme de simples données.

### **La solution : utiliser des requêtes préparées**

Les requêtes préparées séparent le code des données. La commande SQL est définie une fois, et les valeurs utilisateur sont passées séparément – de sorte qu'elles ne peuvent pas briser la logique.

Voici la même requête en utilisant PHP avec PDO :

```php
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->execute([$username, $password]);
```

Cela rend votre code immunisé contre l'injection SQL – même si un utilisateur essaie d'injecter une entrée malveillante.

## Cross-Site Scripting (XSS)

Supposons que votre site affiche des commentaires. Si quelqu'un publie ceci :

```html
<script>alert('Attrapé !');</script>
```

Et que votre site l'affiche tel quel, chaque visiteur voit une popup. C'est une attaque XSS basique. Un vrai attaquant pourrait faire bien pire – comme voler des cookies de session ou rediriger les utilisateurs vers de fausses pages de connexion.

### **La solution : échapper ce que vous affichez**

Échapper signifie convertir des caractères spéciaux comme `<` et `>` en texte inoffensif.

En PHP :

```php
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');
```

En JavaScript, vous pouvez utiliser des bibliothèques comme DOMPurify :

```js
const safeHTML = DOMPurify.sanitize(userInput);
```

Ne faites jamais confiance à l'entrée utilisateur – surtout lorsque vous la réinsérez dans votre HTML.

## Cross-Site Request Forgery (CSRF)

Le CSRF trompe le navigateur d'un utilisateur connecté pour qu'il effectue une requête non désirée sur votre site – sans qu'il le sache.

Voici comment cela fonctionne : un utilisateur se connecte à votre application, puis visite un site malveillant. Ce site contient du code comme :

```html
<img src="https://votreapp.com/supprimer-compte" />
```

Puisque l'utilisateur est déjà connecté, son navigateur envoie la requête – avec les cookies et tout. Si votre application ne vérifie pas le CSRF, elle suppose que l'utilisateur voulait supprimer son compte.

### **La solution : utiliser des jetons CSRF**

Ce sont des valeurs uniques et secrètes incluses dans les formulaires :

```html
<input type="hidden" name="csrf_token" value="abc123">
```

Votre serveur doit vérifier ce jeton à chaque requête. S'il est manquant ou incorrect, rejetez la requête. La plupart des frameworks (comme Laravel ou Django) font cela automatiquement.

## Authentification cassée ou faible

Si votre système de connexion est trop simple, c'est une cible facile.

**Erreur courante :** stocker les mots de passe en texte brut :

```php
file_put_contents('users.txt', "$username:$password\n");
```

Si ce fichier est divulgué, tous les comptes utilisateur sont exposés.

### **La solution : hacher les mots de passe**

```php
$hash = password_hash($password, PASSWORD_DEFAULT);
```

Et pour les vérifier plus tard :

```php
if (password_verify($password, $storedHash)) {
    // Connexion réussie
}
```

Autres corrections critiques :

* **Limiter le taux de tentatives de connexion :** Bloquer ou retarder après 5 essais échoués.

* **Ajouter une authentification multifacteur (MFA) :** Envoyer un code à usage unique par e-mail ou application.

* **Utiliser des politiques de mots de passe robustes :** Exiger des mots de passe plus longs avec un mélange de caractères.

Chaque étape rend les attaques par force brute plus difficiles et protège les comptes utilisateur.

## Références directes à des objets non sécurisées (IDOR)

Supposons que votre site a cette URL :

```plaintext
/facture?id=123
```

Un hacker essaie :

```plaintext
/facture?id=124
```

Soudain, ils peuvent voir la facture de quelqu'un d'autre.

### **La solution : vérifier la propriété**

```php
$stmt = $pdo->prepare("SELECT * FROM invoices WHERE id = ? AND user_id = ?");
$stmt->execute([$invoiceId, $loggedInUserId]);
```

Toujours confirmer que l'utilisateur connecté est propriétaire des donnéesqu'il essaie d'accéder.

## Mauvaise configuration de sécurité

Cela fait référence à l'utilisation de paramètres par défaut non sécurisés ou à l'oubli de désactiver des choses qui ne devraient pas être publiques.

**Exemples incluent :**

* Laisser les messages d'erreur activés en production (`display_errors = 1`)

* Exposer des panneaux d'administration ou des outils de débogage

* Utiliser des mots de passe par défaut ou des logiciels obsolètes

Ce ne sont pas des bugs dans votre code – mais ils sont tout aussi dangereux.

### **La solution :** désactiver les rapports d'erreur détaillés en production :

```php
ini_set('display_errors', 0);
```

Et sécuriser les outils d'administration avec des mots de passe, des listes d'autorisation d'IP, ou les déplacer derrière un VPN ou un chemin privé.

## Exposition de données sensibles

Si vous envoyez des données utilisateur via HTTP au lieu de HTTPS, n'importe qui sur le réseau peut les lire – comme des mots de passe ou des numéros de carte de crédit.

**Exemple de code non sécurisé :**

```php
file_put_contents('logs.txt', "User: $username, Password: $password");
```

Si ce fichier de log est exposé, tous les mots de passe sont divulgués.

**Solutions :**

* Utiliser HTTPS partout. Des outils comme [Let's Encrypt](https://letsencrypt.org/) le rendent gratuit et facile.

* Ne jamais stocker de mots de passe dans les logs.

* Chiffrer les données sensibles au repos, surtout si ce sont des informations personnellement identifiables (PII) ou des données financières.

## Utilisation de bibliothèques obsolètes

La plupart des applications utilisent des bibliothèques externes. Si l'une d'entre elles a une vulnérabilité connue, les attaquants peuvent l'exploiter – même si votre code est parfait.

**Pour vous protéger :**

* Mettre à jour régulièrement les dépendances. En Node.js :

```bash
npm audit fix
```

* En PHP :

```bash
composer update
```

* Remplacer les bibliothèques non maintenues par des alternatives plus sûres.

## Contrôle d'accès défaillant

Certaines applications essaient de contrôler l'accès simplement en cachant des boutons sur l'interface utilisateur.

**Exemple :** Un utilisateur n'est pas montré le bouton "supprimer le post" – mais il envoie manuellement une requête comme :

```http
POST /supprimer-post?id=5
```

Si le backend ne vérifie pas les permissions, la requête passe.

### **La solution : appliquer le contrôle d'accès sur le backend**

```php
if ($user->role !== 'admin') {
    http_response_code(403);
    exit;
}
```

Ne vous fiez pas au front-end pour bloquer les actions. Le serveur doit vérifier chaque requête et confirmer que l'utilisateur est autorisé à effectuer l'action.

## Absence de journalisation ou de surveillance

Si quelque chose de suspect se produit et que vous n'avez pas de logs, vous ne le saurez jamais.

**Exemple d'entrée de log (dans Laravel) :**

```php
Log::info('Connexion utilisateur', ['user_id' => $user->id]);
```

Configurez des alertes pour les comportements suspects – comme 100 tentatives de connexion échouées en 10 minutes. Utilisez des outils de surveillance comme Sentry, Datadog ou ELK Stack pour surveiller votre application en temps réel.

Si vous ne suivez pas ce qui se passe, vous ne pourrez pas l'arrêter lorsque les choses tournent mal.

## Conclusion

Les hackers n'ont pas besoin d'outils avancés. La plupart cherchent simplement des victoires faciles – des formulaires non échappés, des mots de passe en texte brut, des bibliothèques obsolètes ou des zones d'administration exposées.

Si vous suivez les bases de ce guide, vous bloquerez 90 % de ces attaques.

Vous n'avez pas besoin de tout corriger aujourd'hui. Commencez par un élément. Échappez les entrées utilisateur. Utilisez HTTPS. Ajoutez une protection CSRF. Chaque correction rend votre application un peu plus sûre.

**Vous voulez en savoir plus ?** Acquérez des bases solides en sécurité offensive – suivez le cours [*Security Starter*](https://start.stealthsecurity.sh/).