---
title: Apprenez les fondamentaux d'un bon état d'esprit de développeur en 15 minutes
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2019-04-05T21:07:49.000Z'
originalURL: https://freecodecamp.org/news/learn-the-fundamentals-of-a-good-developer-mindset-in-15-minutes-81321ab8a682
coverImage: https://cdn-media-1.freecodecamp.org/images/0*9aI9Xrj0_SpE9KbK.jpg
tags:
- name: coding
  slug: coding
- name: General Programming
  slug: programming
- name: 'self-improvement '
  slug: self-improvement
- name: software development
  slug: software-development
- name: 'tech '
  slug: tech
seo_title: Apprenez les fondamentaux d'un bon état d'esprit de développeur en 15 minutes
seo_desc: 'By Huseyin Polat Yuruk

  “Difficult to make even small changes”

  “Breaking functionality of the software by making changes”

  “Introducing a new bug by fixing another one”

  “Implementing code that is unnecessary”

  “Almost impossible to add a new feature bec...'
---

Par Huseyin Polat Yuruk

_Difficile de faire même de petits changements_

_Casser la fonctionnalité du logiciel en faisant des changements_

_Introduire un nouveau bug en corrigeant un autre_

_Implémenter du code qui est inutile_

_Presque impossible d'ajouter une nouvelle fonctionnalité à cause du code compliqué_

_Le produit jamais livré_

_Jeter du code et tout réécrire depuis le début_

Toutes les déclarations ci-dessus vous sont-elles familières ?

Chaque minute, un développeur quelque part dans le monde dit (ou pense) l'une des déclarations ci-dessus et souhaite pleurer. Pourquoi ?

Ce sont des problèmes courants dont parlent très souvent les développeurs. Ces histoires sont vécues dans chaque équipe de développement.

Il y a de nombreux petits facteurs qui nuisent lentement et progressivement aux projets des développeurs. Ils ne sont pas immédiatement destructeurs. La plupart d'entre eux ne font que des dégâts à long terme. Quelque chose que vous ne verrez pas avant un an ou plus. Donc, lorsque quelqu'un les propose, ils semblent souvent inoffensifs.

Même lorsque vous commencez à les implémenter, ils peuvent sembler corrects. Mais avec le temps, et particulièrement lorsque de plus en plus de ces éléments s'accumulent, la complexité devient plus apparente et grandit jusqu'à ce que vous soyez une autre victime de cette histoire d'horreur si courante.

Pour éviter d'être l'une des victimes, vous devriez adopter les lois fondamentales du logiciel. Vous devriez développer un état d'esprit que chaque développeur devrait avoir. Cet état d'esprit vous aidera à prendre de meilleures décisions dans votre parcours de programmation quotidien. Vous pouvez garder votre logiciel aussi simple que possible. Vous pouvez le protéger de devenir un système ingérable et complexe.

Voici les points clés que chaque développeur doit maîtriser.

### 1. Concevoir le but du logiciel

Tout d'abord, vous devriez comprendre le but du logiciel. Il y a, en fait, un seul but pour tous les logiciels : **Aider les gens**.

> **Rappelez-vous : le but du logiciel n'est pas de montrer à quel point vous êtes intelligent.**

[Max Kanat-Alexander, Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)

Les développeurs qui ne peuvent pas concevoir le but du logiciel écriront de mauvais logiciels. Qu'est-ce qu'un mauvais logiciel ? Un système complexe qui n'aide pas beaucoup les gens.

Lorsque vous prenez des décisions concernant le logiciel, vous devriez vous guider en gardant toujours cela à l'esprit : _Comment pouvons-nous aider ?_ Vous pouvez même prioriser les demandes de fonctionnalités de cette manière.

### 2. Les objectifs de la conception de logiciels

**Chaque programmeur est un designer.**

Lorsque le logiciel est difficile à créer ou à modifier, les développeurs passent la plupart de leur temps à se concentrer sur le fait de faire en sorte que les choses fonctionnent simplement, et moins de temps à se concentrer sur l'aide aux utilisateurs. La conception de logiciels vise à rendre le travail des développeurs aussi facile que possible afin qu'ils puissent se concentrer sur ce qui compte. Vous créerez des logiciels qui aideront les utilisateurs et votre logiciel continuera à les aider pendant longtemps.

Cependant, si vous concevez un mauvais système, la durée de vie de votre logiciel sera courte.

Cela nous amène à l'objectif le plus important de la conception de logiciels :

> _Concevoir des systèmes qui peuvent être créés et maintenus aussi facilement que possible par leurs développeurs, afin qu'ils puissent être

et continuer à être

aussi utiles que possible.  [Max Kanat-Alexander, Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)_

Il y a donc deux points clés ici : Votre conception doit être facile pour vous et utile pour les autres.

### 3. (In)compréhension

Les développeurs qui ne comprennent pas pleinement leur travail tendent à développer des systèmes complexes. Cela peut devenir un cercle vicieux : l'incompréhension mène à la complexité, qui mène à une incompréhension supplémentaire, et ainsi de suite.

En fait, l'une des meilleures façons d'améliorer vos compétences en conception est de vous assurer que vous comprenez pleinement les systèmes et les outils avec lesquels vous travaillez.

> **La compréhension est la différence clé entre un mauvais développeur et un bon développeur.**

[Max Kanat-Alexander, Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)

Les mauvais développeurs ne comprennent pas ce qu'ils font, et les bons développeurs le comprennent. C'est vraiment aussi simple que cela.

### 4. Simplicité

> _La simplicité est la sophistication ultime.

Leonardo da Vinci_

Programmer, c'est réduire la complexité à la simplicité. Un mauvais développeur est simplement quelqu'un qui ne parvient pas à réduire la complexité. Un bon développeur fait tout ce qui est en son pouvoir pour rendre le code aussi simple que possible pour les autres programmeurs.

Un bon développeur crée des choses faciles à comprendre afin qu'il soit vraiment facile d'éliminer tous les bugs.

Maintenant, les développeurs sont généralement des personnes intelligentes et aucun d'entre eux n'aime être traité comme s'ils étaient idiots. Ironiquement, cela les amène parfois à créer des choses un peu compliquées. Ils pensent essentiellement comme ceci :

_Oh, les autres développeurs comprendront tout ce que j'ai fait ici. Je devrais écrire du code astucieux qui est difficile à comprendre afin qu'ils puissent penser que je suis très intelligent._

Une erreur causée par un mauvais état d'esprit, pas nécessairement par un manque de compétences en programmation. La plupart des échecs de programmation se produisent à cause de cette mentalité.

Montrer à quel point vous êtes intelligent ne les aide pas.

Les développeurs qui sont nouveaux dans votre code ne savent rien à son sujet ; **ils doivent apprendre.**

Donc, vous devriez poser cette question : _Veux-je que les gens comprennent cela et soient heureux, ou veux-je qu'ils soient confus et frustrés ?_

La vérité est que si d'autres développeurs qui lisent votre code peuvent le comprendre facilement, cela signifie que vous faites du bon travail.

> _La complexité n'a rien à voir avec l'intelligence, la simplicité oui.

Larry Bossidy_

La question est : _À quel point devez-vous être simple ?_

Voici votre réponse : **_Stupide, simple._**

### 5. Complexité

> _Contrôler la complexité est l'essence de la programmation informatique.

Brian Kernighan_

La source de nombreux échecs de logiciels est la complexité. Vous commencez avec un projet simple qui peut être terminé en un mois. Ensuite, vous ajoutez de la complexité, et la tâche prendra jusqu'à trois mois. Ensuite, vous commencez à ajouter des fonctionnalités qui remplissent un autre objectif. Les choses deviennent très complexes parce que vous étendez le but de votre logiciel sans raison. Les tâches prendront six mois.

Mais ce n'est pas la fin.

Ensuite, vous prenez chaque partie de la fonctionnalité et la rendez encore plus complexe, et la tâche prendra neuf mois. Ensuite, vous commencez à introduire de nombreux nouveaux bugs à cause de la complexité dans votre code. Naturellement, vous commencez à les corriger tous sans penser à la manière dont ces corrections affecteront les autres parties. À la fin, lorsque même de petits changements deviennent difficiles. Lorsque les corrections de bugs commencent à introduire de nouveaux bugs, vous arriverez à l'une des histoires d'horreur de programmation les plus populaires : _Réécrire le code depuis le début_.

Alors, comment êtes-vous devenu une victime de cette histoire d'horreur ? Nah, qui s'en soucie. Il est préférable de demander : Comment auriez-vous pu éviter d'être une victime ?

Eh bien, c'est simple. Premièrement, vous connaîtrez exactement le but de votre logiciel et sa définition. Deuxièmement, vous serez aussi simple que possible dans chaque morceau de code que vous écrivez. Troisièmement, lorsqu'une nouvelle fonctionnalité ou une demande de changement arrive à la table de discussion, vous les évaluerez en fonction du but de votre logiciel et vous les questionnerez.

En tant que développeur, votre premier comportement devrait être la résistance au changement (inutile). Cela vous empêchera d'ajouter des codes inutiles à votre logiciel. Lorsque vous êtes convaincu que ce changement est nécessaire, alors vous pouvez l'implémenter.

Il y a de nombreux facteurs qui augmenteront la complexité, mais ce sont les plus populaires. En dehors de tout, il n'y a qu'une seule règle que vous devriez suivre :

**Votre objectif principal est de contrôler la complexité, pas de la créer.**

### 6. Maintenance

La maintenance est l'une des choses les plus importantes dans le développement de logiciels. Malheureusement, les développeurs ignorent généralement à quel point elle est importante. Le codage rapide et la livraison rapide semblent plus importants que la maintenance du code. C'est le point où ils font une erreur

l'ignorance de la future maintenance du code.

Il y aura toujours une certaine implémentation de changements. Non seulement vous devez les implémenter, mais vous devez également les maintenir au fil du temps. En tant que développeur, penser à la future maintenance des changements est l'une de vos principales responsabilités.

> _Tous les changements nécessitent de la maintenance._

> La simplicité et la complexité sont les deux principaux facteurs qui affectent la maintenance du code. La facilité de maintenance de tout logiciel est proportionnelle à la simplicité de ses pièces individuelles. L'effort de maintenance est proportionnel à la complexité du logiciel.

> La seule règle que vous devriez suivre concernant la maintenance est :

> **Il est plus important de réduire l'effort de maintenance que de réduire l'effort d'implémentation.**

>  [Max Kanat-Alexander, Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)

### 7. Cohérence

> La cohérence fait partie intégrante de la simplicité. Si vous faites quelque chose d'une certaine manière à un endroit, faites-le de cette manière à chaque endroit. Par exemple, si vous nommez une variable thisIsVariable, alors toutes vos variables doivent être nommées de cette manière (otherVariable, anAnotherVariable, etc. et non other_variable).  [Max Kanat-Alexander, Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)

Le code qui n'est pas cohérent devient plus difficile à comprendre. Ne forcez pas les développeurs à réapprendre le fonctionnement de votre système chaque fois qu'ils regardent une nouvelle partie de celui-ci.

> _Dans tout sport d'équipe, les meilleures équipes ont de la cohérence et de la chimie.

Roger Staubach_

### 8. Priorisation

Comment prenez-vous des décisions concernant votre logiciel ?

Lorsque vous êtes confronté à de nombreuses directions possibles, comment décidez-vous quelle option est la meilleure ? Sur quoi vous concentrer et quelles fonctionnalités vous devriez implémenter ?

Pour répondre à ces questions, il y a trois facteurs importants qui vous aideront à prendre une meilleure décision. Cette équation est très bien expliquée dans le livre [Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848) :

* **La désirabilité d'un changement (D)** : À quel point voulez-vous que ce changement se produise ?
* **La valeur d'un changement (V)** : Quelle valeur offre le changement ? À quel point aide-t-il vos utilisateurs ?
* **L'effort requis pour effectuer le changement (E)** : Combien de travail devrez-vous faire pour accomplir ce changement ?

L'équation est simple : **D=V/E**

> La désirabilité de tout changement est **directement proportionnelle à la valeur du changement et inversement proportionnelle à l'effort impliqué** dans la réalisation du changement.  [Code Simplicity](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA10&lpg=PA10&dq=The+desirability+of+any+change+is+directly+proportional+to+the+value+of+the+change+and+inversely+proportional+to+the+effort+involved+in+making+the+change.&source=bl&ots=wHr7P9wmmS&sig=ACfU3U2e8gccv3dI9dLceJk1_E1sfK5bsQ&hl=en&sa=X&ved=2ahUKEwjQoOrw9pXoAhUhoFsKHRWaBkIQ6AEwAnoECAoQAQ#v=onepage&q=The%20desirability%20of%20any%20change%20is%20directly%20proportional%20to%20the%20value%20of%20the%20change%20and%20inversely%20proportional%20to%20the%20effort%20involved%20in%20making%20the%20change.&f=false)

Lorsque vous priorisez votre travail, vous devriez suivre cette règle :

Les changements qui vous apporteront beaucoup de valeur et nécessiteront peu d'efforts sont meilleurs que ceux qui apporteront peu de valeur et nécessiteront beaucoup d'efforts.

### 9. Résolution de problèmes

La première étape est la compréhension. Sachez exactement ce qui est demandé. La plupart des problèmes difficiles sont difficiles parce que vous ne les comprenez pas. Écrivez votre problème et essayez de l'expliquer à quelqu'un d'autre.

> _Si vous ne pouvez pas expliquer quelque chose en termes simples, vous ne le comprenez pas.

Richard Feynman_

La deuxième étape est la planification. Ne prenez pas d'action. Dormez dessus. Donnez à votre cerveau un peu de temps pour analyser le problème et traiter l'information, mais ne passez pas trop de temps à planifier.

**Réfléchissez avant d'agir.**

La troisième étape est la division. N'essayez pas de résoudre un gros problème. Lorsque vous regardez le problème dans son ensemble, il peut vous faire peur. Divisez-le en tâches plus petites et résolvez chaque sous-problème un par un. Une fois que vous avez résolu chaque sous-problème, vous connectez les points.

### 10. Assez bien, c'est bien

> _Le parfait est l'ennemi du bien.

Voltaire_

Que ce soit pour créer un nouveau projet ou ajouter une fonctionnalité à un système existant, les développeurs tendent à tout planifier en détail dès le début.

Ils veulent que la première version soit parfaite. Ils ne se concentrent pas sur le problème qu'ils vont résoudre et sur la manière dont leur logiciel va aider les gens.

Ils commencent par penser à chaque petit détail auquel ils pourraient penser. Ensuite, des hypothèses et des prédictions viennent, suivies de phrases Et si. Ils doivent prédire l'avenir parce qu'ils sont maintenant si captivés par l'imagination du projet dans leur esprit et leur projet doit être aussi parfait qu'ils l'ont imaginé.

En fait, ils ne sont pas conscients de ce qui les attend et de ce que cela leur coûtera en poursuivant la perfection.

Permettez-moi de vous dire ce qui va se passer :

* Vous allez écrire du code qui n'est pas nécessaire
* Vous allez augmenter la complexité en ajoutant des codes inutiles
* Vous allez être trop générique
* Vous allez manquer des délais
* Vous allez devoir gérer de nombreux bugs causés par la complexité

Voulez-vous que cela se produise ? Je suppose que non.

Que devriez-vous faire à la place ?

**Commencez petit, améliorez-le, puis étendez-le.**

La conception incrémentielle devrait être votre guide. Voici comment vous pourriez l'utiliser pour concevoir une calculatrice :

1. Planifiez un système qui ne fait que l'addition et rien d'autre.
2. Implémentez-le.
3. Améliorez la conception du système maintenant existant afin de pouvoir ajouter d'autres opérations également.
4. Planifiez la soustraction et répétez les étapes 2 et 3.
5. Planifiez la multiplication et répétez les étapes 2 et 3.
6. Planifiez la division et répétez les étapes 2 et 3.

### 11. Prédictions

> _Une prédiction est simplement une prévision que quelque chose se produira dans le futur. Elle pourrait être factuelle et basée sur une sorte de données objectives ou elle pourrait être basée sur une hypothèse._

> Lorsqu'ils sont confrontés au fait que leur code changera dans le futur, certains développeurs tentent de résoudre le problème en concevant une solution si générique qu'elle (croient-ils) s'adaptera à toutes les situations futures possibles.  [Code Simplicity](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA28&lpg=PA28&dq=When+faced+with+the+fact+that+their+code+will+change+in+the+future,+some+developers+attempt+to+solve+the+problem+by+designing+a+solution+so+generic+that+(they+believe)+it+will+accommodate+to+every+possible+future+situation.&source=bl&ots=wHr7P9wpuX&sig=ACfU3U1P13XqQr5-_UpYhkSDYMXOU-lSdw&hl=en&sa=X&ved=2ahUKEwjn-Mqo-JXoAhXL854KHRSaBooQ6AEwAHoECAgQAQ#v=onepage&q=When%20faced%20with%20the%20fact%20that%20their%20code%20will%20change%20in%20the%20future%2C%20some%20developers%20attempt%20to%20solve%20the%20problem%20by%20designing%20a%20solution%20so%20generic%20that%20(they%20believe)%20it%20will%20accommodate%20to%20every%20possible%20future%20situation.&f=false)

**Être trop générique implique beaucoup de code qui n'est pas nécessaire.**

Vous ne pouvez pas prédire l'avenir, donc peu importe à quel point votre solution est générique, elle ne sera pas assez générique pour satisfaire les véritables exigences futures que vous aurez. Très probablement, ce moment ne viendra jamais et le code que vous avez écrit pour résoudre les problèmes futurs augmentera la complexité, rendra difficile la modification des morceaux de code et finira par devenir un fardeau qui pourrait détruire votre logiciel.

Ne prédisez pas l'avenir. Soyez seulement aussi générique que vous savez que vous devez l'être maintenant.

### 12. Hypothèses

Qu'est-ce qu'une hypothèse ?

> _Une **hypothèse** est quelque chose que vous acceptez comme vrai ou supposez être vrai, bien que vous n'ayez aucune preuve concluante._

L'un des grands tueurs d'un projet logiciel est les hypothèses. Voyons comment une hypothèse peut tuer un projet logiciel.

Un développeur sait qu'il doit développer un système pour faire X. Ensuite, il pense que le système nécessitera de faire Y dans le futur, et il implémente également Y. Il écrit des milliers de lignes de code pour concevoir Y.

Dans le futur, le développeur réalise que les exigences actuelles sont complètement différentes de ce qu'il pensait. Mais maintenant, le logiciel contient des codes inutiles qui rendent difficile de s'en débarrasser parce que tout est entrelacé. Il faut des mois pour refactoriser le code et maintenant ils pensent à réécrire tout le logiciel depuis le début, ce qui leur fera perdre des mois.

Pour éviter d'être une victime comme ce développeur, suivez cette règle simple :

> **Le code doit être conçu en fonction de ce que vous savez maintenant, et non de ce que vous pensez qui se passera dans le futur.**

 [Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)

### 13. Arrêtez de réinventer

Si, par exemple, vous inventez votre propre garbage collector alors qu'un parfaitement bon existe déjà, vous allez passer beaucoup de temps à travailler sur le garbage collector, alors que vous pourriez simplement travailler sur votre logiciel.

Les seules fois où il est acceptable de réinventer la roue sont lorsque l'une des situations suivantes est vraie :

* Vous avez besoin de quelque chose qui n'existe pas encore
* Toutes les roues existantes sont de mauvaises technologies ou incapables de gérer vos besoins
* Les roues existantes ne sont pas correctement maintenues

Règle simple :

**Ne réinventez pas la roue.**

### 14. Résistance

En tant que développeur, votre première réaction aux demandes de changement devrait être NON.

Résistez toujours à ajouter plus de code, plus de fonctionnalités jusqu'à ce que vous soyez convaincu qu'ils sont nécessaires et qu'il y a un besoin de les implémenter. Parce que les changements inutiles augmenteront les défauts dans votre logiciel.

Comment pouvez-vous savoir qu'il y a un besoin pour eux ?

Retournez en arrière et rappelez-vous le but de votre logiciel. Ensuite, rappelez-vous l'équation simple dans la section de priorisation.

```
De : rsc@plan9.bell-labs.com (Russ Cox)
Sujet : Re: [9fans] design clairvoyance & the 9 way
Date : Thu, 8 May 2003 04:05:31 GMT
> À quoi ressemble l'unix de demain ?
Je suis convaincu que l'Unix de demain ressemblera à l'Unix d'aujourd'hui, mais avec plus de cruft.
Russ
```

### 15. Automatisation

Ne passez pas votre temps sur des tâches répétitives. Configurez-les et oubliez-les. Elles peuvent travailler pendant que vous dormez. Lorsque vous réalisez que vous faites quelque chose encore et encore, rappelez-vous simplement cette règle :

**Si vous pouvez l'automatiser, automatisez-le.**

### 16. Mesure du code

> _Mesurer les progrès de la programmation par le nombre de lignes de code, c'est comme mesurer les progrès de la construction d'avions par le poids._  
> _ Bill Gates_

Je vois des développeurs qui mesurent la qualité de leur logiciel en fonction du nombre de lignes de code. Ils pensent que plus de lignes de code signifie qu'ils font un excellent travail. Le logiciel contient des centaines de milliers de lignes de code, ce qui signifie que le logiciel sur lequel ils travaillent est si grand.

La question qui se pose ici est : Est-il vraiment si grand, ou y a-t-il quelque chose qui ne va pas ?

La réponse est que très probablement il y a quelque chose qui ne va pas avec leur conception. La plupart des solutions simples ne nécessitent pas beaucoup de code. Vous pouvez atteindre la simplicité avec un petit ensemble de code et résoudre le problème.

Je ne dis pas que moins de lignes de code est toujours mieux. Bien que vous souhaitiez éviter d'avoir moins de code, vous pouvez facilement tomber dans un piège qui vous amènera à écrire du code astucieux qui est difficile à comprendre pour les autres. Vous devriez trouver un équilibre.

Le code optimal est un petit ensemble de code qui est facile à comprendre, facile à lire.

### 17. Productivité

Comment mesurez-vous votre productivité ?

En écrivant plus de lignes de code ou en jetant des centaines de lignes de code ?!

Votre objectif principal devrait être de garder votre base de code aussi petite que possible. La question n'est pas Comment puis-je écrire plus de code ? mais plutôt Comment puis-je supprimer plus de code ?

> _L'un de mes jours les plus productifs a été de jeter 1000 lignes de code.

Ken Thompson_

### 18. Tests

Quand devriez-vous ajouter la journalisation et la gestion des erreurs à votre projet ?

Vous devriez ajouter la journalisation très tôt. Cela vous aidera à trouver le problème facilement et à gagner du temps.

Je vois beaucoup d'erreurs en matière de test de code. Permettez-moi de vous donner un exemple. Il y avait deux conditions, un simple bloc if-else. Le développeur a donné une entrée au logiciel qui entrera dans le bloc if. Ils l'ont testé et ont validé le code dans le contrôle de source. Terminé ! 

Mais qu'en est-il du bloc else ? Lorsque le logiciel a été livré en production, cela a causé beaucoup d'erreurs. Lorsque vous testez votre code, vous devez exécuter toutes les nouvelles lignes au moins une fois et vous devriez commencer à tester les parties avant le tout.

Lorsque vous avez un bug, vous devez d'abord le reproduire. Vous ne devriez pas deviner la source du bug et appliquer des corrections basées sur votre hypothèse. Très probablement, vous aurez tort. Vous devriez le voir de vos propres yeux avant d'appliquer la correction.

Vous devez être fiable. Lorsque les autres développeurs de votre équipe voient que vous avez validé un nouveau code dans le contrôle de source, tout le monde doit savoir que votre code est testé et fonctionne.

**Le code non testé est le code qui ne fonctionne pas.**

### 19. (Sous-)Estimation

L'estimation des développeurs est mauvaise.

Généralement, ils sous-estiment les choses plutôt que de les surestimer. Ils sous-estiment le temps et l'effort nécessaires pour développer une petite quantité de code ou une fonctionnalité. À la fin, cette sous-estimation conduit à manquer des délais.

La solution : Divisez la grande chose en petites choses. Plus c'est petit, plus c'est facile à estimer. Vous allez probablement encore vous tromper, mais vous vous tromperez beaucoup moins que si vous estimiez un grand projet.

Rappelez-vous :

**Tout prend plus de temps que vous ne le pensez.**

### 20. Éviter de tout réécrire

Je crois que lorsque vous adoptez les principes fondamentaux du développement logiciel mentionnés dans cet article, vous n'en arriverez pas à ce point. Cependant, si, d'une manière ou d'une autre, vous faites ces erreurs et vous retrouvez à penser à réécrire votre code, voici la chose principale que vous devez savoir :

**Réécrire du code est souvent une illusion de développeur, pas la solution dans la plupart des cas.**

Pourquoi est-ce une illusion ?

Eh bien, parce qu'_il est plus difficile de lire du code que d'en écrire_. C'est pourquoi il est si difficile de réutiliser du code. C'est pourquoi notre subconscient nous murmure _Jetez-le et recommencez_ lorsque nous lisons le code d'un autre développeur.

Il y a de nombreux cas où vous devriez envisager de réécrire votre code depuis le début et vous pouvez les lire [ici](https://medium.freecodecamp.org/lessons-learned-in-my-10-years-as-a-developer-3d33c8702828). Mais voici un conseil simple pour vous :

**Le refactoring devrait être la première option.**

### 21. Documentation et commentaires

L'une des idées fausses courantes sur les commentaires est que les développeurs ajoutent des commentaires qui disent _ce que le code fait_. C'est faux. Cela devrait être évident en lisant le code. Si ce n'est pas évident, cela signifie qu'il n'est pas lisible et qu'il devrait être simplifié.

Lorsque vous ne pouvez pas rendre le code plus simple, vous devez ajouter le commentaire pour expliquer cette complexité.

> Le véritable but des commentaires est d'expliquer _POURQUOI_ vous avez fait quelque chose, et non _QUOI_ le code fait. Si vous n'expliquez pas cela, d'autres programmeurs pourraient être confus et lorsqu'ils iront modifier votre code, ils pourraient supprimer des parties importantes de celui-ci.  [Code Simplicity](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA46&lpg=PA46&dq=The+real+purpose+of+comments+is+to+explain+%E2%80%9CWHY%E2%80%9D+you+did+something,+not+%E2%80%9CWHAT%E2%80%9D+the+code+is+doing.+If+you+don%E2%80%99t+explain+this,+other+programmers+may+be+confused+and+when+they+go+to+change+your+code+they+might+remove+important+parts+of+it.&source=bl&ots=wHr7P9xnmU&sig=ACfU3U0qqYekJFrcrNUQfL9TzOR443NcpA&hl=en&sa=X&ved=2ahUKEwi56KH--pXoAhWFoFsKHYKoChoQ6AEwAHoECAoQAQ#v=onepage&q=The%20real%20purpose%20of%20comments%20is%20to%20explain%20%E2%80%9CWHY%E2%80%9D%20you%20did%20something%2C%20not%20%E2%80%9CWHAT%E2%80%9D%20the%20code%20is%20doing.%20If%20you%20don%E2%80%99t%20explain%20this%2C%20other%20programmers%20may%20be%20confused%20and%20when%20they%20go%20to%20change%20your%20code%20they%20might%20remove%20important%20parts%20of%20it.&f=false)

**Écrivez un commentaire pour expliquer POURQUOI, pas pour expliquer QUOI.**

Une autre chose est la documentation. Il est important d'avoir une documentation pour expliquer l'architecture de votre logiciel et chaque module et composant. Cela est nécessaire pour voir la vue d'ensemble de votre logiciel. 

Lorsque qu'un nouveau développeur rejoint votre équipe, il lui sera plus facile de comprendre le logiciel dans son ensemble. Lorsque les développeurs n'ont aucune idée des autres parties du logiciel, ils pourraient facilement faire une erreur dans leur propre partie, ce qui pourrait affecter les autres parties également.

### 22. Choix des technologies (Outils, Bibliothèques, etc.)

Tout d'abord, rappelez-vous toujours cette règle :

**Ne dépendez pas des technologies externes**. Mais lorsque vous devez le faire, essayez de **réduire votre dépendance à leur égard autant que** vous le pouvez**.**

Pourquoi cela ? Parce qu'elles sont une autre source courante de complexité. Elles peuvent tuer votre développement actif et rendre tout encore plus difficile. 

Lorsque vous dépendez trop des technologies externes, vous n'êtes pas libre. Et si il y a un bug majeur dans cette technologie ? Vous devez attendre que les développeurs corrigent ce bug et si cette technologie est au centre de votre projet, vous êtes essentiellement bloqué, vous ne pouvez pas avancer. C'est pourquoi il est si important de choisir les bonnes technologies pour votre projet.

Il y a quelques facteurs que vous devriez considérer avant de commencer à utiliser une technologie :

* Y a-t-il un développement actif derrière elle ?
* Sera-t-elle continue à être maintenue ?
* À quel point est-il facile de s'en éloigner ?
* Que dit la communauté à son sujet ?

Si vous pouvez trouver la bonne réponse à ces questions, vous pouvez réduire le risque de choisir la mauvaise technologie.

### 23. Développement personnel

Continuez à apprendre. Essayez différents langages de programmation et outils, lisez des livres sur le développement de logiciels. Ils vous donneront une autre perspective. Chaque jour, de petites améliorations feront une réelle différence dans vos connaissances et compétences.

Soyez ouvert d'esprit. Ne soyez pas obsédé par une technologie. Utilisez la technologie requise pour résoudre un problème spécifique. Ne vous engagez pas dans des discussions inutiles comme Microsoft vs Linux :)

**Sachez que chaque problème spécifique a sa propre solution spécifique.**

### 24. Ne soyez pas un héros

Très souvent, il est préférable d'être un abandonneur qu'un héros. Comme l'explique Jason Fried,

> Par exemple, supposons que vous pensez qu'une tâche peut être faite en deux heures. Mais quatre heures plus tard, vous n'avez fait qu'un quart du chemin. L'instinct naturel est de penser, Mais je ne peux pas abandonner maintenant, j'ai déjà passé quatre heures dessus ! 

> Alors vous passez en mode héros. Vous êtes déterminé à faire en sorte que cela fonctionne (et légèrement embarrassé que cela ne fonctionne pas déjà). Vous prenez votre cape et vous isolez du monde.  [Jason Fried](https://books.google.com/books?id=U77um_h_dgcC&pg=PA118&lpg=PA118&dq=For+example,+let%E2%80%99s+say+you+think+a+task+can+be+done+in+two+hours.+But+four+hours+into+it,+you%E2%80%99re+still+only+a+quarter+of+the+way+done.+The+natural+instinct+is+to+think,+%E2%80%9CBut+I+can%E2%80%99t+give+up+now,+I%E2%80%99ve+already+spent+four+hours+on+this!%E2%80%9D+So+you+go+into+hero+mode.+You%E2%80%99re+determined+to+make+it+work+(and+slightly+embarrassed+that+it+isn%E2%80%99t+already+working).+You+grab+your+cape+and+shut+yourself+off+from+the+world.&source=bl&ots=F_kaZpwxMf&sig=ACfU3U36TIXkJt-Lk2NtH_kzw5A7q_99_w&hl=en&sa=X&ved=2ahUKEwjXkqO--5XoAhUIJDQIHZZhDWYQ6AEwAHoECAkQAQ#v=onepage&q=For%20example%2C%20let%E2%80%99s%20say%20you%20think%20a%20task%20can%20be%20done%20in%20two%20hours.%20But%20four%20hours%20into%20it%2C%20you%E2%80%99re%20still%20only%20a%20quarter%20of%20the%20way%20done.%20The%20natural%20instinct%20is%20to%20think%2C%20%E2%80%9CBut%20I%20can%E2%80%99t%20give%20up%20now%2C%20I%E2%80%99ve%20already%20spent%20four%20hours%20on%20this!%E2%80%9D%20So%20you%20go%20into%20hero%20mode.%20You%E2%80%99re%20determined%20to%20make%20it%20work%20(and%20slightly%20embarrassed%20that%20it%20isn%E2%80%99t%20already%20working).%20You%20grab%20your%20cape%20and%20shut%20yourself%20off%20from%20the%20world.&f=false)

**Ne soyez pas obsédé. Sachez quand abandonner. N'hésitez pas à demander de l'aide.**

### 25. Ne posez pas de questions

Demandez de l'aide

Lorsque vous avez quelque chose à implémenter et que vous n'êtes pas sûr des solutions, ne demandez pas aux autres comment le faire 

au moins pas immédiatement. Essayez plutôt tout ce à quoi vous pouvez penser. Cela est d'autant plus important que vous êtes moins à l'aise avec un concept ou un langage.

Lorsque vous ne pouvez plus penser à rien par vous-même, cherchez ! Trouvez des réponses et essayez-les. Modifiez ces réponses, voyez si vous pouvez comprendre pourquoi elles fonctionnent, adaptez-les à votre code.



Mais demandez toujours conseil.

Lorsque vous avez tout essayé, et de préférence après avoir une solution fonctionnelle, c'est le meilleur moment pour demander conseil. Tournez-vous vers vos pairs et les développeurs seniors pour qu'ils révisent votre code.

J'ai essayé d'expliquer les fondamentaux d'un bon état d'esprit de développeur dans cet article. J'ai utilisé certaines parties du livre [Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848) qui a eu un grand impact sur mon processus de réflexion en tant que développeur. Lorsque j'ai lu ce livre, il y a eu beaucoup de moments où j'ai réagi en disant ohh j'ai fait cette erreur, j'ai fait cela aussi. J'ai mentionné certaines parties importantes du livre et les ai combinées avec mon expérience.

Je vous recommande vivement de lire [Code Simplicity](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848) de Max Kanat-Alexander.

Merci d'avoir lu ! J'espère que ce guide vous a aidé !

_Vous pouvez lire plus de mes articles sur [https://huseyinpolatyuruk.com](https://blog.huseyinpolatyuruk.com/fundamentals-of-a-good-developer-mindset)._