---
title: Pr√©paration aux entretiens de d√©veloppeur ‚Äì Comment utiliser une approche collaborative
  pour la r√©solution de probl√®mes
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2023-04-19T21:14:37.000Z'
originalURL: https://freecodecamp.org/news/collaborative-problem-solving-with-python
coverImage: https://www.freecodecamp.org/news/content/images/2023/04/michal-czyz-ALM7RNZuDH8-unsplash.jpg
tags:
- name: Collaboration
  slug: collaboration
- name: interview questions
  slug: interview-questions
- name: Interview tips
  slug: interview-tips
- name: Python
  slug: python
seo_title: Pr√©paration aux entretiens de d√©veloppeur ‚Äì Comment utiliser une approche
  collaborative pour la r√©solution de probl√®mes
seo_desc: "By Alberto Gonzalez Rosales\nNo matter how experienced of a developer you\
  \ are, being interviewed for a new job is always stressful. This is certainly true\
  \ from my own experience. \nIn my case, I have been working professionally as a\
  \ Software Developer ..."
---

Par Alberto Gonzalez Rosales

Peu importe votre exp√©rience en tant que d√©veloppeur, passer un entretien pour un nouvel emploi est toujours stressant. Cela a certainement √©t√© le cas pour moi.

Dans mon cas, je travaille professionnellement en tant que d√©veloppeur logiciel depuis deux ans et demi, et j'ai d√©j√† d√ª affronter cinq entretiens de d√©veloppeur.

J'ai vu des gens se concentrer trop sur l'apprentissage de probl√®mes algorithmiques sp√©cifiques, ou s'entra√Æner sur des plateformes en ligne sp√©cialis√©es dans les d√©fis d'entretien. Mais il y a un autre aspect des entretiens que je pense √™tre tout aussi important ‚Äì et auquel les gens pr√™tent moins attention.

Alors, si vous voulez savoir comment je pense que vous devriez orienter votre pr√©paration pour les entretiens, prenez une tasse de caf√© et installez-vous confortablement.

Cela va √™tre un peu mouvement√© (mais ne vous inqui√©tez pas ‚Äì des exemples en Python sont inclus !).

## Voici ce que nous allons couvrir :

1. [Les algorithmes et les structures de donn√©es sont-ils importants pour les entretiens ?](#heading-les-algorithmes-et-les-structures-de-donnees-sont-ils-importants-pour-les-entretiens)
2. [Se concentrer sur une approche collaborative](#heading-se-concentrer-sur-une-approche-collaborative)
3. [Essayez de faire un entretien simul√©e](#heading-essayez-de-faire-un-entretien-simulee)  
‚Äì [Le probl√®me initial de l'exemple d'entretien](#heading-le-probleme-initial-de-lexemple-dentretien)  
‚Äì [Le deuxi√®me probl√®me de l'exemple d'entretien](#heading-le-deuxieme-probleme-de-lexemple-dentretien)  
‚Äì [Le probl√®me le plus difficile de l'exemple d'entretien](#heading-le-probleme-le-plus-difficile-de-lexemple-dentretien)
4. [Mots de la fin](#heading-mots-de-la-fin)

Commen√ßons.

## **Les algorithmes et les structures de donn√©es sont-ils importants pour les entretiens ?**

La r√©ponse courte est **Oui**.

Conna√Ætre les structures de donn√©es et les algorithmes vous aidera souvent √† obtenir un emploi. De plus, les avantages d'avoir une solide formation algorithmique incluent la capacit√© √† prendre de meilleures d√©cisions face √† un probl√®me difficile.

Dans la vie r√©elle, les probl√®mes algorithmiques n'appara√Ætront pas comme les √©nonc√©s des exercices acad√©miques que vous pourriez √©tudier. Pourtant, plus vous √™tes entra√Æn√©, plus vous √™tes susceptible de reconna√Ætre une application d'un arbre binaire √©quilibr√© ou d'un algorithme de plus court chemin d√©guis√©.

Avec cela en t√™te, je recommanderais de ne pas s'entra√Æner aux structures de donn√©es et aux algorithmes uniquement pour les entretiens que vous souhaitez r√©ussir. La conception des algorithmes et l'utilisation des bonnes structures de donn√©es sont des sujets suffisamment beaux pour √™tre √©tudi√©s simplement pour le plaisir de savoir.

Le champ d'un entretien est tr√®s limit√©. Au lieu de cela, concentrez-vous sur la partie r√©solution de probl√®mes. Essayez de comprendre comment utiliser un algorithme (ou ses variations) pour des t√¢ches similaires. √âtudiez toutes les variantes et apprenez √† les reconna√Ætre dans diff√©rentes situations. Cela vous aidera √† aborder de nouvelles t√¢ches avec un esprit ouvert.

De plus, ne m√©morisez pas les solutions. Cela ne vous m√®nera nulle part. Il est tr√®s facile pour un d√©veloppeur exp√©riment√© de poser les bonnes questions qui vous mettront en difficult√© si vous ne vous entra√Ænez que pour des sujets tr√®s sp√©cifiques.

Prenez un probl√®me et essayez de le r√©soudre en utilisant diff√©rentes m√©thodes. Essayez de r√©soudre des probl√®mes plus difficiles √† chaque fois. Sortez de votre zone de confort.

Cela portera ses fruits.

## **Se concentrer sur une approche collaborative**

La plupart des gens s'entra√Ænent pour leurs entretiens sur des sites comme [Leetcode](https://leetcode.com/). Il n'y a pas de probl√®me avec cela. Ces sites sont bons pour entra√Æner vos comp√©tences en r√©solution de probl√®mes.

Je participe √† des concours de programmation comp√©titive depuis au moins huit ans, et j'ai toujours b√©n√©fici√© de ces ressources en ligne.

Mais il y a une chose difficile √† comprendre pour la plupart des ing√©nieurs logiciels qui veulent bien performer lors d'un entretien. Ils ne s'entra√Ænent pas pour l'aspect le plus important du d√©veloppement logiciel : **la collaboration**.

Habituellement, lorsque vous √™tes confront√© √† un probl√®me sur une plateforme en ligne, il vient avec certaines contraintes sur les valeurs maximales pour certaines entr√©es. Il peut √©galement avoir des limites de temps et de m√©moire qui vous obligent √† ajuster vos solutions pour √™tre plus ou moins efficaces. Mais ce n'est pas ainsi que cela se passera dans la vie r√©elle.

Il n'est pas √©vident de mapper ces contraintes √† des sc√©narios de la vie r√©elle. Elles se pr√©sentent g√©n√©ralement sous la forme de demandes tr√®s sp√©cifiques d'un client, ou de caract√©ristiques tr√®s sp√©cifiques de l'√©quipe.

Dans un projet r√©el, l'√©quipe **collaborera** pour d√©terminer quelles seront ces contraintes. Vous devez analyser vos cas d'utilisation, le temps dont vous disposez pour la t√¢che, qui est l'utilisateur final, combien de personnes travailleront dessus, et ainsi de suite...

Apr√®s une s√©rie de discussions, vous parviendrez √† un consensus et commencerez enfin √† impl√©menter une solution qui r√©pond √† vos besoins. Et cette solution n'a m√™me pas besoin d'√™tre la plus efficace dans certains cas, mais la plus rapide √† impl√©menter, par exemple.

C'est aussi ce que les intervieweurs veulent voir chez les candidats pendant les entretiens.

Vous ne sautez pas directement √† l'impl√©mentation de la meilleure solution que vous connaissez pour le probl√®me auquel vous √™tes confront√©. Au lieu de cela, vous devriez utiliser vos intervieweurs comme une ressource pr√©cieuse, les traiter comme s'ils √©taient vos co√©quipiers (apr√®s tout, vous voulez qu'ils le deviennent). Posez des questions sur la mani√®re dont l'√©quipe pr√©f√®re que la solution du probl√®me soit impl√©ment√©e.

Cela m√®nera √† une discussion tr√®s fructueuse o√π vous pourrez montrer vos capacit√©s de codage et vos comp√©tences collaboratives. Vous pourriez commencer par proposer des solutions simples et guider vos intervieweurs √† travers le processus d'am√©lioration de la solution en utilisant les meilleurs atouts que vous avez en main.

En guise de note finale sur l'entra√Ænement en ligne, je recommanderais de faire des entra√Ænements individuels et en √©quipe. Utilisez des sites tels que [Codeforces](https://codeforces.com/) ou [AtCoder](https://atcoder.jp/), qui ont un grand ensemble de probl√®mes int√©ressants (et difficiles), et essayez de rivaliser avec vous-m√™me chaque jour.

Ne vous concentrez pas sur votre classement. Je l'ai fait avant, et cela ne fait que vous retenir.

## **Essayez de faire un entretien simul√©e**

Si vous √™tes arriv√© √† ce point dans l'article, je vous proposerais un petit exercice. Faisons un entretien simul√©e o√π je jouerai le r√¥le de l'intervieweur. Je vous dirai comment je pense que le candidat (vous) devrait r√©pondre √† chaque question et effectuer chaque t√¢che.

Bien s√ªr, nous nous concentrerons uniquement sur la partie d√©fi de programmation. D'autres aspects des entretiens, comme parler des exp√©riences pr√©c√©dentes, sont √©galement importants, mais nous essaierons de couvrir cela dans un autre article.

Alors, si vous vous sentez pr√™t, c'est parti !

### Le probl√®me initial de l'exemple d'entretien

Commen√ßons par la t√¢che que vous allez r√©soudre. Gardez √† l'esprit que si vous et moi nous trouvons un jour dans cette situation, je n'utiliserai pas cet exemple, mais bien s√ªr, j'utiliserai la m√™me m√©thodologie üòâ.

L'√©nonc√© du probl√®me est le suivant :

> "√âtant donn√© un nombre entier `X`, d√©terminez s'il est un nombre premier."

Vous pourriez √™tre tent√© d'opter pour la meilleure solution que vous connaissez pour r√©soudre ce probl√®me. Je pense que cette approche, comme je l'ai expliqu√© pr√©c√©demment, n'est pas toujours correcte.

Au lieu de cela, ce que je voudrais savoir, ce sont les diff√©rentes approches pour r√©soudre ce probl√®me. De plus, j'aimerais que vous posiez des questions sur les exigences pour cette t√¢che. Quelque chose comme :

* Devons-nous viser la performance ou r√©soudre le probl√®me plus rapidement ?
* Devons-nous faire une solution facile √† comprendre pour les autres d√©veloppeurs ?

Habituellement, certains aspects √† consid√©rer lors de la cr√©ation de la premi√®re solution pour un probl√®me sont :

* Facile vs Difficile : Devons-nous faire une solution facile √† impl√©menter m√™me si elle n'est pas parfaite, ou devons-nous opter pour une solution plus robuste qui sera difficile √† impl√©menter ?
* Na√Øf vs Efficace : Devons-nous livrer une solution na√Øve fonctionnelle d'abord, puis une solution plus efficace, ou devons-nous aller directement √† l'efficace ?

√âvaluez ce que votre √©quipe veut optimiser. Parvenez √† un consensus et impl√©mentez la solution convenue.

Dans mon cas, je serais ravi si vous proposiez la solution la plus facile, la plus rapide √† impl√©menter et correcte √† laquelle vous pouvez penser, puis me guidiez √† travers le processus d'am√©lioration de cette solution.

Un exemple de tr√®s bonne solution initiale √† ce probl√®me est quelque chose comme ce qui suit :

```python
# naive.py

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    for i in range(2, x):
        if x % i == 0:
            return False
    return True

```

Comme vous pouvez le voir, cette fonction est correcte. Puisqu'un nombre premier est un entier divisible uniquement par le nombre `1` et lui-m√™me, il est logique d'it√©rer de `2` √† `x - 1` √† la recherche d'un diviseur de `x`. Si nous en trouvons un, nous pouvons imm√©diatement retourner `False`. Sinon, nous retournons `True`. En tant que cas particuliers, les nombres `0` et `1` ne sont pas premiers par d√©finition.

C'est un bon point de d√©part !

Maintenant, avant de plonger dans l'optimisation de cette m√©thode, vous pouvez discuter du style du code. Est-il suffisamment Pythonique ? Est-ce que cela nous importe ? Est-il lisible ?

Toutes ces questions peuvent ne pas sembler importantes au premier abord, mais, puisque nous travaillons en √©quipe, elles comptent. Avoir un style de codage est important car cela facilite la compr√©hension du code de chacun par les autres membres de l'√©quipe, et cela acc√©l√©rera les revues et les refactorisations. De plus, le code est plus souvent lu qu'√©crit, donc la lisibilit√© compte !

Vous pourriez √™tre tent√© de montrer vos comp√©tences en Python et de r√©√©crire la fonction pr√©c√©dente comme suit :

```python
# pythonic_naive.py

def is_prime(x: int) -> bool:
    return False if x in {0, 1} else all(x % i != 0 for i in range(2, x))

```

Je pense que c'est une bonne fa√ßon, pythonique, d'√©crire cette fonction. Mais, puisque l'√©quipe est la chose la plus importante ici, ce changement devrait √™tre discut√©.

Il se peut que certains membres de l'√©quipe ne soient pas aussi comp√©tents en Python. Peut-√™tre que, dans ce cas, nous devrions optimiser pour la lisibilit√© et garder la fonction telle que nous l'avons √©crite au d√©but.

Un ajout plus int√©ressant, avant de passer √† la performance, serait d'ajouter des docstrings √† la fonction. Comme je l'ai dit pr√©c√©demment, ce code sera probablement lu par vos membres d'√©quipe √† l'avenir. Il est important, alors, de le rendre plus facile √† comprendre pour eux (et pour vous-m√™me dans le futur).

Peut-√™tre que changer la fonction en quelque chose comme ce qui suit ajoutera plus de valeur :

```python
# naive.py

def is_prime(x: int) -> bool:
    """Cette fonction prend un entier `x` comme
    argument et v√©rifie s'il est premier ou non.

    Args:
        x (int): Le nombre entier √† tester pour la primalit√©.

    Returns:
        bool: True si le nombre `x` est premier, False sinon.
    """
    if x in [0, 1]:
        return False
    for i in range(2, x):
        if x % i == 0:
            return False
    return True

```

#### Premi√®re optimisation

Jusqu'√† ce point, nous avons une solution initiale qui fonctionne. Nous avons discut√© de sujets importants tels que le style de code, la lisibilit√© et la documentation pour les d√©veloppeurs. Ce sont toutes des choses importantes √† consid√©rer lorsque l'on travaille en √©quipe.

Mais nous n'avons toujours pas parl√© de la performance de la solution ! Alors, il est probablement temps de le faire.

√Ä ce stade, vous devriez probablement mentionner que cette fonction peut √™tre impl√©ment√©e pour qu'elle s'ex√©cute beaucoup plus rapidement. Et c'est maintenant que vous montrez toute cette connaissance algorithmique qui est en vous.

La solution pr√©c√©dente a une complexit√© temporelle de `O(x)`, o√π `x` est l'entier d'entr√©e que la fonction prend comme argument. Cela peut √™tre optimis√© √† `O(sqrt(x))` avec le code suivant :

```python
# sqrt.py

import math

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    for i in range(2, int(math.sqrt(x)) + 1):
        if x % i == 0:
            return False
    return True

```

Ou m√™me comme ceci, sans importer la biblioth√®que `math` :

```python
# sqrt.py

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    i = 2
    while i**2 <= x:
        if x % i == 0:
            return False
        i += 1
    return True

```

Je serais d'accord avec l'une ou l'autre alternative.

J'ai omis les docstrings dans l'impl√©mentation pr√©c√©dente pour plus de clart√© dans les changements de code. Mais il serait bien d'inclure la complexit√© temporelle de la fonction dans la documentation pour les d√©veloppeurs. Plus vous pouvez donner d'informations sur votre code, mieux ce sera pour vos membres d'√©quipe et pour vous-m√™me.

Vous faites du bon travail jusqu'√† pr√©sent. Continuons !

### Le deuxi√®me probl√®me de l'exemple d'entretien

Jusqu'√† pr√©sent, j'ai pu √©valuer que vous avez les comp√©tences collaboratives n√©cessaires pour vous attaquer √† des t√¢ches faciles avec l'√©quipe. Il est maintenant temps de compliquer un peu les choses.

Voici l'√©nonc√© du deuxi√®me probl√®me que je vous proposerais :

> "√âtant donn√© deux nombres entiers `L` et `R`, comptez combien de nombres entiers premiers se trouvent dans l'intervalle `[L, R]`."

Une fois de plus, je recommanderais de discuter des priorit√©s que l'√©quipe a fix√©es concernant cette t√¢che. Commencez simplement et parcourez le processus d'am√©lioration d'une solution initiale. Soulignez que l'optimisation pr√©matur√©e n'est pas une bonne pratique.

Discutez √©galement de la possibilit√© d'utiliser la solution que vous avez impl√©ment√©e pour la t√¢che pr√©c√©dente pour r√©soudre celle-ci. Il est logique que si nous avons une fonction qui indique si un entier est un nombre premier ou non, nous pouvons l'utiliser pour chaque nombre dans une plage.

Et c'est quelque chose que vous devrez faire dans la vie r√©elle. Habituellement, lorsqu'une nouvelle t√¢che appara√Æt, l'√©quipe doit examiner les projets maintenus pour voir ce qui peut √™tre r√©utilis√© afin d'acc√©l√©rer le processus d'impl√©mentation. Si vous ne faites pas cela, vous pourriez finir par coder des fonctionnalit√©s dupliqu√©es.

Cela dit, une bonne solution initiale pour cette t√¢che pourrait √™tre quelque chose comme ceci :

```python
# range_primes.py

from sqrt import is_prime

def count_primes(l: int, r: int) -> int:
    primes = 0
    for i in range(l, r + 1):
        if is_prime(i):
            primes += 1
    return primes

```

Cela est parfaitement acceptable, et vous avez montr√© que vous pouvez r√©utiliser des fonctionnalit√©s pr√©c√©dentes pour en construire de nouvelles. Comme dans le premier exemple, vous pourriez √™tre tent√© de montrer vos comp√©tences en Python et d'√©crire cette fonction comme ceci :

```python
# range_primes.py

from sqrt import is_prime

def count_primes(l: int, r: int) -> int:
    return sum(bool(is_prime(i)) for i in range(l, r + 1))

```

Je recommande de ne pas opter pour cette impl√©mentation Pythonique comme premi√®re option. Laissez-la pour la discussion, √©valuez la lisibilit√© du code et analysez peut-√™tre les diff√©rences de performance. N'oubliez pas les docstrings !

La section suivante est celle o√π les choses deviennent int√©ressantes. Continuez √† lire. Nous sommes √† l'√©tape finale...

### Le probl√®me le plus difficile de l'exemple d'entretien

Vous souvenez-vous lorsque j'ai dit pr√©c√©demment que les contraintes pr√©sentes sur les sites de programmation comp√©titive sont difficiles √† mapper aux exigences de la vie r√©elle ?

Voici comment je vous pr√©senterais un d√©fi difficile pour d√©terminer ces contraintes et impl√©menter la meilleure solution possible :

> "Supposons qu'un client souhaite que nous fournissions la fonctionnalit√© de calcul des nombres premiers dans une plage en tant que service. Ils veulent que l'accent soit mis sur la performance car ils pr√©voient d'utiliser ce service tr√®s souvent. Comment l'impl√©menteriez-vous ?"

Si vous vous √™tes entra√Æn√© √† vos comp√©tences algorithmiques pour les entretiens, vous avez probablement r√©solu des probl√®mes similaires √† celui-ci quelques fois. La principale diff√©rence ici est le changement de contexte.

Au lieu de vous donner des instructions pr√©cises, des contraintes num√©riques et des formats d'entr√©e ou de sortie, je vous ai donn√© une description plus large de la t√¢che. Et mon objectif ici est le m√™me qu'avant : vous faire interagir avec moi comme si nous √©tions des co√©quipiers cherchant √† r√©soudre ce probl√®me √† partir des quelques informations que nous connaissons.

Esp√©rons qu'apr√®s avoir √©chang√© quelques questions et r√©ponses, nous pourrons traduire l'√©nonc√© pr√©c√©dent, plus ambigu, en quelque chose de beaucoup plus familier :

> "√âtant donn√© un ensemble de requ√™tes de la forme `[L, R]`, r√©pondez, pour chaque requ√™te, combien de nombres entiers √† l'int√©rieur de cette plage sont premiers."

Et cela a du sens car le client voulait utiliser ce service tr√®s souvent, comme indiqu√© dans la description.

Nous voulons nous concentrer sur la performance. Cela devrait √™tre notre principale pr√©occupation lors de l'impl√©mentation de la solution. Mais toujours, la meilleure fa√ßon d'arriver √† une solution optimale est de commencer par une solution simple, d'analyser si nous r√©pondons √† nos exigences de performance et de continuer √† am√©liorer progressivement. Voyons l'exemple complet.

Nous pourrions commencer par utiliser la solution que nous avons impl√©ment√©e √† l'√©tape pr√©c√©dente. Est-elle suffisamment bonne ?

Supposons que la plage maximale de nombres que nous aurons comme argument de notre fonction est `[1, 10^6]`. De plus, r√©alistement, supposons que le nombre de requ√™tes que notre service r√©pondra par minute est d'environ `10^5`.

Notre solution pr√©c√©dente a une complexit√© temporelle de `O(sqrt(n))` pour d√©terminer si un nombre est premier. Si nous devions faire cela pour chaque nombre dans la plage, la complexit√© passe √† `O(n * sqrt(n))`. En plus de cela, si nous faisons cela pour chaque requ√™te, nous finirons avec une complexit√© temporelle encore plus √©lev√©e de `O(q * n * sqrt(n))`.

Substituez les variables pr√©c√©dentes par les valeurs les plus √©lev√©es qu'elles peuvent avoir, et vous obtiendrez que cette solution prendra environ `10^14` op√©rations pour r√©pondre √† toutes les requ√™tes. En supposant qu'un ordinateur peut effectuer environ `10^8` op√©rations √©l√©mentaires par seconde, il faudra environ `10^6` secondes pour les compl√©ter toutes.

> Note : Convertissez 10^6 secondes en jours. Vous serez √©merveill√© ü§Ø.

Cette solution est irr√©alisable si l'objectif est de prioriser la performance de notre solution. Voyons comment nous pouvons l'am√©liorer.

√Ä ce stade, ce que j'attendrais, c'est que vous sortiez le meilleur de l'entra√Ænement que vous avez eu sur toutes ces plateformes en ligne, et que vous me montriez une solution impressionnante. C'est le moment de montrer toutes vos comp√©tences analytiques et algorithmiques.

Mais seulement maintenant, parce que je sais que vous √™tes un joueur d'√©quipe.

#### La solution finale

Puisque ceci est un entretien simul√©e, je suis tr√®s int√©ress√© de conna√Ætre votre approche pour r√©soudre ce dernier probl√®me efficacement. Faites-moi savoir comment vous impl√©menteriez la solution ou partagez votre code sur GitHub ‚Äì ne soyez pas timide.

Je vous garantis une chose : si vous pouvez arriver √† ce point dans les entretiens r√©els, il ne sera probablement pas trop important si vous ne connaissez pas la solution optimale √† ce probl√®me. Cela ne signifie pas que vous ne devriez pas faire de votre mieux pour le r√©soudre, mais soyez assur√© que vous avez d√©j√† fait un tr√®s bon travail.

C'est tout ! Maintenant, je veux voir votre code.

## **Mots de la fin**

Dans cet article, j'ai essay√© de r√©sumer certains des aspects que je consid√®re comme les plus importants dans les entretiens de codage. J'ai plac√© un accent particulier sur la partie collaborative car je pense que la plupart des gens sous-estiment l'importance de cette comp√©tence. C'est un must, surtout si vous voulez travailler en √©quipe avec d'autres d√©veloppeurs.

J'ai essay√© de vous guider √† travers un entretien simul√©e o√π j'ai expliqu√© le processus de r√©flexion que je suivrais face √† une t√¢che de codage standard lors d'un entretien. J'esp√®re que cet exercice a √©t√© utile et qu'il pourra vous aider lors de votre prochain entretien (en tant que candidat ou en tant qu'intervieweur).

Partagez vos r√©flexions sur cet entretien simul√©e, et commen√ßons une discussion fructueuse.

√Ä bient√¥t ! üëã

## **Sources**

* Les exemples de code utilis√©s dans l'article peuvent √™tre trouv√©s [ici](https://github.com/albexl/a-problem-solving-oriented-approach).
* Indice pour le dernier probl√®me : impl√©mentation de l'algorithme du [Crible d'√âratosth√®ne](https://github.com/albexl/data-structures-for-teaching/blob/dev/algorithms/number_theory/eratosthenes_sieve.py).

üëã Bonjour, je suis Alberto, d√©veloppeur logiciel chez [doWhile](https://dowhile.se/), programmeur comp√©titif, enseignant et passionn√© de fitness.

ü§ó Si vous avez aim√© cet article, envisagez de le partager.

üîó [Tous les liens](https://bio.link/albexl) | [Twitter](https://twitter.com/albe_xl) | [LinkedIn](https://www.linkedin.com/in/albexl/)