---
title: Cinq leçons importantes après quatre ans en tant que développeur logiciel
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2019-04-05T15:55:39.000Z'
originalURL: https://freecodecamp.org/news/five-important-lessons-from-four-years-as-a-software-developer-9b367f256226
coverImage: https://cdn-media-1.freecodecamp.org/images/0*_mLw5ajccei5oTEb
tags:
- name: Computer Science
  slug: computer-science
- name: Life lessons
  slug: life-lessons
- name: General Programming
  slug: programming
- name: software development
  slug: software-development
- name: 'tech '
  slug: tech
seo_title: Cinq leçons importantes après quatre ans en tant que développeur logiciel
seo_desc: 'By Stephen McLean

  It’s been almost four years since I graduated with a degree in CS and began my career
  as a Software Developer. In this post, I’d like to share some of the lessons I have
  learned along the way.

  Table of Contents


  Never Assume

  The non...'
---

Par Stephen McLean

Cela fait presque quatre ans que j'ai obtenu mon diplôme en informatique et que j'ai commencé ma carrière en tant que développeur logiciel. Dans cet article, je souhaite partager quelques-unes des leçons que j'ai apprises en cours de route.

#### Table des matières

* [Ne jamais supposer](#a029)
* [Les problèmes non techniques sont les plus difficiles](#918d)
* [Réfléchir d'abord, coder ensuite](#55e8)
* [Ce que vous créez est plus important que les outils utilisés pour le créer](#25cf)
* [Chaque rôle est également important](#94da)
* [Conclusion](#f6b0)

#### Ne jamais supposer

Après avoir commencé mon premier emploi, mon premier projet était une mission à court terme sur un projet de longue durée. Le projet avait connu de nombreuses sprints et de nombreux développeurs. La base de code était volumineuse, complexe et avec de nombreuses intégrations à des services externes.

Ma première tâche était de corriger certains tests unitaires qui échouaient de manière intermittente. Le code testé était relativement ancien et avait été écrit par un développeur senior. Comme la fonctionnalité fonctionnait bien depuis l'UI et avait été testée minutieusement par l'assurance qualité, j'ai fait l'hypothèse que le problème devait être avec les tests eux-mêmes.

J'ai passé près de trois jours à essayer de corriger des tests qui n'étaient pas cassés. Lorsque j'ai expliqué à mon responsable d'équipe pourquoi la correction avait pris autant de temps, il m'a enseigné ma première leçon majeure. Il m'a dit de ne jamais supposer que le code de quelqu'un d'autre est correct simplement parce qu'il en a l'air.

C'est probablement la leçon la plus importante que j'ai apprise et qui peut être appliquée à de nombreuses situations, pas seulement en rapport avec le code. En voici quelques-unes :

1. Ne jamais supposer que quelqu'un fera quelque chose simplement parce que vous le lui avez demandé. Obtenez toujours un accord explicite. Vous n'avez pas reçu de réponse de quelqu'un à qui vous avez demandé de vérifier quelque chose ? Envoyez un suivi. Si quelque chose est important, c'est suffisamment important pour faire un suivi.

2. Ne jamais supposer que quelqu'un comprend ce que vous lui avez dit, même s'il dit qu'il comprend. C'est une leçon que j'ai apprise après avoir progressé dans ma carrière au point de commencer à mentor des développeurs plus juniors. J'ai remarqué que je parcourais rapidement les instructions, et le lendemain, je constatais que le développeur en question n'avait pas fait beaucoup de progrès même s'il avait dit qu'il comprenait parfaitement ce qui était requis. Au lieu de cela, demandez à la personne de vous faire un compte rendu de ce qui a été discuté afin que vous puissiez être certain qu'elle comprend. Cela s'applique à plus que simplement mentor des développeurs, comme expliquer quelque chose aux analystes métiers, à l'assurance qualité, etc.

3. Ne jamais supposer que l'autre partie a tort. Je pense que les développeurs ont tendance à blâmer tout le monde pour le fait que leur code ne fonctionne pas. Vous devenez protecteur envers le code que vous écrivez, au point où vous êtes convaincu qu'il ne peut pas être faux. Si l'assurance qualité vous dit qu'ils ont rencontré un problème, ils ont une raison de le faire. Cela ne vous coûtera pas grand-chose de leur donner le bénéfice du doute, et ils l'apprécieront plus que d'être ignorés.

#### Les problèmes non techniques sont les plus difficiles

À l'université, tous les problèmes étaient techniques. Découvrir comment faire fonctionner un morceau de code était presque toujours le problème en question. Dans la vie professionnelle, cependant, j'ai constaté que ce n'est rarement le cas.

Assurer une communication claire au sein d'une grande équipe travaillant dans plusieurs fuseaux horaires. S'assurer que les processus fonctionnent et sont clairement documentés. Découvrir comment aider à intégrer ou à mentor de nouveaux membres de l'équipe. Essayer d'introduire en douceur quelque chose de nouveau dans le processus de développement. Convaincre la gestion de projet de se concentrer sur la santé à long terme du code lorsque les chiffres pressent leur agenda dans le présent.

Ce ne sont là que quelques exemples montrant les types de choses auxquelles vous pouvez être confronté sur un projet. À mon avis, ils sont infiniment plus difficiles que de traquer ce pointeur nul qui vous tracasse.

#### Réfléchir d'abord, coder ensuite

Vous repérez un processus qui peut être amélioré. Vous décidez immédiatement de l'automatiser. Vous passez chaque heure de libre à développer quelque chose qui changera complètement la façon dont votre équipe travaille.

Cela vous semble familier, n'est-ce pas ? Les développeurs, moi y compris, adorent les solutions automatisées.

Qu'ai-je appris ? Ne vous précipitez pas immédiatement vers le code. Arrêtez-vous et réfléchissez au problème, pas à la solution. Parlez à une gamme de personnes, pas seulement à des développeurs. Découvrez si le problème est un problème technique ou un problème de processus en premier. Ensuite, vous pourrez déterminer la solution.

Bien sûr, proposer une solution complexe utilisant Docker et des scripts parfaitement écrits serait cool, et vous apprendriez probablement beaucoup, mais proposer une solution technique pour un problème non technique n'aidera probablement pas l'équipe à long terme. Cela pourrait simplement masquer le problème plus important.

#### Ce que vous créez est plus important que les outils utilisés pour le créer

Lorsque j'ai obtenu mon diplôme, j'adorais écrire du code, apprendre de nouveaux langages et frameworks, et tout ce qui impliquait un élément technique.

Ne vous méprenez pas, j'aime toujours cela. Mais j'ai réalisé que tant que les outils que nous utilisons en tant que développeurs nous permettent de faire notre travail, peu importe ce que sont ces outils. En développement front-end, il y a un nouveau framework tous les deux jours. Et bien qu'il soit important pour un développeur de se tenir au courant, les utilisateurs finaux (les personnes importantes) ne se soucient pas de savoir comment quelque chose fonctionne, mais simplement que cela fonctionne.

#### Chaque rôle est également important

J'ai déjà mentionné l'importance de ne pas supposer automatiquement que tout le monde qui n'est pas développeur a tort. En plus de cela, j'ai appris que chaque membre qui compose votre équipe (analyste métier, assurance qualité, chef de projet, autres parties prenantes, etc.) est tout aussi important que n'importe quel développeur.

Un projet ne fonctionne pas sans représentation de chaque rôle et ne fonctionne pas non plus si les ressources ne sont pas partagées équitablement entre les différents types de ressources.

J'ai appris que même si c'est le développeur qui écrit le code réel, il n'y aurait pas besoin de code sans les parties prenantes, et il n'y aurait pas de parties prenantes sans l'assurance qualité de ce qu'elles supervisent.

#### Conclusion

J'espère que vous pourrez apprendre quelque chose de ces leçons. Si vous avez des leçons que vous avez apprises et que vous souhaitez partager, j'adorerais les entendre dans les réponses.

Merci d'avoir lu !