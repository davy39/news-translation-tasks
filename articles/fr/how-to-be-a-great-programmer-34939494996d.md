---
title: Comment devenir un excellent programmeur
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2019-04-17T16:58:47.000Z'
originalURL: https://freecodecamp.org/news/how-to-be-a-great-programmer-34939494996d
coverImage: https://cdn-media-1.freecodecamp.org/images/1*JMsN-rnyB1H2q14RbQsVBw.jpeg
tags:
- name: learning
  slug: learning
- name: Productivity
  slug: productivity
- name: General Programming
  slug: programming
- name: 'self-improvement '
  slug: self-improvement
- name: 'tech '
  slug: tech
seo_title: Comment devenir un excellent programmeur
seo_desc: 'By Amy M Haddad

  What sets apart the really great programmers?


  _Photo by [Unsplash](https://unsplash.com/photos/4m7gmLNr3M0?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"
  rel="noopener" target="_blank" title="">David Rangel on <a...'
---

Par Amy M Haddad

_Qu'est-ce qui distingue les vraiment grands programmeurs ?_

![Image](https://cdn-media-1.freecodecamp.org/images/VmDGEaafdOMPVkYJhv6uF6zRqkZPLdxNKv5r)
_Photo par [Unsplash](https://unsplash.com/photos/4m7gmLNr3M0?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener" target="_blank" title="">David Rangel</a> sur <a href="https://unsplash.com/search/photos/study-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener" target="_blank" title=")_

Comme nous le savons tous, les grands programmeurs créent des fonctionnalités, des sites web, des applications et bien plus encore. Mais qu'ont-ils en commun ?

Dans mes recherches, ce n'est pas seulement une question de maîtriser parfaitement un langage ou d'avoir un parcours éducatif particulier. C'est que les programmeurs vraiment talentueux ont maîtrisé les fondamentaux. Cette base est ce qui leur permet de construire de grandes choses et de venir avec des idées révolutionnaires.

Imaginez une pyramide. Elle a une large base, mais devient progressivement plus petite et plus fine vers le haut. Apprendre les fondamentaux de la programmation forme cette base. Tout décolle à partir de là.

Alors, quels sont ces fondamentaux ? Basé sur mon expérience et les programmeurs dont j'ai étudié les parcours, je vois les fondamentaux de la programmation comme une approche en deux parties.

### Résolveur de problèmes extraordinaire

Tout d'abord, vous devez être un résolveur de problèmes efficace. C'est un point important pour commencer puisque la programmation _est_ la résolution de problèmes.

Bien qu'il existe de nombreuses façons de résoudre un problème, il y a quelques parties du processus qui se distinguent pour moi. Les programmeurs qui sont aussi de grands résolveurs de problèmes distillent un problème à son essence, afin d'identifier leur objectif global et de commencer un problème avec un but. Ensuite, ils décomposent chaque problème en petites parties gérables, attaquant chaque partie à tour de rôle, et parfois en termes visuels en dessinant une image pour le rendre "réel".

Le processus est plus difficile qu'il n'y paraît. Lorsque j'ai commencé à programmer, j'ai rencontré un obstacle : comme beaucoup d'autres, je n'ai jamais appris à résoudre des problèmes à l'école ; c'est une compétence qui n'est pas facilement enseignée. On m'a donné un ensemble de problèmes en cours de maths et je me suis simplement lancée, ce que j'ai fait lorsque j'ai commencé à programmer. Sans surprise, je tournais en rond inutilement et je rencontrais des obstacles sur les problèmes les plus simples.

Les choses ont commencé à changer lorsque j'ai commencé à apprendre le processus de résolution de problèmes et comment résoudre des problèmes efficacement. Je commence maintenant un problème avec une intention. J'ai le livre de George Polya, _Comment le résoudre_, à remercier pour ce conseil.

J'ai adapté certaines des idées de Polya à la programmation, comme comprendre le problème. "Le problème doit être compris", écrit Polya. Cela inclut la capacité à "pointer les parties principales du problème, l'inconnu, les données et la condition". Pour chaque problème, je sors une feuille de papier et j'écris les réponses à ces questions : qu'est-ce que je résous ou essaie de trouver ? (inconnu) ; qu'est-ce qui me est donné ? (données) ; et quelles contraintes ou détails dois-je prendre en compte ? (condition).

Comprendre le problème peut sembler évident, mais l'évidence est facilement négligée. À plus d'une occasion, j'ai passé des heures sur un problème pour réaliser beaucoup plus tard que j'avais manqué un petit détail, mais crucial dans l'énoncé du problème. Écrire les détails du problème me ralentit mentalement et m'aide à réfléchir exactement à ce que je dois faire, ce qui est la moitié de la bataille.

À partir de là, je fais un plan, ce qui est une autre des suggestions de Polya. Cela a du sens. J'écris un plan avant d'écrire un article. Un artiste fait un croquis de la peinture avant de travailler sur la peinture elle-même. Un constructeur utilise des dessins et des plans pour construire une maison. Ce n'est pas différent avec la programmation. Au lieu de me précipiter dans le _faire_, je dois commencer par _réfléchir_ à ce que je m'apprête à faire et établir un plan d'attaque.

Il y a de nombreuses façons de procéder. Parfois, je décris les étapes que je dois suivre dans l'ordre numérique : d'abord faire ceci, ensuite faire cela. D'autres fois, je rend le problème visuel. Lorsque j'apprenais les boucles for, j'ai sorti une poignée d'amandes et j'ai itéré physiquement à travers la pile. C'est un exemple idiot, mais cela m'a aidé à réfléchir au problème.

Je dessine aussi des images ou des diagrammes. Pour un problème récursif, je dessine un diagramme de ce qui se passe à chaque appel récursif jusqu'à ce que j'atteigne le cas de base. Presque toujours, cependant, je trouve un moyen de simplifier le problème pour le rendre plus gérable et pour m'aider à repérer un motif. Par-dessus tout, l'objectif pour moi est d'aborder un problème avec un but, et de maintenir ce sens du but tout au long.

Malgré les meilleurs plans, les problèmes sont toujours difficiles et je suis toujours bloquée. Devenir un excellent résolveur de problèmes prend du temps ; c'est une compétence sur laquelle je travaille encore et cela vaut définitivement l'effort. C'est une différence que l'on peut voir.

Lorsque je lis du code écrit par un excellent résolveur de problèmes, il est propre et facile à comprendre. Les variables sont bien nommées. Les fonctions sont courtes et précises. Chaque ligne de code a un but spécifique ; le superflu est supprimé. La clarté du code reflète le processus de pensée du programmeur : je peux lire le programme de haut en bas et savoir exactement ce qui se passe. C'est une excellente résolution de problèmes, et c'est ce que je vise.

### Et votre ordinateur ?

Apprendre l'informatique est le deuxième fondamental de la programmation. J'ai récemment commencé à apprendre l'informatique, et je l'adore parce que je vais au-delà du niveau de surface. Je vais "derrière les scènes" pour apprendre ce qui se passe lorsque j'utilise une fonction intégrée, par exemple. J'apprends aussi la mémoire et le temps d'exécution, parmi de nombreux autres sujets. En bref, j'apprends _pourquoi_ un ordinateur fait ce qu'il fait.

Connaître le "pourquoi" améliore mes connaissances contextuelles et fait de moi un programmeur plus informé. En conséquence, je suis plus réfléchie avec le code que j'écris. Maintenant que je connais un peu le temps d'exécution, par exemple, je choisirai d'utiliser une recherche binaire au lieu d'itérer à travers chaque élément d'une liste.

Cela enrichit également ma compréhension de la façon dont les concepts de programmation de base fonctionnent. Par exemple, je travaillais sur un problème récursif et je n'obtenais pas la solution que j'anticipais. Après un examen approfondi, j'ai appris pourquoi : cela avait à voir avec l'exécution de la pile d'appels, une idée qui m'aurait échappé il y a quelques mois.

Ou prenez les classes. J'ai énormément lutté avec les classes pendant très longtemps, et j'avais peur d'en utiliser une. Je savais _comment_ écrire une classe, mais je n'étais pas confiante _quand_ et _pourquoi_ je l'utiliserais. Cela a changé lorsque j'ai appris ce qui se passe réellement dans mon ordinateur lorsque je crée des instances et que j'appelle des méthodes. Cela a finalement fait clic, une fois que j'avais un peu de contexte. Pour la récursion et les classes, l'informatique a comblé les lacunes dans mes connaissances.

Trop souvent, les fondamentaux sont mis de côté. Les progrès peuvent être lents, et les gens ont tendance à choisir des choses plus "amusantes" à travailler lorsqu'on leur en donne l'option. C'est dommage. Les programmeurs qui maîtrisent les fondamentaux semblent coder avec confiance : ils connaissent le "comment" et le "pourquoi" de leurs choix de programmation, ce qui améliore leur travail et construit leur crédibilité avec les autres.

De plus, une bonne maîtrise des fondamentaux facilite l'apprentissage de nouveaux langages et technologies. Par exemple, prendre le temps de vraiment comprendre les concepts de base comme l'itération, la récursion et l'abstraction avec un langage aidera lors de l'apprentissage d'un autre. En termes simples, il y a beaucoup à gagner et peu à perdre en maîtrisant les fondamentaux.

_Je suis une écrivaine ([amymhaddad.com](https://amymhaddad.com/press-clips-79d90fa1ed72)), et une programmeuse débutante._