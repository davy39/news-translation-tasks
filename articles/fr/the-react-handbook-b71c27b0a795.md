---
title: Le manuel React – Apprendre React pour les débutants
subtitle: ''
author: Flavio Copes
co_authors: []
series: null
date: '2019-01-08T16:50:56.000Z'
originalURL: https://freecodecamp.org/news/the-react-handbook-b71c27b0a795
coverImage: https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png
tags:
- name: JavaScript
  slug: javascript
- name: General Programming
  slug: programming
- name: React
  slug: react
- name: 'tech '
  slug: tech
- name: technology
  slug: technology
seo_title: Le manuel React – Apprendre React pour les débutants
seo_desc: 'The React Handbook follows the 80/20 rule: learn in 20% of the time the
  80% of a topic.

  I find this approach gives a well-rounded overview. This book does not try to cover
  everything under the sun related to React, but it should give you the basic bu...'
---

Le manuel React suit la règle 80/20 : apprendre en 20 % du temps les 80 % d'un sujet.

Je trouve que cette approche donne un aperçu bien équilibré. Ce livre ne tente pas de couvrir tout ce qui concerne React, mais il devrait vous donner les blocs de construction de base pour vous lancer et devenir un excellent développeur React. Si vous pensez qu'un sujet spécifique devrait être inclus, dites-le-moi. Vous pouvez me joindre sur Twitter [@flaviocopes](https://twitter.com/flaviocopes).

J'espère que le contenu de ce livre vous aidera à atteindre ce que vous voulez : **apprendre les bases de React**.

Vous pouvez obtenir cet ebook en format PDF, ePub et Mobi sur [reacthandbook.com](https://reacthandbook.com)

### Index du livre

#### Table des matières

[Une introduction à React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#une-introduction-a-react)  
[Comment utiliser create-react-app](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#comment-utiliser-create-react-app)

**SECTION 1** : CONCEPTS CORE DE JAVASCRIPT MODERNE QUE VOUS DEVEZ CONNAÎTRE POUR UTILISER REACT

* [Variables](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#variables)
* [Fonctions fléchées](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#fonctions-flechees)
* [Rest et spread](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#rest-et-spread)
* [Destructuration d'objets et de tableaux](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#destructuration-dobjets-et-de-tableaux)
* [Littéraux de gabarits](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#litteraux-de-gabarits)
* [Classes](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#classes)
* [Fonctions de rappel](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#fonctions-de-rappel)
* [Promesses](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#promesses)
* [Async/Await](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#async-await)
* [Modules ES](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#modules-es)

**SECTION 2** : CONCEPTS REACT

* [Applications à page unique](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#applications-a-page-unique)
* [Déclaratif](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#declaratif)
* [Immuabilité](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#immuabilite)
* [Pureté](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#purete)
* [Composition](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#composition)
* [Le DOM virtuel](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#le-dom-virtuel)
* [Flux de données unidirectionnel](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#flux-de-donnees-unidirectionnel)

**SECTION 3** : REACT EN PROFONDEUR

* [JSX](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#jsx)
* [Composants](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#composants)
* [État](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#etat)
* [Props](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#props)
* [Composants de présentation vs conteneurs](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#composants-de-presentation-vs-conteneurs)
* [État vs props](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#etat-vs-props)
* [PropTypes](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#proptypes)
* [Fragment React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#fragment-react)
* [Événements](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#evenements)
* [Événements du cycle de vie](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#evenements-du-cycle-de-vie)
* [Formulaires dans React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#formulaires-dans-react)
* [Référencer un élément DOM](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#referencer-un-element-dom)
* [Rendu côté serveur](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#rendu-cote-serveur)
* [L'API Context](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#lapi-context)
* [Composants d'ordre supérieur](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#composants-dordre-superieur)
* [Render Props](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#render-props)
* [Hooks](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#hooks)
* [Division de code](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#division-de-code)

**SECTION 4** : EXEMPLES PRATIQUES

* [Construire un simple compteur](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#construire-un-simple-compteur)
* [Récupérer et afficher les informations des utilisateurs GitHub via API](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#recuperer-et-afficher-les-informations-des-utilisateurs-github-via-api)

**SECTION 5** : STYLISATION

* [CSS dans React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#css-dans-react)
* [SASS dans React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#sass-dans-react)
* [Composants stylisés](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#composants-stylises)

**SECTION 6** : OUTILS

* [Babel](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#babel)
* [Webpack](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#webpack)

**SECTION 7** : TESTS

* [Jest](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#jest)
* [Tester les composants React](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#tester-les-composants-react)

**SECTION 8** : L'ÉCOSYSTÈME REACT

* [React Router](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#react-router)
* [Redux](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#redux)
* [Next.js](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#next-js)
* [Gatsby](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#gatsby)

[Conclusion](https://www.freecodecamp.org/news/the-react-handbook-b71c27b0a795/#conclusion)

### Une introduction à la bibliothèque de vue React

#### Qu'est-ce que React ?

React est une bibliothèque JavaScript qui vise à simplifier le développement des interfaces visuelles.

Développée chez Facebook et publiée dans le monde en 2013, elle alimente certaines des applications les plus utilisées, alimentant Facebook et Instagram parmi d'innombrables autres applications.

Son objectif principal est de faciliter le raisonnement sur une interface et son état à tout moment, en divisant l'interface utilisateur en une collection de composants.

#### Pourquoi React est-il si populaire ?

React a pris d'assaut le monde du développement web frontend. Pourquoi ?

#### Moins complexe que les autres alternatives

À l'époque où React a été annoncé, Ember.js et Angular 1.x étaient les choix prédominants en tant que framework. Ces deux frameworks imposaient tant de conventions au code que le portage d'une application existante n'était pas du tout pratique.

React a fait le choix d'être très facile à intégrer dans un projet existant, car c'est ainsi qu'ils ont dû le faire chez Facebook afin de l'introduire dans la base de code existante. De plus, ces 2 frameworks apportaient trop de choses à la table, tandis que React a choisi de n'implémenter que la couche Vue au lieu de la pile MVC complète.

#### Timing parfait

À l'époque, Angular 2.x a été annoncé par Google, ainsi que l'incompatibilité ascendante et les changements majeurs qu'il allait apporter. Passer d'Angular 1 à 2 était comme passer à un framework différent, donc cela, ainsi que les améliorations de la vitesse d'exécution que React promettait, en a fait quelque chose que les développeurs étaient impatients d'essayer.

#### Soutenu par Facebook

Être soutenu par Facebook est, bien sûr, bénéfique pour un projet s'il s'avère être un succès.

Facebook a actuellement un fort intérêt pour React, voit la valeur de son Open Source, et c'est un énorme plus pour tous les développeurs qui l'utilisent dans leurs propres projets.

#### React est-il simple à apprendre ?

Même si j'ai dit que React est plus simple que les frameworks alternatifs, se plonger dans React est toujours compliqué, mais surtout à cause des technologies corollaires qui peuvent être intégrées avec React, comme Redux et GraphQL.

React en lui-même a une API très petite, et vous devez essentiellement comprendre 4 concepts pour commencer :

* Composants
* JSX
* État
* Props

Tous ces concepts (et plus) sont expliqués dans ce manuel.

#### Comment installer React sur votre ordinateur de développement

Comment installez-vous React ?

React est une bibliothèque, donc dire _installer_ peut sembler un peu étrange. Peut-être que _configurer_ est un meilleur mot, mais vous comprenez le concept.

Il existe diverses façons de configurer React afin qu'il puisse être utilisé sur votre application ou site.

#### Charger React directement dans la page web

La plus simple consiste à ajouter le fichier JavaScript React directement dans la page. Cela est idéal lorsque votre application React interagira avec les éléments présents sur une seule page, et ne contrôlera pas réellement l'aspect de navigation.

Dans ce cas, vous ajoutez 2 balises de script à la fin de la balise `body` :

```html
<html>
  ...
  <body>
    ...
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/react/16.8.3/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.3/umd/react-dom.production.min.js"
      crossorigin
    ></script>
  </body>
</html>
```

> _Veuillez changer le numéro de version pour la dernière version de React disponible._

Ici, nous avons chargé à la fois React et React DOM. Pourquoi 2 bibliothèques ? Parce que React est 100 % indépendant du navigateur et peut être utilisé en dehors de celui-ci (par exemple sur des appareils mobiles avec React Native). D'où le besoin de React DOM, pour ajouter les enveloppes pour le navigateur.

Après ces balises, vous pouvez charger vos fichiers JavaScript qui utilisent React, ou même du JavaScript en ligne dans une balise `script` :

```html
<script src="app.js"></script>

<!-- ou -->

<script>
  //mon app
</script>
```

Pour utiliser JSX, vous avez besoin d'une étape supplémentaire : charger Babel

```html
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

et charger vos scripts avec le type MIME spécial `text/babel` :

```html
<script src="app.js" type="text/babel"><;/script>
```

Maintenant, vous pouvez ajouter JSX dans votre fichier app.js :

```jsx
const Button = () => {
  return <button>Cliquez-moi !</button>
}

ReactDOM.render(<Button />, document.getElementById('root'))
```

Consultez cet exemple simple Glitch : [https://glitch.com/edit/#!/react-example-inline-jsx?path=script.js](https://glitch.com/edit/#!/react-example-inline-jsx?path=script.js)

Commencer de cette manière avec des balises de script est bon pour construire des prototypes et permet un démarrage rapide sans avoir à configurer un flux de travail complexe.

### Comment utiliser create-react-app

`create-react-app` est un projet visant à vous faire démarrer rapidement avec React, et toute application React qui doit dépasser une seule page trouvera que `create-react-app` répond à ce besoin.

Vous commencez par utiliser `[npx](https://flaviocopes.com/npx/)`, qui est un moyen facile de télécharger et d'exécuter des commandes Node.js sans les installer. `npx` vient avec `npm` (depuis la version 5.2) et si vous n'avez pas encore npm installé, faites-le maintenant depuis [https://nodejs.org](https://nodejs.org/) (npm est installé avec Node).

Si vous n'êtes pas sûr de la version de npm que vous avez, exécutez `npm -v` pour vérifier si vous devez mettre à jour.

> _Astuce : consultez mon [tutoriel sur le terminal OSX](https://flaviocopes.com/macos-terminal/) si vous n'êtes pas familier avec l'utilisation du terminal, s'applique également à Linux — je suis désolé mais je n'ai pas de tutoriel pour Windows pour le moment, mais Google est votre ami._

Lorsque vous exécutez `npx create-react-app <nom-de-l-app>`, `npx` va _télécharger_ la dernière version de `create-react-app`, l'exécuter, puis la supprimer de votre système. C'est génial car vous n'aurez jamais une version obsolète sur votre système, et chaque fois que vous l'exécutez, vous obtenez le dernier et meilleur code disponible.

Commençons alors :

```bash
npx create-react-app todolist
```

![Image](https://cdn-media-1.freecodecamp.org/images/bZgizsJA2eDZwRUPT9KmAuqaWq2z-i5JYO49)

C'est quand il a fini de s'exécuter :

![Image](https://cdn-media-1.freecodecamp.org/images/yJPelCCT4muE3FcEci5CIDm4GEyy5rvdh6R5)

`create-react-app` a créé une structure de fichiers dans le dossier que vous avez indiqué (`todolist` dans ce cas), et a initialisé un dépôt [Git](https://flaviocopes.com/git/).

Il a également ajouté quelques commandes dans le fichier `package.json`, afin que vous puissiez immédiatement démarrer l'application en allant dans le dossier et en exécutant `npm start`.

![Image](https://cdn-media-1.freecodecamp.org/images/bIcUqq3FBoasmTjSSeYJ1LA4yMndxfNF12nu)

![Image](https://cdn-media-1.freecodecamp.org/images/bD33lX4Yp0WYlgDNGCwr3Otftsstxvx1HvTQ)

En plus de `npm start`, `create-react-app` a ajouté quelques autres commandes :

* `npm run build` : pour construire les fichiers de l'application React dans le dossier `build`, prêts à être déployés sur un serveur
* `npm test` : pour exécuter la suite de tests en utilisant [Jest](https://flaviocopes.com/jest/)
* `npm eject` : pour éjecter de `create-react-app`

L'éjection est l'acte de décider que `create-react-app` a fait assez pour vous, mais que vous voulez faire plus que ce qu'il permet.

Puisque `create-react-app` est un ensemble de conventions de dénominateur commun et un nombre limité d'options, il est probable qu'à un moment donné vos besoins demanderont quelque chose d'unique qui dépasse les capacités de `create-react-app`.

Lorsque vous éjectez, vous perdez la capacité de mises à jour automatiques mais vous gagnez plus de flexibilité dans la configuration de [Babel](https://flaviocopes.com/babel/) et [Webpack](https://flaviocopes.com/webpack/).

Lorsque vous éjectez, l'action est irréversible. Vous obtiendrez 2 nouveaux dossiers dans votre répertoire d'application, `config` et `scripts`. Ceux-ci contiennent les configurations - et maintenant vous pouvez commencer à les éditer.

> _Si vous avez déjà une application React installée en utilisant une ancienne version de React, vérifiez d'abord la version en ajoutant `console.log(React.version)` dans votre application, puis vous pouvez mettre à jour en exécutant `yarn add react@16.7`, et yarn vous invitera à mettre à jour (choisissez la dernière version disponible). Répétez pour `yarn add react-dom@16.7` (changez "16.7" par la version la plus récente de React à ce moment)_

#### CodeSandbox

Un moyen facile d'avoir la structure `create-react-app`, sans l'installer, est d'aller sur [https://codesandbox.io/s](https://codesandbox.io/s) et de choisir "React".

![Image](https://cdn-media-1.freecodecamp.org/images/DQRfUlIow3Z-icJy6XcMwTWh7gd8ZCwac02l)

CodeSandbox est un excellent moyen de démarrer un projet React sans avoir à l'installer localement.

#### Codepen

Une autre excellente solution est [Codepen](https://codepen.io/).

Vous pouvez utiliser ce projet de démarrage Codepen qui est déjà pré-configuré avec React, avec support pour les Hooks : [https://codepen.io/flaviocopes/pen/VqeaxB](https://codepen.io/flaviocopes/pen/VqeaxB)

Les "pens" Codepen sont idéaux pour des projets rapides avec un seul fichier JavaScript, tandis que les "projets" sont idéaux pour des projets avec plusieurs fichiers, comme ceux que nous utiliserons le plus lors de la construction d'applications React.

Une chose à noter est que dans Codepen, en raison de son fonctionnement interne, vous n'utilisez pas la syntaxe d'importation de modules ES régulière, mais plutôt pour importer par exemple `useState`, vous utilisez

```jsx
const { useState } = React
```

et non

```jsx
import { useState } from 'react'
```

### SECTION 1 : CONCEPTS CORE DE JAVASCRIPT MODERNE QUE VOUS DEVEZ CONNAÎTRE POUR UTILISER REACT

#### Découvrez si vous devez apprendre quelque chose avant de vous plonger dans l'apprentissage de React

Si vous êtes prêt à apprendre React, vous devez d'abord avoir quelques choses sous la main. Il y a certaines technologies préalables que vous devez connaître, en particulier liées à certaines des fonctionnalités JavaScript plus récentes que vous utiliserez encore et encore dans React.

Parfois, les gens pensent qu'une fonctionnalité particulière est fournie par React, mais en réalité, ce n'est que la syntaxe JavaScript moderne.

Il n'y a pas besoin d'être un expert dans ces sujets tout de suite, mais plus vous vous plongez dans React, plus vous devrez maîtriser ces concepts.

Je vais mentionner une liste de choses pour vous mettre à niveau rapidement.

### Variables

Une variable est un littéral assigné à un identifiant, afin que vous puissiez le référencer et l'utiliser plus tard dans le programme.

Les variables en JavaScript n'ont aucun type attaché. Une fois que vous avez assigné un type de littéral spécifique à une variable, vous pouvez plus tard réassigner la variable pour héberger n'importe quel autre type, sans erreurs de type ou aucun problème.

C'est pourquoi JavaScript est parfois appelé « non typé ».

Une variable doit être déclarée avant de pouvoir l'utiliser. Il y a 3 façons de le faire, en utilisant `var`, `let` ou `const`, et ces 3 façons diffèrent dans la manière dont vous pouvez interagir avec la variable plus tard.

#### Utilisation de `var`

Jusqu'à ES2015, `var` était la seule construction disponible pour définir des variables.

```jsx
var a = 0
```

Si vous oubliez d'ajouter `var`, vous allez assigner une valeur à une variable non déclarée, et les résultats peuvent varier.

Dans les environnements modernes, avec le mode strict activé, vous obtiendrez une erreur. Dans les anciens environnements (ou avec le mode strict désactivé), cela initialisera simplement la variable et l'assignera à l'objet global.

Si vous n'initialisez pas la variable lorsque vous la déclarez, elle aura la valeur `undefined` jusqu'à ce que vous lui assigniez une valeur.

```jsx
var a //typeof a === 'undefined'
```

Vous pouvez redéclarer la variable plusieurs fois, en l'écrasant :

```jsx
var a = 1
var a = 2
```

Vous pouvez également déclarer plusieurs variables en une seule fois dans la même instruction :

```js
var a = 1, b = 2jsx
```

La **portée** est la portion de code où la variable est visible.

Une variable initialisée avec `var` en dehors de toute fonction est assignée à l'objet global, a une portée globale et est visible partout. Une variable initialisée avec `var` à l'intérieur d'une fonction est assignée à cette fonction, elle est locale et n'est visible qu'à l'intérieur de celle-ci, tout comme un paramètre de fonction.

Toute variable définie dans une fonction avec le même nom qu'une variable globale prend le pas sur la variable globale, l'éclipse.

Il est important de comprendre qu'un bloc (identifié par une paire d'accolades) ne définit pas une nouvelle portée. Une nouvelle portée n'est créée que lorsqu'une fonction est créée, car `var` n'a pas de portée de bloc, mais une portée de fonction.

À l'intérieur d'une fonction, toute variable définie dans celle-ci est visible dans tout le code de la fonction, même si la variable est déclarée à la fin de la fonction, elle peut toujours être référencée au début, car JavaScript avant d'exécuter le code _déplace en réalité toutes les variables en haut_ (quelque chose qui est appelé **hoisting**). Pour éviter la confusion, déclarez toujours les variables au début d'une fonction.

#### Utilisation de `let`

`let` est une nouvelle fonctionnalité introduite dans ES2015 et c'est essentiellement une version de `var` avec portée de bloc. Sa portée est limitée au bloc, à l'instruction ou à l'expression où elle est définie, et à tous les blocs internes contenus.

Les développeurs JavaScript modernes peuvent choisir d'utiliser uniquement `let` et d'abandonner complètement l'utilisation de `var`.

> _Si `let` semble un terme obscur, lisez simplement `let color = 'red'` comme_ que la couleur soit rouge _et tout devient beaucoup plus clair_

Définir `let` en dehors de toute fonction - contrairement à `var` - ne crée pas une variable globale.

#### Utilisation de `const`

Les variables déclarées avec `var` ou `let` peuvent être modifiées plus tard dans le programme, et réassignées. Une fois qu'un `const` est initialisé, sa valeur ne peut jamais être changée à nouveau, et il ne peut pas être réassigné à une valeur différente.

```jsx
const a = 'test'
```
Nous ne pouvons pas assigner une autre valeur littérale à la `const` `a`. Cependant, nous pouvons muter `a` si c'est un objet qui fournit des méthodes mutantes pour son contenu.

`const` ne fournit pas d'immuabilité, il garantit simplement que la référence ne peut pas être changée.

`const` a une portée de bloc, comme `let`.

Les développeurs JavaScript modernes peuvent choisir d'utiliser toujours `const` pour les variables qui n'ont pas besoin d'être réassignées plus tard dans le programme.

Pourquoi ? Parce que nous devons toujours utiliser la structure la plus simple disponible pour éviter de faire des erreurs plus tard.

### Fonctions fléchées

Les fonctions fléchées ont été introduites dans ES6 / ECMAScript 2015, et depuis leur introduction, elles ont changé à jamais l'apparence (et le fonctionnement) du code JavaScript.

À mon avis, ce changement a été si bien accueilli que l'on voit rarement l'utilisation du mot-clé `function` dans les bases de code modernes.

Visuellement, c'est un changement simple et bienvenu, qui permet d'écrire des fonctions avec une syntaxe plus courte, passant de :

```jsx
const myFunction = function() {
  //...
}
```

à

```jsx
const myFunction = () => {
  //...
}
```

Si le corps de la fonction ne contient qu'une seule instruction, vous pouvez omettre les accolades et tout écrire sur une seule ligne :

```jsx
const myFunction = () => doSomething()
```

Les paramètres sont passés entre parenthèses :

```jsx
const myFunction = (param1, param2) => doSomething(param1, param2)
```

Si vous avez un (et un seul) paramètre, vous pouvez omettre complètement les parenthèses :

```jsx
const myFunction = param => doSomething(param)
```

Grâce à cette syntaxe courte, les fonctions fléchées **encouragent l'utilisation de petites fonctions**.

### Retour implicite

Les fonctions fléchées permettent d'avoir un retour implicite : les valeurs sont retournées sans avoir à utiliser le mot-clé `return`.

Cela fonctionne lorsqu'il y a une instruction sur une seule ligne dans le corps de la fonction :

```jsx
const myFunction = () => 'test'

myFunction() //'test'
```

Un autre exemple, lors du retour d'un objet, n'oubliez pas d'envelopper les accolades dans des parenthèses pour éviter qu'elles soient considérées comme les accolades du corps de la fonction :

```jsx
const myFunction = () => ({ value: 'test' })

myFunction() //{value: 'test'}
```

### Comment `this` fonctionne dans les fonctions fléchées

`this` est un concept qui peut être compliqué à comprendre, car il varie beaucoup en fonction du contexte et varie également en fonction du mode de JavaScript (mode _strict_ ou non).

Il est important de clarifier ce concept car les fonctions fléchées se comportent très différemment par rapport aux fonctions régulières.

Lorsque défini comme méthode d'un objet, dans une fonction régulière, `this` fait référence à l'objet, donc vous pouvez faire :

```jsx
const car = {
  model: 'Fiesta',
  manufacturer: 'Ford',
  fullName: function() {
    return `${this.manufacturer} ${this.model}`
  }
}
```

appeler `car.fullName()` retournera `"Ford Fiesta"`.

La portée de `this` avec les fonctions fléchées est **héritée** du contexte d'exécution. Une fonction fléchée ne lie pas du tout `this`, donc sa valeur sera recherchée dans la pile d'appels, donc dans ce code, `car.fullName()` ne fonctionnera pas et retournera la chaîne `"undefined undefined"` :

```jsx
const car = {
  model: 'Fiesta',
  manufacturer: 'Ford',
  fullName: () => {
    return `${this.manufacturer} ${this.model}`
  }
}
```

En raison de cela, les fonctions fléchées ne conviennent pas comme méthodes d'objet.

Les fonctions fléchées ne peuvent pas non plus être utilisées comme constructeurs, l'instantiation d'un objet lèvera une `TypeError`.

C'est là que les fonctions régulières doivent être utilisées à la place, **lorsqu'un contexte dynamique n'est pas nécessaire**.

C'est aussi un problème lors de la gestion des événements. Les écouteurs d'événements DOM définissent `this` comme étant l'élément cible, et si vous dépendez de `this` dans un gestionnaire d'événements, une fonction régulière est nécessaire :

```jsx
const link = document.querySelector('#link')
link.addEventListener('click', () => {
  // this === window
})

const link = document.querySelector('#link')
link.addEventListener('click', function() {
  // this === link
})
```

### Rest et spread

Vous pouvez développer un tableau, un objet ou une chaîne de caractères en utilisant l'opérateur de spread `...`.

Commençons par un exemple de tableau. Étant donné

```jsx
const a = [1, 2, 3]
```

tu peux créer un nouveau tableau en utilisant

```jsx
const b = [...a, 4, 5, 6]
```

Tu peux aussi créer une copie d'un tableau en utilisant

```jsx
const c = [...a]
```

Cela fonctionne également pour les objets. Clone un objet avec :

```jsx
const newObj = { ...oldObj }
```

En utilisant des chaînes de caractères, l'opérateur de spread crée un tableau avec chaque caractère de la chaîne :

```jsx
const hey = 'hey'
const arrayized = [...hey] // ['h', 'e', 'y']
```

Cet opérateur a des applications assez utiles. La plus importante est la capacité d'utiliser un tableau comme argument de fonction de manière très simple :

```jsx
const f = (foo, bar) => {}
const a = [1, 2]
f(...a)
```

(par le passé, tu pouvais faire cela en utilisant `f.apply(null, a)` mais ce n'est pas aussi beau et lisible)

L'**élément rest** est utile lors de l'utilisation de la **destructuration de tableau** :

```jsx
const numbers = [1, 2, 3, 4, 5]
[first, second, ...others] = numbers
```

et **éléments spread** :

```jsx
const numbers = [1, 2, 3, 4, 5]
const sum = (a, b, c, d, e) => a + b + c + d + e
const sumOfNumbers = sum(...numbers)
```

ES2018 introduit les propriétés rest, qui sont les mêmes mais pour les objets.

**Propriétés rest** :

```jsx
const { first, second, ...others } = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5
}

first // 1
second // 2
others // { third: 3, fourth: 4, fifth: 5 }
```

**Propriétés spread** permettent de créer un nouvel objet en combinant les propriétés de l'objet passé après l'opérateur de spread :

```jsx
const items = { first, second, ...others }
items //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }
```

### Destructuration d'objets et de tableaux

Étant donné un objet, en utilisant la syntaxe de destructuration, tu peux extraire certaines valeurs et les mettre dans des variables nommées :

```jsx
const person = {
  firstName: 'Tom',
  lastName: 'Cruise',
  actor: true,
  age: 54 //inventé
}

const { firstName: name, age } = person //name: Tom, age: 54
```

`name` et `age` contiennent les valeurs souhaitées.

La syntaxe fonctionne également sur les tableaux :

```jsx
const a = [1, 2, 3, 4, 5]
const [first, second] = a
```

Cette instruction crée 3 nouvelles variables en obtenant les éléments avec les index 0, 1, 4 du tableau `a` :

```jsx
const [first, second, , , fifth] = a
```

### Littéraux de gabarit

Les littéraux de gabarit sont une nouvelle fonctionnalité ES2015 / ES6 qui permet de travailler avec des chaînes de caractères de manière nouvelle par rapport à ES5 et versions antérieures.

La syntaxe, à première vue, est très simple, il suffit d'utiliser des backticks au lieu de guillemets simples ou doubles :

```jsx
const a_string = `something`
```

Ils sont uniques car ils offrent de nombreuses fonctionnalités que les chaînes normales construites avec des guillemets ne fournissent pas, en particulier :

* ils offrent une excellente syntaxe pour définir des chaînes multilignes
* ils fournissent un moyen facile d'interpoler des variables et des expressions dans des chaînes
* ils permettent de créer des DSL avec des balises de gabarit (DSL signifie langage spécifique de domaine, et il est utilisé par exemple dans React par Styled Components, pour définir du CSS pour un composant)

Plongeons dans chacun de ces détails.

#### Chaînes multilignes

Avant ES6, pour créer une chaîne s'étendant sur deux lignes, il fallait utiliser le caractère `\` à la fin d'une ligne :

```jsx
const string =
  'first part \
second part'
```

Cela permet de créer une chaîne sur 2 lignes, mais elle est rendue sur une seule ligne :

`first part second part`

Pour rendre la chaîne sur plusieurs lignes également, il faut explicitement ajouter `\n` à la fin de chaque ligne, comme ceci :

```
const string =
  'first line\n \
second line'
```

ou

```
const string = 'first line\n' + 'second line'
```

Les littéraux de gabarit rendent les chaînes multilignes beaucoup plus simples.

Une fois qu'un littéral de gabarit est ouvert avec le backtick, il suffit de presser entrée pour créer une nouvelle ligne, sans caractères spéciaux, et il est rendu tel quel :

```
const string = `Hey
this
string
is awesome!`
```

Gardez à l'esprit que l'espace est significatif, donc faire ceci :

```
const string = `First
                Second`
```

va créer une chaîne comme ceci :

```jsx
First
                Second
```

Un moyen facile de corriger ce problème est d'avoir une première ligne vide, et d'ajouter la méthode trim() juste après le backtick de fermeture, ce qui éliminera tout espace avant le premier caractère :

```jsx
const string = `
First
Second`.trim()
```

#### Interpolation

Les littéraux de gabarit fournissent un moyen facile d'interpoler des variables et des expressions dans des chaînes.

Tu le fais en utilisant la syntaxe `${...}` :

```jsx
const myVariable = 'test'
const string = `something ${myVariable}` //something test
```

À l'intérieur de `${}` tu peux ajouter n'importe quoi, même des expressions :

```jsx
const string = `something ${1 + 2 + 3}`
const string2 = `something ${foo() ? 'x' : 'y'}`
```

### Classes

En 2015, la norme ECMAScript 6 (ES6) a introduit les classes.

JavaScript a une manière assez inhabituelle d'implémenter l'héritage : l'héritage prototypal. [L'héritage prototypal](https://flaviocopes.com/javascript-prototypal-inheritance/), bien que, à mon avis, excellent, est différent de la plupart des autres langages de programmation populaires, qui sont basés sur des classes.

Les personnes venant de Java ou Python ou d'autres langages ont eu du mal à comprendre les intricacies de l'héritage prototypal, donc le comité ECMAScript a décidé d'ajouter du sucre syntaxique par-dessus l'héritage prototypal pour qu'il ressemble à la façon dont l'héritage basé sur les classes fonctionne dans d'autres implémentations populaires.

C'est important : JavaScript sous le capot reste le même, et tu peux accéder au prototype d'un objet de la manière habituelle.

#### Définition d'une classe

Voici à quoi ressemble une classe.

```jsx
class Person {
  constructor(name) {
    this.name = name
  }
  
  hello() {
    return 'Hello, I am ' + this.name + '.'
  }
}
```

Une classe a un identifiant, que nous pouvons utiliser pour créer de nouveaux objets en utilisant `new ClassIdentifier()`.

Lorsque l'objet est initialisé, la méthode `constructor` est appelée, avec tous les paramètres passés.

Une classe a également autant de méthodes que nécessaire. Dans ce cas, `hello` est une méthode et peut être appelée sur tous les objets dérivés de cette classe :

```
const flavio = new Person('Flavio')
flavio.hello()
```

#### Héritage de classe

Une classe peut étendre une autre classe, et les objets initialisés en utilisant cette classe héritent de toutes les méthodes des deux classes.

Si la classe héritée a une méthode avec le même nom qu'une des classes plus haut dans la hiérarchie, la méthode la plus proche prend le pas :

```jsx
class Programmer extends Person {
  hello() {
    return super.hello() + ' I am a programmer.'
  }
}

const flavio = new Programmer('Flavio')
flavio.hello()
```

(le programme ci-dessus imprime "Hello, I am Flavio. I am a programmer.")

Les classes n'ont pas de déclarations explicites de variables de classe, mais tu dois initialiser toute variable dans le constructeur.

À l'intérieur d'une classe, tu peux référencer la classe parente en appelant `super()`.

#### Méthodes statiques

Normalement, les méthodes sont définies sur l'instance, pas sur la classe.

Les méthodes statiques sont exécutées sur la classe à la place :

```jsx
class Person {
  static genericHello() {
    return 'Hello'
  }
}

Person.genericHello() //Hello
```

#### Méthodes privées

JavaScript n'a pas de moyen intégré pour définir des méthodes privées ou protégées.

Il existe des solutions de contournement, mais je ne les décrirai pas ici.

#### Getters et setters

Tu peux ajouter des méthodes préfixées avec `get` ou `set` pour créer un getter et un setter, qui sont deux morceaux de code différents exécutés en fonction de ce que tu fais : accéder à la variable, ou modifier sa valeur.

```jsx
class Person {
  constructor(name) {
    this.name = name
  }
  
  set name(value) {
    this.name = value
  }
  
  get name() {
    return this.name
  }
}
```

Si tu n'as qu'un getter, la propriété ne peut pas être définie, et toute tentative de le faire sera ignorée :

```
class Person {
  constructor(name) {
    this.name = name
  }
  
  get name() {
    return this.name
  }
}
```

Si tu n'as qu'un setter, tu peux changer la valeur mais pas y accéder de l'extérieur :

```
class Person {
  constructor(name) {
    this.name = name
  }
  
  set name(value) {
    this.name = value
  }
}
```

### Callbacks

Les ordinateurs sont asynchrones par conception.

Asynchrone signifie que les choses peuvent se produire indépendamment du flux principal du programme.

Dans les ordinateurs grand public actuels, chaque programme s'exécute pendant un intervalle de temps spécifique, puis il arrête son exécution pour permettre à un autre programme de continuer son exécution. Ce cycle est si rapide qu'il est impossible de le remarquer, et nous pensons que nos ordinateurs exécutent de nombreux programmes simultanément, mais c'est une illusion (sauf sur les machines multiprocesseurs).

Les programmes utilisent en interne des _interruptions_, un signal émis au processeur pour attirer l'attention du système.

Je ne vais pas entrer dans les détails internes de cela, mais garde simplement à l'esprit qu'il est normal pour les programmes d'être asynchrones, et d'arrêter leur exécution jusqu'à ce qu'ils aient besoin d'attention, et l'ordinateur peut exécuter d'autres choses en attendant. Lorsqu'un programme attend une réponse du réseau, il ne peut pas arrêter le processeur jusqu'à ce que la requête se termine.

Normalement, les langages de programmation sont synchrones, et certains fournissent un moyen de gérer l'asynchronicité, dans le langage ou via des bibliothèques. C, Java, C#, PHP, Go, Ruby, Swift, Python, ils sont tous synchrones par défaut. Certains d'entre eux gèrent l'async en utilisant des threads, en créant un nouveau processus.

JavaScript est **synchrone** par défaut et est mono-threadé. Cela signifie que le code ne peut pas créer de nouveaux threads et s'exécuter en parallèle.

Les lignes de code sont exécutées en série, l'une après l'autre, par exemple :

```jsx
const a = 1
const b = 2
const c = a * b
console.log(c)
doSomething()
```

Mais JavaScript est né dans le navigateur, son travail principal, au début, était de répondre aux actions de l'utilisateur, comme `onClick`, `onMouseOver`, `onChange`, `onSubmit` et ainsi de suite. Comment pouvait-il faire cela avec un modèle de programmation synchrone ?

La réponse était dans son environnement. Le **navigateur** fournit un moyen de le faire en fournissant un ensemble d'API qui peuvent gérer ce type de fonctionnalité.

Plus récemment, Node.js a introduit un environnement d'E/S non bloquant pour étendre ce concept à l'accès aux fichiers, aux appels réseau et ainsi de suite.

Tu ne peux pas savoir quand un utilisateur va cliquer sur un bouton, donc ce que tu fais, c'est que tu **définis un gestionnaire d'événements pour l'événement de clic**. Ce gestionnaire d'événements accepte une fonction, qui sera appelée lorsque l'événement est déclenché :

```
document.getElementById('button').addEventListener('click', () => {
  //item clicked
})
```

C'est ce qu'on appelle le **callback**.

Un callback est une fonction simple qui est passée en tant que valeur à une autre fonction, et ne sera exécutée que lorsque l'événement se produira. Nous pouvons faire cela car JavaScript a des fonctions de première classe, qui peuvent être assignées à des variables et passées à d'autres fonctions (appelées **fonctions d'ordre supérieur**)

Il est courant d'envelopper tout ton code client dans un écouteur d'événements `load` sur l'objet `window`, qui exécute la fonction de callback uniquement lorsque la page est prête :

```
window.addEventListener('load', () => {
  //window loaded
  //do what you want
})
```

Les callbacks sont utilisés partout, pas seulement dans les événements DOM.

Un exemple courant est l'utilisation de timers :

```
setTimeout(() => {
  // runs after 2 seconds
}, 2000)
```

Les requêtes XHR acceptent également un callback, dans cet exemple en assignant une fonction à une propriété qui sera appelée lorsqu'un événement particulier se produit (dans ce cas, l'état de la requête change) :

```
const xhr = new XMLHttpRequest()
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')
  }
}
xhr.open('GET', 'https://yoursite.com')
xhr.send()
```

#### Gestion des erreurs dans les callbacks

Comment gères-tu les erreurs avec les callbacks ? Une stratégie très courante consiste à utiliser ce que Node.js a adopté : le premier paramètre dans toute fonction de callback est l'objet d'erreur : **error-first callbacks**

Si il n'y a pas d'erreur, l'objet est `null`. Si il y a une erreur, il contient une description de l'erreur et d'autres informations.

```
fs.readFile('/file.json', (err, data) => {
  if (err !== null) {
    //handle error
    console.log(err)
    return
  }
  
  //no errors, process data
  console.log(data)
})
```

#### Le problème avec les callbacks

Les callbacks sont excellents pour les cas simples !

Cependant, chaque callback ajoute un niveau de nesting, et lorsque tu as beaucoup de callbacks, le code commence à devenir compliqué très rapidement :

```
window.addEventListener('load', () => {
  document.getElementById('button').addEventListener('click', () => {
    setTimeout(() => {
      items.forEach(item => {
        //your code here
      })
    }, 2000)
  })
})
```

Ce n'est qu'un simple code à 4 niveaux, mais j'ai vu beaucoup plus de niveaux de nesting et ce n'est pas amusant.

Comment résolvons-nous cela ?

### ALTERNATIVES AUX CALLBACKS

À partir de ES6, JavaScript a introduit plusieurs fonctionnalités qui nous aident avec le code asynchrone qui n'impliquent pas l'utilisation de callbacks :

* Promesses (ES6)
* Async/Await (ES8)

### Promesses

Les promesses sont un moyen de gérer le code asynchrone, sans écrire trop de callbacks dans ton code.

Bien qu'elles existent depuis des années, elles ont été standardisées et introduites dans ES2015, et maintenant elles ont été remplacées dans ES2017 par les fonctions asynchrones.

Les **fonctions asynchrones** utilisent l'API des promesses comme leur bloc de construction, donc les comprendre est fondamental même si dans le code plus récent tu utiliseras probablement des fonctions asynchrones au lieu de promesses.

#### Comment fonctionnent les promesses, en bref

Une fois qu'une promesse a été appelée, elle commence dans un **état en attente**. Cela signifie que la fonction appelante continue l'exécution, tandis qu'elle attend que la promesse fasse son propre traitement, et donne un retour à la fonction appelante.

À ce stade, la fonction appelante attend qu'elle retourne la promesse dans un **état résolu**, ou dans un **état rejeté**, mais comme tu le sais, JavaScript est asynchrone, donc _la fonction continue son exécution pendant que la promesse fait son travail_.

#### Quelles API JS utilisent les promesses ?

En plus de ton propre code et du code de bibliothèque, les promesses sont utilisées par des API Web modernes standard comme [Fetch](https://flaviocopes.com/fetch-api/) ou [Service Workers](https://flaviocopes.com/service-workers/).

Il est peu probable que dans le JavaScript moderne tu te retrouves à _ne pas_ utiliser les promesses, donc commençons à plonger directement dans celles-ci.

#### Créer une promesse

L'API Promise expose un constructeur Promise, que tu initialises en utilisant `new Promise()` :

```
let done = true

const isItDoneYet = new Promise((resolve, reject) => {
  if (done) {
    const workDone = 'Here is the thing I built'
    resolve(workDone)
  } else {
    const why = 'Still working on something else'
    reject(why)
  }
})
```

Comme tu peux le voir, la promesse vérifie la constante globale `done`, et si elle est vraie, nous retournons une promesse résolue, sinon une promesse rejetée.

En utilisant `resolve` et `reject`, nous pouvons communiquer une valeur, dans le cas ci-dessus, nous retournons simplement une chaîne, mais cela pourrait être un objet également.

#### Consommer une promesse

Dans la dernière section, nous avons introduit comment une promesse est créée.

Maintenant, voyons comment la promesse peut être _consommée_ ou utilisée.

```
const isItDoneYet = new Promise()
//...

const checkIfItsDone = () => {
  isItDoneYet
    .then(ok => {
      console.log(ok)
    })
    .catch(err => {
      console.error(err)
    })
}
```

L'exécution de `checkIfItsDone()` exécutera la promesse `isItDoneYet()` et attendra qu'elle se résolve, en utilisant le callback `then`, et s'il y a une erreur, elle la gérera dans le callback `catch`.

#### Chaînage de promesses

Une promesse peut être retournée à une autre promesse, créant une chaîne de promesses.
Un excellent exemple de chaînage de promesses est donné par l'[API Fetch](https://flaviocopes.com/fetch-api/), une couche au-dessus de l'API XMLHttpRequest, que nous pouvons utiliser pour obtenir une ressource et mettre en file d'attente une chaîne de promesses à exécuter lorsque la ressource est récupérée.

L'API Fetch est un mécanisme basé sur les promesses, et l'appel à `fetch()` est équivalent à définir notre propre promesse en utilisant `new Promise()`.

Exemple :

```
const status = response => {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response)
  }
  return Promise.reject(new Error(response.statusText))
}

const json = response => response.json()

fetch('/todos.json')
  .then(status)
  .then(json)
  .then(data => {
    console.log('Requête réussie avec réponse JSON', data)
  })
  .catch(error => {
    console.log('Requête échouée', error)
  })
```

Dans cet exemple, nous appelons `fetch()` pour obtenir une liste d'éléments TODO à partir du fichier `todos.json` trouvé à la racine du domaine, et nous créons une chaîne de promesses.

L'exécution de `fetch()` retourne une [réponse](https://fetch.spec.whatwg.org/#concept-response), qui a de nombreuses propriétés, et parmi celles-ci nous référençons :

* `status`, une valeur numérique représentant le code d'état HTTP
* `statusText`, un message d'état, qui est `OK` si la requête a réussi

`response` a également une méthode `json()`, qui retourne une promesse qui se résoudra avec le contenu du corps traité et transformé en JSON.

Étant donné ces prémisses, voici ce qui se passe : la première promesse de la chaîne est une fonction que nous avons définie, appelée `status()`, qui vérifie l'état de la réponse et si ce n'est pas une réponse de succès (entre 200 et 299), elle rejette la promesse.

Cette opération fera sauter la chaîne de promesses à toutes les promesses enchaînées listées et passera directement à l'instruction `catch()` en bas, enregistrant le texte `Request failed` ainsi que le message d'erreur.

Si cela réussit, elle appelle la fonction json() que nous avons définie. Puisque la promesse précédente, lorsqu'elle est réussie, a retourné l'objet `response`, nous l'obtenons en entrée de la deuxième promesse.

Dans ce cas, nous retournons les données JSON traitées, donc la troisième promesse reçoit le JSON directement :

```
.then((data) => {
  console.log('Requête réussie avec réponse JSON', data)
})
```

et nous l'enregistrons simplement dans la console.

#### Gestion des erreurs

Dans l'exemple ci-dessus, dans la section précédente, nous avions un `catch` qui était ajouté à la chaîne de promesses.

Lorsque quelque chose dans la chaîne de promesses échoue et lève une erreur ou rejette la promesse, le contrôle passe à l'instruction `catch()` la plus proche dans la chaîne.

```
new Promise((resolve, reject) => {
  throw new Error('Erreur')
}).catch(err => {
  console.error(err)
})

// ou

new Promise((resolve, reject) => {
  reject('Erreur')
}).catch(err => {
  console.error(err)
})
```

#### Erreurs en cascade

Si à l'intérieur du `catch()` vous levez une erreur, vous pouvez ajouter un deuxième `catch()` pour la gérer, et ainsi de suite.

```
new Promise((resolve, reject) => {
  throw new Error('Erreur')
})
  .catch(err => {
    throw new Error('Erreur')
  })
  .catch(err => {
    console.error(err)
  })
```

#### Orchestration des promesses avec `Promise.all()`

Si vous devez synchroniser différentes promesses, `Promise.all()` vous aide à définir une liste de promesses, et à exécuter quelque chose lorsqu'elles sont toutes résolues.

Exemple :

```
const f1 = fetch('/something.json')
const f2 = fetch('/something2.json')

Promise.all([f1, f2])
  .then(res => {
    console.log('Tableau de résultats', res)
  })
  .catch(err => {
    console.error(err)
  })
```

La syntaxe d'affectation par déstructuration ES2015 vous permet également de faire

```jsx
Promise.all([f1, f2]).then(([res1, res2]) => {
  console.log('Résultats', res1, res2)
})
```

Vous n'êtes pas limité à utiliser `fetch` bien sûr, **toute promesse est bonne à utiliser**.

#### Orchestration des promesses avec `Promise.race()`

`Promise.race()` s'exécute dès qu'une des promesses que vous lui passez est résolue, et exécute le callback attaché une seule fois avec le résultat de la première promesse résolue.

Exemple :

```
const promiseOne = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, 'one')
})
const promiseTwo = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'two')
})

Promise.race([promiseOne, promiseTwo]).then(result => {
  console.log(result) // 'two'
})
```

### Async/Await

JavaScript a évolué très rapidement des callbacks aux promesses (ES2015), et depuis ES2017, JavaScript asynchrone est encore plus simple avec la syntaxe async/await.

Les fonctions asynchrones sont une combinaison de promesses et de générateurs, et essentiellement, elles sont une abstraction de plus haut niveau sur les promesses. Laissez-moi répéter : **async/await est construit sur les promesses**.

#### Pourquoi async/await a-t-il été introduit ?

Ils réduisent le code répétitif autour des promesses, et la limitation "ne pas rompre la chaîne" du chaînage des promesses.

Lorsque les promesses ont été introduites dans ES2015, elles étaient destinées à résoudre un problème avec le code asynchrone, et elles l'ont fait, mais au cours des 2 années qui ont séparé ES2015 et ES2017, il était clair que _les promesses ne pouvaient pas être la solution finale_.

Les promesses ont été introduites pour résoudre le célèbre problème de _l'enfer des callbacks_, mais elles ont introduit leur propre complexité, et une complexité syntaxique.

Elles étaient de bonnes primitives autour desquelles une meilleure syntaxe pouvait être exposée aux développeurs, donc lorsque le moment était venu, nous avons obtenu des **fonctions asynchrones**.

Elles font en sorte que le code semble synchrone, mais il est asynchrone et non bloquant en arrière-plan.

#### Comment cela fonctionne

Une fonction asynchrone retourne une promesse, comme dans cet exemple :

```jsx
const doSomethingAsync = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve('J\'ai fait quelque chose'), 3000)
  })
}
```

Lorsque vous voulez **appeler** cette fonction, vous préfixez avec `await`, et **le code appelant s'arrêtera jusqu'à ce que la promesse soit résolue ou rejetée**. Un point important : la fonction cliente doit être définie comme `async`. Voici un exemple :

```
const doSomething = async () => {
  console.log(await doSomethingAsync())
}
```

#### Un exemple rapide

Voici un exemple simple d'utilisation de async/await pour exécuter une fonction de manière asynchrone :

```
const doSomethingAsync = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve('J\'ai fait quelque chose'), 3000)
  })
}

const doSomething = async () => {
  console.log(await doSomethingAsync())
}

console.log('Avant')
doSomething()
console.log('Après')
```

Le code ci-dessus imprimera ce qui suit dans la console du navigateur :

```
Avant
Après
J\'ai fait quelque chose // après 3s
```

#### Tout est promesse

Préfixer n'importe quelle fonction avec le mot-clé `async` signifie que la fonction retournera une promesse.

Même si elle ne le fait pas explicitement, elle le fera retourner une promesse en interne.

C'est pourquoi ce code est valide :

```
const aFunction = async () => {
  return 'test'
}

aFunction().then(alert) // Cela affichera 'test'
```

et c'est la même chose que :

```
const aFunction = async () => {
  return Promise.resolve('test')
}

aFunction().then(alert) // Cela affichera 'test'
```

#### Le code est beaucoup plus simple à lire

Comme vous pouvez le voir dans l'exemple ci-dessus, notre code semble très simple. Comparez-le au code utilisant des promesses simples, avec chaînage et fonctions de rappel.

Et ceci est un exemple très simple, les principaux avantages apparaîtront lorsque le code sera beaucoup plus complexe.

Par exemple, voici comment vous obtiendriez une ressource JSON et la parseriez, en utilisant des promesses :

```
const getFirstUserData = () => {
  return fetch('/users.json') // obtenir la liste des utilisateurs
    .then(response => response.json()) // parser le JSON
    .then(users => users[0]) // choisir le premier utilisateur
    .then(user => fetch(`/users/${user.name}`)) // obtenir les données de l'utilisateur
    .then(userResponse => userResponse.json()) // parser le JSON
}

getFirstUserData()
```

Et voici la même fonctionnalité fournie en utilisant await/async :

```
const getFirstUserData = async () => {
  const response = await fetch('/users.json') // obtenir la liste des utilisateurs
  const users = await response.json() // parser le JSON
  const user = users[0] // choisir le premier utilisateur
  const userResponse = await fetch(`/users/${user.name}`) // obtenir les données de l'utilisateur
  const userData = await userResponse.json() // parser le JSON
  return userData
}

getFirstUserData()
```

#### Plusieurs fonctions asynchrones en série

Les fonctions asynchrones peuvent être enchaînées très facilement, et la syntaxe est beaucoup plus lisible qu'avec des promesses simples :

```
const promiseToDoSomething = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve('J\'ai fait quelque chose'), 10000)
  })
}

const watchOverSomeoneDoingSomething = async () => {
  const something = await promiseToDoSomething()
  return something + ' et j\'ai regardé'
}

const watchOverSomeoneWatchingSomeoneDoingSomething = async () => {
  const something = await watchOverSomeoneDoingSomething()
  return something + ' et j\'ai regardé aussi'
}

watchOverSomeoneWatchingSomeoneDoingSomething().then(res => {
  console.log(res)
})
```

Cela imprimera :

```
J\'ai fait quelque chose et j\'ai regardé et j\'ai regardé aussi
```

#### Débogage plus facile

Le débogage des promesses est difficile car le débogueur ne passera pas sur le code asynchrone.

Async/await rend cela très facile car pour le compilateur, c'est comme du code synchrone.

### Modules ES

ES Modules est le standard ECMAScript pour travailler avec des modules.

Alors que Node.js a utilisé le standard CommonJS pendant des années, le navigateur n'a jamais eu de système de modules, car toute décision majeure telle qu'un système de modules doit d'abord être standardisée par ECMAScript puis implémentée par le navigateur.

Ce processus de standardisation s'est achevé avec ES6 et les navigateurs ont commencé à implémenter ce standard en essayant de garder tout bien aligné, en travaillant tous de la même manière, et maintenant les modules ES sont supportés dans Chrome, Safari, Edge et Firefox (depuis la version 60).

Les modules sont très intéressants, car ils vous permettent d'encapsuler toutes sortes de fonctionnalités, et d'exposer cette fonctionnalité à d'autres fichiers JavaScript, comme des bibliothèques.

#### La syntaxe des modules ES

La syntaxe pour importer un module est :

```
import package from 'module-name'
```

tandis que CommonJS utilise

```
const package = require('module-name')
```

Un module est un fichier JavaScript qui **exporte** une ou plusieurs valeurs (objets, fonctions ou variables), en utilisant le mot-clé `export`. Par exemple, ce module exporte une fonction qui retourne une chaîne en majuscules :

> _uppercase.js_

```
export default str => str.toUpperCase()
```

Dans cet exemple, le module définit une seule **exportation par défaut**, donc elle peut être une fonction anonyme. Sinon, elle aurait besoin d'un nom pour la distinguer des autres exportations.

Maintenant, **n'importe quel autre module JavaScript** peut importer la fonctionnalité offerte par uppercase.js en l'important.

Une page HTML peut ajouter un module en utilisant une balise `<script>` avec l'attribut spécial `type="module"` :

```
<script type="module" src="index.js"></script>
```

> _Note : cette importation de module se comporte comme un chargement de script `defer`. Voir [charger efficacement JavaScript avec defer et async](https://flaviocopes.com/javascript-async-defer/)_

Il est important de noter que tout script chargé avec `type="module"` est chargé en [mode strict](https://flaviocopes.com/javascript-strict-mode/).

Dans cet exemple, le module `uppercase.js` définit une **exportation par défaut**, donc lorsque nous l'importons, nous pouvons lui assigner un nom de notre choix :

```
import toUpperCase from './uppercase.js'
```

et nous pouvons l'utiliser :

```
toUpperCase('test') // 'TEST'
```

Vous pouvez également utiliser un chemin absolu pour l'importation du module, pour référencer des modules définis sur un autre domaine :

```
import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js'
```

Cette syntaxe d'importation est également valide :

```
import { foo } from '/uppercase.js'
import { foo } from '../uppercase.js'
```

Ceci ne l'est pas :

```
import { foo } from 'uppercase.js'
import { foo } from 'utils/uppercase.js'
```

C'est soit absolu, soit il a un `./` ou `/` avant le nom.

### Autres options d'import/export

Nous avons vu cet exemple ci-dessus :

```jsx
export default str => str.toUpperCase()
```

Cela crée une exportation par défaut. Dans un fichier, cependant, vous pouvez exporter plus d'une chose, en utilisant cette syntaxe :

```
const a = 1
const b = 2
const c = 3

export { a, b, c }
```

Un autre module peut importer toutes ces exportations en utilisant

```jsx
import * from 'module'
```

Vous pouvez importer seulement quelques-unes de ces exportations, en utilisant l'affectation par déstructuration :

```
import { a } from 'module'
import { a, b } from 'module'
```

Vous pouvez renommer n'importe quelle importation, pour plus de commodité, en utilisant `as` :

```
import { a, b as two } from 'module'
```

Vous pouvez importer l'exportation par défaut, et toute exportation non par défaut par nom, comme dans cette importation React courante :

```jsx
import React, { Component } from 'react'
```

Vous pouvez voir un exemple de modules ES ici : [https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html](https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html)

#### CORS

Les modules sont récupérés en utilisant [CORS](https://flaviocopes.com/cors/). Cela signifie que si vous référencez des scripts provenant d'autres domaines, ils doivent avoir un en-tête CORS valide qui permet le chargement inter-sites (comme `Access-Control-Allow-Origin: *`)

#### Que faire des navigateurs qui ne supportent pas les modules ?

Utilisez une combinaison de `type="module"` et `nomodule` :

```html
<script type="module" src="module.js"></script>
<script nomodule src="fallback.js"></script>
```

Les modules ES sont l'une des plus grandes fonctionnalités introduites dans les navigateurs modernes. Ils font partie d'ES6 mais le chemin pour les implémenter a été long.

Nous pouvons maintenant les utiliser ! Mais nous devons également nous rappeler que le fait d'avoir plus de quelques modules aura un impact sur les performances de nos pages, car c'est une étape supplémentaire que le navigateur doit effectuer à l'exécution.

Webpack va probablement rester un acteur majeur même si les modules ES arrivent dans le navigateur, mais avoir une telle fonctionnalité directement intégrée dans le langage est énorme pour une unification de la façon dont les modules fonctionnent côté client et sur Node.js également.

### SECTION 2 : CONCEPTS REACT

### Applications à page unique

Les applications React sont également appelées applications à page unique. Que signifie cela ?

Dans le passé, lorsque les navigateurs étaient beaucoup moins capables qu'aujourd'hui, et que les performances de JavaScript étaient médiocres, chaque page provenait d'un serveur. Chaque fois que vous cliquiez sur quelque chose, une nouvelle requête était faite au serveur et le navigateur chargeait ensuite la nouvelle page.

Seuls des produits très innovants fonctionnaient différemment, et expérimentaient de nouvelles approches.

Aujourd'hui, popularisées par les frameworks JavaScript frontend modernes comme React, une application est généralement construite comme une application à page unique : vous ne chargez le code de l'application (HTML, [CSS](https://flaviocopes.com/css/), [JavaScript](https://flaviocopes.com/javascript/)) qu'une seule fois, et lorsque vous interagissez avec l'application, ce qui se passe généralement, c'est que JavaScript intercepte les événements du navigateur et au lieu de faire une nouvelle requête au serveur qui retourne ensuite un nouveau document, le client demande un peu de JSON ou effectue une action sur le serveur, mais la page que l'utilisateur voit n'est jamais complètement effacée, et se comporte plus comme une application de bureau.

Les applications à page unique sont construites en JavaScript (ou au moins compilées en JavaScript) et fonctionnent dans le navigateur.

La technologie est toujours la même, mais la philosophie et certains composants clés du fonctionnement de l'application sont différents.

#### Exemples d'applications à page unique

Quelques exemples notables :

* Gmail
* Google Maps
* Facebook
* Twitter
* Google Drive

#### Avantages et inconvénients des SPAs

Une SPA semble beaucoup plus rapide pour l'utilisateur, car au lieu d'attendre que la communication client-serveur se produise, et d'attendre que le navigateur réaffiche la page, vous pouvez maintenant avoir un retour instantané. C'est la responsabilité du créateur de l'application, mais vous pouvez avoir des transitions et des indicateurs de chargement et toute sorte d'amélioration UX qui est certainement meilleure que le flux de travail traditionnel.

En plus de rendre l'expérience plus rapide pour l'utilisateur, le serveur consommera moins de ressources car vous pouvez vous concentrer sur la fourniture d'une API efficace au lieu de construire les mises en page côté serveur.

Cela en fait une solution idéale si vous construisez également une application mobile sur le dessus de l'API, car vous pouvez réutiliser complètement votre code côté serveur existant.

Les applications à page unique sont faciles à transformer en applications web progressives, ce qui vous permet à son tour de fournir une mise en cache locale et de supporter des expériences hors ligne pour vos services (ou simplement un meilleur message d'erreur si vos utilisateurs doivent être en ligne).

Les SPAs sont mieux utilisées lorsqu'il n'y a pas besoin de SEO (optimisation pour les moteurs de recherche). Par exemple pour les applications qui fonctionnent derrière une connexion.

Les moteurs de recherche, bien qu'ils s'améliorent chaque jour, ont encore du mal à indexer les sites construits avec une approche SPA plutôt que les pages traditionnelles rendues par le serveur. C'est le cas pour les blogs. Si vous allez vous appuyer sur les moteurs de recherche, ne vous donnez même pas la peine de créer une application à page unique sans avoir également une partie rendue par le serveur.

Lors du codage d'une SPA, vous allez écrire une grande quantité de JavaScript. Puisque l'application peut être de longue durée, vous allez devoir porter beaucoup plus d'attention aux éventuelles fuites de mémoire — si dans le passé votre page avait une durée de vie qui se comptait en minutes, maintenant une SPA peut rester ouverte pendant des heures et si il y a un problème de mémoire, cela va augmenter l'utilisation de la mémoire du navigateur de beaucoup plus et cela va causer une expérience désagréablement lente si vous n'en prenez pas soin.

Les SPAs sont excellentes pour travailler en équipe. Les développeurs backend peuvent se concentrer uniquement sur l'API, et les développeurs frontend peuvent se concentrer sur la création de la meilleure expérience utilisateur, en utilisant l'API construite en backend.

Comme inconvénient, les applications à page unique dépendent fortement de JavaScript. Cela peut rendre l'utilisation d'une application sur des appareils à faible puissance une mauvaise expérience en termes de vitesse. De plus, certains de vos visiteurs peuvent simplement avoir JavaScript désactivé, et vous devez également considérer l'accessibilité pour tout ce que vous construisez.

#### Remplacement de la navigation

Puisque vous vous débarrassez de la navigation par défaut du navigateur, les URLs doivent être gérées manuellement.

Cette partie d'une application est appelée le routeur. Certains frameworks s'en occupent déjà pour vous (comme Ember), d'autres nécessitent des bibliothèques qui feront ce travail (comme [React Router](https://flaviocopes.com/react-router/)).

Quel est le problème ? Au début, cela était une réflexion après coup pour les développeurs construisant des applications à page unique. Cela a causé le problème courant du "bouton retour cassé" : lors de la navigation dans l'application, l'URL ne changeait pas (puisque la navigation par défaut du navigateur était détournée) et en appuyant sur le bouton retour, une opération courante que les utilisateurs effectuent pour revenir à l'écran précédent, cela pouvait les amener à un site web que vous avez visité il y a longtemps.

Ce problème peut maintenant être résolu en utilisant l'[API History](https://flaviocopes.com/history-api/) offerte par les navigateurs, mais la plupart du temps vous utiliserez une bibliothèque qui utilise cette API en interne, comme **React Router**.

### Déclaratif

Que signifie-t-il lorsque vous lisez que React est déclaratif ? Vous tomberez sur des articles décrivant React comme une **approche déclarative pour construire des interfaces utilisateur**.

React a rendu son "approche déclarative" assez populaire et directe, de sorte qu'elle a imprégné le monde du frontend avec React.

Ce n'est vraiment pas un nouveau concept, mais React a rendu la construction d'interfaces utilisateur beaucoup plus déclarative qu'avec les modèles HTML :

* vous pouvez construire des interfaces Web sans même toucher directement le DOM
* vous pouvez avoir un système d'événements sans avoir à interagir avec les événements DOM réels.

L'opposé de déclaratif est **impératif**. Un exemple courant d'une approche impérative est la recherche d'éléments dans le DOM en utilisant jQuery ou les événements DOM. Vous dites au navigateur exactement quoi faire, au lieu de lui dire ce dont vous avez besoin.
L'approche déclarative de React abstrait cela pour nous. Nous disons simplement à React que nous voulons qu'un composant soit rendu d'une manière spécifique, et nous n'avons jamais à interagir avec le DOM pour le référencer plus tard.

### Immuabilité

Un concept que vous rencontrerez probablement lors de la programmation en React est l'immuabilité (et son opposé, la mutabilité).

C'est un sujet controversé, mais quelle que soit votre opinion sur le concept d'immuabilité, React et la plupart de son écosystème l'imposent, donc vous devez au moins comprendre pourquoi c'est si important et quelles sont ses implications.

En programmation, une variable est immuable lorsque sa valeur ne peut pas changer après sa création.

Vous utilisez déjà des variables immuables sans le savoir lorsque vous manipulez une chaîne de caractères. Les chaînes sont immuables par défaut : lorsque vous les modifiez, vous créez en réalité une nouvelle chaîne et l'assignez au même nom de variable.

Une variable immuable ne peut jamais être modifiée. Pour mettre à jour sa valeur, vous créez une nouvelle variable.

Cela s'applique également aux objets et aux tableaux.

Au lieu de modifier un tableau, pour ajouter un nouvel élément, vous créez un nouveau tableau en concaténant l'ancien tableau avec le nouvel élément.

Un objet n'est jamais mis à jour, mais copié avant d'être modifié.

Cela s'applique à React à de nombreux endroits.

Par exemple, vous ne devez jamais muter directement la propriété `state` d'un composant, mais uniquement via la méthode `setState()`.

Dans Redux, vous ne mutez jamais l'état directement, mais uniquement via des reducers, qui sont des fonctions.

La question est, pourquoi ?

Il y a plusieurs raisons, les plus importantes étant :

* Les mutations peuvent être centralisées, comme dans le cas de Redux, ce qui améliore vos capacités de débogage et réduit les sources d'erreurs.
* Le code est plus propre et plus simple à comprendre. Vous ne vous attendez jamais à ce qu'une fonction change une valeur sans que vous le sachiez, ce qui vous donne de la **prévisibilité**. Lorsqu'une fonction ne mute pas les objets mais retourne simplement un nouvel objet, elle est appelée une fonction pure.
* La bibliothèque peut optimiser le code car, par exemple, JavaScript est plus rapide lorsqu'il remplace une référence d'objet ancien par un tout nouvel objet, plutôt que de muter un objet existant. Cela vous donne des **performances**.

### Pureté

En JavaScript, lorsqu'une fonction ne mute pas les objets mais retourne simplement un nouvel objet, elle est appelée une fonction pure.

Une fonction, ou une méthode, pour être appelée _pure_ ne doit pas causer d'effets secondaires et doit retourner la même sortie lorsqu'elle est appelée plusieurs fois avec la même entrée.

Une fonction pure prend une entrée et retourne une sortie sans changer l'entrée ni quoi que ce soit d'autre.

Sa sortie est uniquement déterminée par les arguments. Vous pourriez appeler cette fonction 1 million de fois, et étant donné le même ensemble d'arguments, la sortie sera toujours la même.

React applique ce concept aux composants. Un composant React est un composant pur lorsque sa sortie dépend uniquement de ses props.

Tous les composants fonctionnels sont des composants purs :

```
const Button = props => {
  return <button>{props.message}</button>
}
```

Les composants de classe peuvent être purs si leur sortie dépend uniquement des props :

```
class Button extends React.Component {
  render() {
    return <button>{this.props.message}</button>
  }
}
```

### Composition

En programmation, la composition permet de construire des fonctionnalités plus complexes en combinant des fonctions petites et ciblées.

Par exemple, pensez à utiliser `map()` pour créer un nouveau tableau à partir d'un ensemble initial, puis à filtrer le résultat en utilisant `filter()` :

```
const list = ['Apple', 'Orange', 'Egg']
list.map(item => item[0]).filter(item => item === 'A') //'A'
```

Dans React, la composition permet d'avoir certains avantages assez intéressants.

Vous créez des composants petits et légers et les utilisez pour _composer_ plus de fonctionnalités par-dessus. Comment ?

#### Créer une version spécialisée d'un composant

Utilisez un composant externe pour étendre et spécialiser un composant plus générique :

```
const Button = props => {
  return <button>{props.text}</button>
}

const SubmitButton = () => {
  return <Button text="Submit" />
}

const LoginButton = () => {
  return <Button text="Login" />
}
```

#### Passer des méthodes en tant que props

Un composant peut se concentrer sur le suivi d'un événement de clic, par exemple, et ce qui se passe réellement lorsque l'événement de clic se produit est à la charge du composant conteneur :

```
const Button = props => {
  return <button onClick={props.onClickHandler}>{props.text}</button>
}

const LoginButton = props => {
  return <Button text="Login" onClickHandler={props.onClickHandler} />
}

const Container = () => {
  const onClickHandler = () => {
    alert('clicked')
  }
  
  return <LoginButton onClickHandler={onClickHandler} />
}
```

#### Utiliser children

La propriété `props.children` permet d'injecter des composants à l'intérieur d'autres composants.

Le composant doit sortir `props.children` dans son JSX :

```
const Sidebar = props => {
  return <aside>{props.children}</aside>
}
```

et vous y intégrez plus de composants de manière transparente :

```
<Sidebar>
  <Link title="First link" />
  <Link title="Second link" />
</Sidebar>
```

#### Composants d'ordre supérieur

Lorsqu'un composant reçoit un composant en tant que prop et retourne un composant, il est appelé composant d'ordre supérieur.

Nous les verrons dans un instant.

### Le Virtual DOM

De nombreux frameworks existants, avant l'arrivée de React, manipulaient directement le DOM à chaque changement.

Tout d'abord, qu'est-ce que le DOM ?

Le DOM (_Document Object Model_) est une représentation arborescente de la page, commençant par la balise `<html>`, descendant dans chaque enfant, appelés nœuds.

Il est conservé dans la mémoire du navigateur et directement lié à ce que vous voyez dans une page. Le DOM dispose d'une API que vous pouvez utiliser pour le parcourir, accéder à chaque nœud, les filtrer, les modifier.

L'API est la syntaxe familière que vous avez probablement vue de nombreuses fois, si vous n'utilisiez pas l'API abstraite fournie par jQuery et ses amis :

```
document.getElementById(id)
document.getElementsByTagName(name)
document.createElement(name)
parentNode.appendChild(node)
element.innerHTML
element.style.left
element.setAttribute()
element.getAttribute()
element.addEventListener()
window.content
window.onload
window.dump()
window.scrollTo()
```

React conserve une copie de la représentation du DOM, pour ce qui concerne le rendu React : le Virtual DOM.

#### Le Virtual DOM expliqué

Chaque fois que le DOM change, le navigateur doit effectuer deux opérations intensives : le repaint (changements visuels ou de contenu d'un élément qui n'affectent pas la mise en page et le positionnement par rapport aux autres éléments) et le reflow (recalculer la mise en page d'une partie de la page — ou la mise en page complète de la page).

React utilise un Virtual DOM pour aider le navigateur à utiliser moins de ressources lorsque des changements doivent être effectués sur une page.

Lorsque vous appelez `setState()` sur un composant, en spécifiant un état différent de celui précédent, React marque ce composant comme **dirty**. C'est la clé : React ne met à jour que lorsqu'un composant change explicitement l'état.

Ce qui se passe ensuite est :

* React met à jour le Virtual DOM relatif aux composants marqués comme dirty (avec quelques vérifications supplémentaires, comme le déclenchement de `shouldComponentUpdate()`)
* Exécute l'algorithme de différenciation pour réconcilier les changements
* Met à jour le vrai DOM

#### Pourquoi le Virtual DOM est-il utile : le batching

L'élément clé est que React regroupe une grande partie des changements et effectue une mise à jour unique du vrai DOM, en modifiant tous les éléments qui doivent être changés en même temps, de sorte que le repaint et le reflow que le navigateur doit effectuer pour rendre les changements sont exécutés une seule fois.

### Flux de données unidirectionnel

En travaillant avec React, vous pourriez rencontrer le terme Flux de données unidirectionnel. Que signifie-t-il ? Le flux de données unidirectionnel n'est pas un concept unique à React, mais en tant que développeur JavaScript, cela pourrait être la première fois que vous en entendez parler.

En général, ce concept signifie que les données ont un, et un seul, moyen d'être transférées à d'autres parties de l'application.

Dans React, cela signifie que :

* l'état est passé à la vue et aux composants enfants
* les actions sont déclenchées par la vue
* les actions peuvent mettre à jour l'état
* le changement d'état est passé à la vue et aux composants enfants

La vue est un résultat de l'état de l'application. L'état ne peut changer que lorsque des actions se produisent. Lorsque des actions se produisent, l'état est mis à jour.

Grâce aux liaisons unidirectionnelles, les données ne peuvent pas circuler dans le sens inverse (comme cela se produirait avec des liaisons bidirectionnelles, par exemple), et cela présente certains avantages clés :

* c'est moins sujet aux erreurs, car vous avez plus de contrôle sur vos données
* c'est plus facile à déboguer, car vous savez _ce qui_ provient de _où_
* c'est plus efficace, car la bibliothèque connaît déjà les limites de chaque partie du système

Un état est toujours possédé par un composant. Toute donnée affectée par cet état ne peut affecter que les composants en dessous : ses enfants.

Changer l'état d'un composant n'affectera jamais son parent, ou ses frères et sœurs, ou tout autre composant dans l'application : seulement ses enfants.

C'est la raison pour laquelle l'état est souvent remonté dans l'arborescence des composants, afin qu'il puisse être partagé entre les composants qui doivent y accéder.

### SECTION 3 : REACT EN PROFONDEUR

### JSX

JSX est une technologie qui a été introduite par React.

Bien que React puisse fonctionner parfaitement sans utiliser JSX, c'est une technologie idéale pour travailler avec des composants, donc React bénéficie beaucoup de JSX.

Au début, vous pourriez penser que l'utilisation de JSX est comme mélanger HTML et [JavaScript](https://flaviocopes.com/javascript/) (et comme vous le verrez, CSS).

Mais ce n'est pas vrai, car ce que vous faites vraiment lorsque vous utilisez la syntaxe JSX est d'écrire une syntaxe déclarative de ce que l'interface utilisateur d'un composant devrait être.

Et vous décrivez cette interface utilisateur non pas en utilisant des chaînes de caractères, mais en utilisant JavaScript, ce qui vous permet de faire beaucoup de choses intéressantes.

#### Un guide JSX

Voici comment vous définissez une balise h1 contenant une chaîne :

```jsx
const element = <h1>Hello, world!</h1>
```

Cela ressemble à un étrange mélange de JavaScript et HTML, mais en réalité, c'est tout du JavaScript.

Ce qui ressemble à du HTML est en fait du sucre syntaxique pour définir des composants et leur positionnement dans le balisage.

Dans une expression JSX, les attributs peuvent être insérés très facilement :

```
const myId = 'test'
const element = <h1 id={myId}>Hello, world!</h1>
```

Vous devez simplement faire attention lorsqu'un attribut contient un tiret (`-`) qui est converti en syntaxe camelCase, et ces 2 cas spéciaux :

* `class` devient `className`
* `for` devient `htmlFor`

car ce sont des mots réservés en JavaScript.

Voici un extrait JSX qui enveloppe deux composants dans une balise `div` :

```
<div>
  <BlogPostsList />
  <Sidebar />
</div>
```

Une balise doit toujours être fermée, car cela ressemble plus à du XML qu'à du HTML (si vous vous souvenez des jours de XHTML, cela sera familier, mais depuis, la syntaxe lâche de HTML5 a gagné). Dans ce cas, une balise auto-fermante est utilisée.

Remarquez comment j'ai enveloppé les 2 composants dans un `div`. Pourquoi ? Parce que **la fonction render() ne peut retourner qu'un seul nœud**, donc si vous voulez retourner 2 frères, ajoutez simplement un parent. Cela peut être n'importe quelle balise, pas seulement `div`.

#### Transpilation de JSX

Un navigateur ne peut pas exécuter des fichiers JavaScript contenant du code JSX. Ils doivent d'abord être transformés en JS régulier.

Comment ? En effectuant un processus appelé **transpilation**.

Nous avons déjà dit que JSX est optionnel, car pour chaque ligne JSX, une alternative JavaScript simple correspondante est disponible, et c'est ce vers quoi JSX est transpilé.

Par exemple, les deux constructions suivantes sont équivalentes :

> _JS simple_

```
ReactDOM.render(
  React.DOM.div(
    { id: 'test' },
    React.DOM.h1(null, 'A title'),
    React.DOM.p(null, 'A paragraph')
  ),
  document.getElementById('myapp')
)
```

> _JSX_

```
ReactDOM.render(
  <div id="test">
    <h1>A title</h1>
    <p>A paragraph</p>
  </div>,
  document.getElementById('myapp')
)
```

Cet exemple très basique n'est que le point de départ, mais vous pouvez déjà voir à quel point la syntaxe JS simple est plus compliquée par rapport à l'utilisation de JSX.

Au moment de l'écriture, la manière la plus populaire d'effectuer la **transpilation** est d'utiliser **Babel**, qui est l'option par défaut lors de l'exécution de `create-react-app`, donc si vous l'utilisez, vous n'avez pas à vous en soucier, tout se passe en arrière-plan pour vous.

Si vous n'utilisez pas `create-react-app`, vous devez configurer Babel vous-même.

#### JS dans JSX

JSX accepte tout type de JavaScript mélangé à celui-ci.

Chaque fois que vous devez ajouter du JS, il suffit de le mettre à l'intérieur d'accolades `{}`. Par exemple, voici comment utiliser une valeur constante définie ailleurs :

```
const paragraph = 'A paragraph'
ReactDOM.render(
  <div id="test">
    <h1>A title</h1>
    <p>{paragraph}</p>
  </div>,
  document.getElementById('myapp')
)
```

C'est un exemple basique. Les accolades acceptent _n'importe quel_ code JS :

```
const paragraph = 'A paragraph'
ReactDOM.render(
  <table>
    {rows.map((row, i) => {
      return <tr>{row.text}</tr>
    })}
  </table>,
  document.getElementById('myapp')
)
```

Comme vous pouvez le voir, _nous avons imbriqué JavaScript dans JSX défini dans JavaScript imbriqué dans JSX_. Vous pouvez aller aussi loin que nécessaire.

#### HTML dans JSX

JSX ressemble beaucoup à HTML, mais il s'agit en réalité de syntaxe XML.

À la fin, vous rendez du HTML, donc vous devez connaître quelques différences entre la manière dont vous définissez certaines choses en HTML et la manière dont vous les définissez en JSX.

#### Vous devez fermer toutes les balises

Tout comme en XHTML, si vous l'avez déjà utilisé, vous devez fermer toutes les balises : plus de `<br>` mais utilisez plutôt la balise auto-fermante : `<br />` (il en va de même pour les autres balises).

#### camelCase est la nouvelle norme

En HTML, vous trouverez des attributs sans aucune casse (par exemple, `onchange`). En JSX, ils sont renommés en leur équivalent camelCase :

* `onchange` => `onChange`
* `onclick` => `onClick`
* `onsubmit` => `onSubmit`

#### `class` devient `className`

En raison du fait que JSX est JavaScript, et que `class` est un mot réservé, vous ne pouvez pas écrire

```
<p class="description">
```

mais vous devez utiliser

```
<p className="description">
```

**Il en va de même pour `for`** qui est traduit par `htmlFor`.

#### CSS dans React

JSX offre un moyen intéressant de définir CSS.

Si vous avez un peu d'expérience avec les styles en ligne HTML, à première vue, vous vous retrouverez propulsé 10 ou 15 ans en arrière, dans un monde où le CSS en ligne était complètement normal (de nos jours, il est démonisé et généralement juste une solution de "dépannage rapide").

Le style JSX n'est pas la même chose : tout d'abord, au lieu d'accepter une chaîne contenant des propriétés CSS, l'attribut `style` de JSX n'accepte qu'un objet. Cela signifie que vous définissez des propriétés dans un objet :

```
var divStyle = {
  color: 'white'
}

ReactDOM.render(<div style={divStyle}>Hello World!</div>, mountNode)
```

ou

```
ReactDOM.render(<div style={{ color: 'white' }}>Hello World!</div>, mountNode)
```

Les valeurs CSS que vous écrivez en JSX sont légèrement différentes du CSS simple :

* les noms des propriétés clés sont en camelCase
* les valeurs sont simplement des chaînes
* vous séparez chaque tuple avec une virgule

#### Pourquoi est-ce préféré au CSS simple / SASS / LESS ?

CSS est un **problème non résolu**. Depuis sa création, des dizaines d'outils autour de lui sont apparus puis ont disparu. Le principal problème avec JS est qu'il n'y a pas de portée et qu'il est facile d'écrire du CSS qui n'est pas appliqué de quelque manière que ce soit, ainsi un "dépannage rapide" peut impacter des éléments qui ne devraient pas être touchés.

JSX permet aux composants (définis dans React par exemple) d'encapsuler complètement leur style.

#### Est-ce la solution idéale ?

Les styles en ligne dans JSX sont bons jusqu'à ce que vous ayez besoin de

1. écrire des requêtes média
2. styliser des animations
3. référencer des pseudo-classes (par exemple, `:hover`)
4. référencer des pseudo-éléments (par exemple, `::first-letter`)

En bref, ils couvrent les bases, mais ce n'est pas la solution finale.

#### Formulaires dans JSX

JSX apporte quelques changements à la manière dont les formulaires HTML fonctionnent, avec pour objectif de faciliter les choses pour le développeur.

#### `value` et `defaultValue`

L'attribut `value` contient toujours la valeur actuelle du champ.

L'attribut `defaultValue` contient la valeur par défaut qui a été définie lors de la création du champ.

_Cela aide à résoudre certains comportements étranges de l'interaction [DOM](https://flaviocopes.com/dom/) régulière lorsque l'inspection de `input.value` et `input.getAttribute('value')` retourne l'une la valeur actuelle et l'autre la valeur par défaut originale._

Cela s'applique également au champ `textarea`, par exemple

```
<textarea>Some text</textarea>
```

mais au lieu de cela

```
<textarea defaultValue={'Some text'} />
```

Pour les champs `select`, au lieu d'utiliser

```
<select>
  <option value="x" selected>
    ...
  </option>
</select>
```

utilisez

```jsx
<select defaultValue="x">
  <option value="x">...</option>
</select>
```

#### Un onChange plus cohérent

En passant une fonction à l'attribut `onChange`, vous pouvez vous abonner aux événements sur les champs de formulaire.

Il fonctionne de manière cohérente sur les champs, même les champs d'entrée `radio`, `select` et `checkbox` déclenchent un événement `onChange`.

`onChange` se déclenche également lors de la frappe d'un caractère dans un champ `input` ou `textarea`.

#### JSX auto escape

Pour atténuer le risque toujours présent d'exploits XSS, JSX force l'échappement automatique dans les expressions.

Cela signifie que vous pourriez rencontrer des problèmes lors de l'utilisation d'une entité HTML dans une expression de chaîne.

Vous vous attendez à ce que ce qui suit imprime `
9 2017` :

```jsx
<p>{'\u00a9 2017'}</p>
```

Mais ce n'est pas le cas, il imprime `
9 2017` parce que la chaîne est échappée.

Pour corriger cela, vous pouvez soit déplacer les entités hors de l'expression :

```
<p>
9 2017</p>
```

soit en utilisant une constante qui imprime la représentation Unicode correspondant à l'entité HTML que vous devez imprimer :

```
<p>{'\u00A9 2017'}</p>
```

#### Espaces blancs dans JSX

Pour ajouter des espaces blancs dans JSX, il y a 2 règles :

**Règle 1 : Les espaces horizontaux sont réduits à 1**

Si vous avez des espaces blancs entre des éléments sur la même ligne, ils sont tous réduits à 1 espace blanc.

```
<p>Something       becomes               this</p>
```

devient

```
<p>Something becomes this</p>
```

**Règle 2 : Les espaces verticaux sont éliminés**

```
<p>
  Something
  becomes
  this
</p>
```

devient

```
<p>Somethingbecomesthis</p>
```

Pour corriger ce problème, vous devez ajouter explicitement des espaces blancs, en ajoutant une expression d'espace comme ceci :

```
<p>
  Something
  {' '}becomes
  {' '}this
</p>
```

ou en intégrant la chaîne dans une expression d'espace :

```
<p>
  Something
  {' becomes '}
  this
</p>
```

#### Ajouter des commentaires dans JSX

Vous pouvez ajouter des commentaires à JSX en utilisant les commentaires JavaScript normaux à l'intérieur d'une expression :

```
<p>
  {/* a comment */}
  {
    //another comment
  }
</p>
```

#### Attributs de propagation

Dans JSX, une opération courante consiste à assigner des valeurs aux attributs.

Au lieu de le faire manuellement, par exemple

```
<div>
  <BlogPost title={data.title} date={data.date} />
</div>
```

vous pouvez passer

```
<div>
  <BlogPost {...data} />
</div>
```

et les propriétés de l'objet `data` seront utilisées comme attributs automatiquement, grâce à l'_opérateur de propagation ES6_.

#### Comment boucler dans JSX

Si vous avez un ensemble d'éléments sur lesquels vous devez boucler pour générer un partial JSX, vous pouvez créer une boucle, puis ajouter JSX à un tableau :

```
const elements = [] //..some array

const items = []

for (const [index, value] of elements.entries()) {
  items.push(<Element key={index} />)
}
```

Maintenant, lors du rendu du JSX, vous pouvez intégrer le tableau `items` simplement en l'enveloppant dans des accolades :

```
const elements = ['one', 'two', 'three'];

const items = []

for (const [index, value] of elements.entries()) {
  items.push(<li key={index}>{value}</li>)
}

return (
  <div>
    {items}
  </div>
)
```

Vous pouvez faire la même chose directement dans le JSX, en utilisant `map` au lieu d'une boucle for-of :

```
const elements = ['one', 'two', 'three'];
return (
  <ul>
    {elements.map((value, index) => {
      return <li key={index}>{value}</li>
    })}
  </ul>
)
```

### Composants
Un composant est une pièce isolée d'interface. Par exemple, sur une page d'accueil de blog typique, vous pourriez trouver le composant Barre latérale et le composant Liste des articles de blog. Ils sont à leur tour composés de composants eux-mêmes, donc vous pourriez avoir une liste de composants d'articles de blog, chacun pour chaque article de blog, et chacun avec ses propres propriétés.

React simplifie beaucoup les choses : tout est un composant.

Même les balises HTML simples sont des composants à part entière, et elles sont ajoutées par défaut.

Les deux lignes suivantes sont équivalentes, elles font la même chose. L'une avec **JSX**, l'autre sans, en injectant `<h1>Hello World!</h1>` dans un élément avec l'id `app`.

```
import React from 'react'
import ReactDOM from 'react-dom'

ReactDOM.render(<h1>Hello World!</h1>, document.getElementById('app'))

ReactDOM.render(
  React.DOM.h1(null, 'Hello World!'),
  document.getElementById('app')
)
```

Vous voyez, `React.DOM` nous expose un composant `h1`. Quelles autres balises HTML sont disponibles ? Toutes ! Vous pouvez inspecter ce que `React.DOM` offre en le tapant dans la console du navigateur :

(la liste est plus longue)

Les composants intégrés sont bien, mais vous les dépasserez rapidement. Ce que React excelle, c'est de nous permettre de composer une interface utilisateur en composant des composants personnalisés.

#### Composants personnalisés

Il existe 2 façons de définir un composant dans React.

Un composant fonctionnel :

```
const BlogPostExcerpt = () => {
  return (
    <div>
      <h1>Titre</h1>
      <p>Description</p>
    </div>
  )
}
```

Un composant de classe :

```
import React, { Component } from 'react'

class BlogPostExcerpt extends Component {
  render() {
    return (
      <div>
        <h1>Titre</h1>
        <p>Description</p>
      </div>
    )
  }
}
```

Jusqu'à récemment, les composants de classe étaient le seul moyen de définir un composant ayant son propre état et pouvant accéder aux méthodes de cycle de vie afin de pouvoir faire des choses lorsque le composant était rendu pour la première fois, mis à jour ou supprimé.

Les hooks React ont changé cela, donc nos composants fonctionnels sont désormais beaucoup plus puissants que jamais et je crois que nous verrons de moins en moins de composants de classe à l'avenir, bien que ce soit toujours une manière parfaitement valide de créer des composants.

Il existe également une troisième syntaxe qui utilise la syntaxe `ES5`, sans les classes :

```
import React from 'react'

React.createClass({
  render() {
    return (
      <div>
        <h1>Titre</h1>
        <p>Description</p>
      </div>
    )
  }
})
```

Vous verrez rarement cela dans les bases de code modernes, `> ES6`.

### État

#### Définir l'état par défaut d'un composant

Dans le constructeur du composant, initialisez `this.state`. Par exemple, le composant BlogPostExcerpt pourrait avoir un état `clicked` :

```
class BlogPostExcerpt extends Component {
  constructor(props) {
    super(props)
    this.state = { clicked: false }
  }
  
  render() {
    return (
      <div>
        <h1>Titre</h1>
        <p>Description</p>
      </div>
    )
  }
}
```

#### Accéder à l'état

L'état _clicked_ peut être accédé en référençant `this.state.clicked` :

```
class BlogPostExcerpt extends Component {
  constructor(props) {
    super(props)
    this.state = { clicked: false }
  }
  
  render() {
    return (
      <div>
        <h1>Titre</h1>
        <p>Description</p>
        <p>Cliqué : {this.state.clicked}</p>
      </div>
    )
  }
}
```

#### Mutating the state

Un état ne doit jamais être muté en utilisant

```
this.state.clicked = true
```

Au lieu de cela, vous devez toujours utiliser `setState()`, en lui passant un objet :

```
this.setState({ clicked: true })
```

L'objet peut contenir un sous-ensemble ou un sur-ensemble de l'état. Seules les propriétés que vous passez seront mutées, celles omises resteront dans leur état actuel.

#### Pourquoi vous devriez toujours utiliser `setState()`

La raison est qu'en utilisant cette méthode, React sait que l'état a changé. Il déclenchera alors la série d'événements qui mèneront à la ré-exécution du composant, ainsi qu'à toute mise à jour du [DOM](https://flaviocopes.com/dom/).

#### Flux de données unidirectionnel

Un état appartient toujours à un seul composant. Toute donnée affectée par cet état ne peut affecter que les composants en dessous : ses enfants.

Changer l'état d'un composant n'affectera jamais son parent, ses frères et sœurs, ou tout autre composant dans l'application : seulement ses enfants.

C'est la raison pour laquelle l'état est souvent remonté dans l'arborescence des composants.

#### Remonter l'état dans l'arborescence

En raison de la règle du flux de données unidirectionnel, si deux composants doivent partager un état, l'état doit être remonté à un ancêtre commun.

De nombreuses fois, l'ancêtre le plus proche est le meilleur endroit pour gérer l'état, mais ce n'est pas une règle obligatoire.

L'état est passé aux composants qui en ont besoin via les props :

```
class Converter extends React.Component {
  constructor(props) {
    super(props)
    this.state = { currency: '€' }
  }
  
  render() {
    return (
      <div>
        <Display currency={this.state.currency} />
        <CurrencySwitcher currency={this.state.currency} />
      </div>
    )
  }
}
```

L'état peut être muté par un composant enfant en passant une fonction de mutation en tant que prop :

```
class Converter extends React.Component {
  constructor(props) {
    super(props)
    this.state = { currency: '€' }
  }
  
  handleChangeCurrency = event => {
    this.setState({ currency: this.state.currency === '€' ? '$' : '€' })
  }
  
  render() {
    return (
      <div>
        <Display currency={this.state.currency} />
        <CurrencySwitcher
          currency={this.state.currency}
          handleChangeCurrency={this.handleChangeCurrency}
        />
      </div>
    )
  }
}

const CurrencySwitcher = props => {
  return (
    <button onClick={props.handleChangeCurrency}>
      La devise actuelle est {props.currency}. Changez-la !
    </button>
  )
}

const Display = props => {
  return <p>La devise actuelle est {props.currency}.</p>
}
```

### Props

Les props sont la manière dont les composants obtiennent leurs propriétés. À partir du composant parent, chaque composant enfant reçoit ses props du parent. Dans un composant fonctionnel, les props sont tout ce qui est passé, et elles sont disponibles en ajoutant `props` comme argument de la fonction :

```
const BlogPostExcerpt = props => {
  return (
    <div>
      <h1>{props.title}</h1>
      <p>{props.description}</p>
    </div>
  )
}
```

Dans un composant de classe, les props sont passées par défaut. Il n'est pas nécessaire d'ajouter quoi que ce soit de spécial, et elles sont accessibles en tant que `this.props` dans une instance de composant.

```
import React, { Component } from 'react'

class BlogPostExcerpt extends Component {
  render() {
    return (
      <div>
        <h1>{this.props.title}</h1>
        <p>{this.props.description}</p>
      </div>
    )
  }
}
```

Passer des props aux composants enfants est un excellent moyen de transmettre des valeurs dans votre application. Un composant détient soit des données (a un état), soit reçoit des données via ses props.

Cela devient compliqué lorsque :

* vous devez accéder à l'état d'un composant depuis un enfant qui se trouve plusieurs niveaux plus bas (tous les enfants précédents doivent agir comme un relais, même s'ils n'ont pas besoin de connaître l'état, ce qui complique les choses)
* vous devez accéder à l'état d'un composant depuis un composant complètement sans relation.

#### Valeurs par défaut pour les props

Si une valeur n'est pas requise, nous devons spécifier une valeur par défaut si elle est manquante lorsque le composant est initialisé.

```
BlogPostExcerpt.propTypes = {
  title: PropTypes.string,
  description: PropTypes.string
}

BlogPostExcerpt.defaultProps = {
  title: '',
  description: ''
}
```

Certains outils comme [ESLint](https://flaviocopes.com/eslint/) ont la capacité d'imposer la définition des defaultProps pour un composant avec certains propTypes non explicitement requis.

#### Comment les props sont passées

Lors de l'initialisation d'un composant, passez les props de manière similaire aux attributs HTML :

```
const desc = 'Une description'
//...
<BlogPostExcerpt title="Un article de blog" description={desc} />
```

Nous avons passé le titre en tant que chaîne simple (quelque chose que nous pouvons faire _uniquement_ avec des chaînes !), et la description en tant que variable.

#### Enfants

Une prop spéciale est `children`. Elle contient la valeur de tout ce qui est passé dans le `body` du composant, par exemple :

```
<BlogPostExcerpt title="Un article de blog" description="{desc}">
  Quelque chose
</BlogPostExcerpt>
```

Dans ce cas, à l'intérieur de `BlogPostExcerpt`, nous pourrions accéder à "Quelque chose" en regardant `this.props.children`.

Alors que les props permettent à un composant de recevoir des propriétés de son parent, pour être "instruits" d'imprimer certaines données par exemple, l'état permet à un composant de prendre vie lui-même et d'être indépendant de l'environnement environnant.

### Composants de présentation vs composants conteneurs

Dans React, les composants sont souvent divisés en deux grandes catégories : **composants de présentation** et **composants conteneurs**.

Chacun de ceux-ci a ses propres caractéristiques uniques.

Les composants de présentation sont principalement préoccupés par la génération de balises à afficher.

Ils ne gèrent aucun type d'état, sauf pour l'état lié à la présentation.

Les composants conteneurs sont principalement préoccupés par les opérations "backend".

Ils peuvent gérer l'état de divers sous-composants. Ils peuvent envelopper plusieurs composants de présentation. Ils peuvent interagir avec Redux.

Pour simplifier la distinction, nous pouvons dire que **les composants de présentation sont préoccupés par l'apparence**, **les composants conteneurs sont préoccupés par le fonctionnement des choses**.

Par exemple, ceci est un composant de présentation. Il obtient des données de ses props et se concentre simplement sur l'affichage d'un élément :

```
const Users = props => (
  <ul>
    {props.users.map(user => (
      <li>{user}</li>
    ))}
  </ul>
)
```

D'autre part, ceci est un composant conteneur. Il gère et stocke ses propres données, et utilise le composant de présentation pour les afficher.

```
class UsersContainer extends React.Component {
  constructor() {
    this.state = {
      users: []
    }
  }
  
  componentDidMount() {
    axios.get('/users').then(users =>
      this.setState({ users: users }))
    )
  }
  
  render() {
    return <Users users={this.state.users} />
  }
}
```

### État vs props

Dans un composant React, **props** sont des variables qui lui sont passées par son composant parent. **State**, en revanche, est toujours des variables, mais directement initialisées et gérées par le composant.

L'état peut être initialisé par les props.

Par exemple, un composant parent peut inclure un composant enfant en appelant

```
<ChildComponent />
```

Le parent peut passer une prop en utilisant cette syntaxe :

```
<ChildComponent color=green />
```

À l'intérieur du constructeur ChildComponent, nous pourrions accéder à la prop :

```
class ChildComponent extends React.Component {
  constructor(props) {
    super(props)
    console.log(props.color)
  }
}
```

et toute autre méthode dans cette classe peut référencer les props en utilisant `this.props`.

Les props peuvent être utilisées pour définir l'état interne basé sur une valeur de prop dans le constructeur, comme ceci :

```
class ChildComponent extends React.Component {
  constructor(props) {
    super(props)
    this.state.colorName = props.color
  }
}
```

Bien sûr, un composant peut également initialiser l'état sans regarder les props.

Dans ce cas, il ne se passe rien d'utile, mais imaginez faire quelque chose de différent basé sur la valeur de la prop, probablement définir une valeur d'état est la meilleure solution.

Les props ne doivent jamais être modifiées dans un composant enfant, donc si quelque chose se passe qui modifie une variable, cette variable doit appartenir à l'état du composant.

Les props sont également utilisées pour permettre aux composants enfants d'accéder aux méthodes définies dans le composant parent. C'est un bon moyen de centraliser la gestion de l'état dans le composant parent, et d'éviter que les enfants aient besoin d'avoir leur propre état.

La plupart de vos composants afficheront simplement un type d'information basé sur les props qu'ils ont reçues, et resteront **sans état**.

### PropTypes

Puisque JavaScript est un langage à typage dynamique, nous n'avons pas vraiment de moyen de forcer le type d'une variable au moment de la compilation, et si nous passons des types invalides, ils échoueront à l'exécution ou donneront des résultats étranges si les types sont compatibles mais pas ceux que nous attendons.

Flow et TypeScript aident beaucoup, mais React a un moyen d'aider directement avec les types de props, et même avant d'exécuter le code, nos outils (éditeurs, linters) peuvent détecter lorsque nous passons de mauvaises valeurs :

```
import PropTypes from 'prop-types'
import React from 'react'

class BlogPostExcerpt extends Component {
  render() {
    return (
      <div>
        <h1>{this.props.title}</h1>
        <p>{this.props.description}</p>
      </div>
    )
  }
}

BlogPostExcerpt.propTypes = {
  title: PropTypes.string,
  description: PropTypes.string
}

export default BlogPostExcerpt
```

#### Quels types pouvons-nous utiliser

Ce sont les types fondamentaux que nous pouvons accepter :

* PropTypes.array
* PropTypes.bool
* PropTypes.func
* PropTypes.number
* PropTypes.object
* PropTypes.string
* PropTypes.symbol

Nous pouvons accepter l'un des deux types :

```
PropTypes.oneOfType([
  PropTypes.string,
  PropTypes.number
]),
```

Nous pouvons accepter l'une des nombreuses valeurs :

```
PropTypes.oneOf(['Test1', 'Test2']),
```

Nous pouvons accepter une instance d'une classe :

```
PropTypes.instanceOf(Something)
```

Nous pouvons accepter n'importe quel nœud React :

```
PropTypes.node
```

ou même n'importe quel type du tout :

```
PropTypes.any
```

Les tableaux ont une syntaxe spéciale que nous pouvons utiliser pour accepter un tableau d'un type particulier :

```jsx
PropTypes.arrayOf(PropTypes.string)
```

Nous pouvons composer les propriétés d'objet en utilisant

```
PropTypes.shape({
  color: PropTypes.string,
  fontSize: PropTypes.number
})
```

#### Exiger des propriétés

Ajouter `isRequired` à n'importe quelle option PropTypes fera en sorte que React retourne une erreur si cette propriété est manquante :

```
PropTypes.arrayOf(PropTypes.string).isRequired,
PropTypes.string.isRequired,
```

### React Fragment

Remarquez comment j'enveloppe les valeurs de retour dans une `div`. C'est parce qu'un composant ne peut retourner qu'un seul élément, et si vous voulez plus d'un, vous devez l'envelopper avec une autre balise conteneur.

Cela, cependant, provoque une `div` inutile dans la sortie. Vous pouvez éviter cela en utilisant `React.Fragment` :

```
import React, { Component } from 'react'

class BlogPostExcerpt extends Component {
  render() {
    return (
      <React.Fragment>
        <h1>{this.props.title}</h1>
        <p>{this.props.description}</p>
      </React.Fragment>
    )
  }
}
```

qui a également une syntaxe abrégée très pratique `<></>` qui est prise en charge uniquement dans les versions récentes (et Babel 7+) :

```
import React, { Component } from 'react'

class BlogPostExcerpt extends Component {
  render() {
    return (
      <>
        <h1>{this.props.title}</h1>
        <p>{this.props.description}</p>
      </>
    )
  }
}
```

### Événements

React fournit un moyen facile de gérer les événements. Préparez-vous à dire adieu à `addEventListener`.

Dans l'article précédent sur l'État, vous avez vu cet exemple :

```
const CurrencySwitcher = props => {
  return (
    <button onClick={props.handleChangeCurrency}>
      La devise actuelle est {props.currency}. Changez-la !
    </button>
  )
}
```

Si vous avez utilisé JavaScript pendant un certain temps, cela ressemble aux anciens gestionnaires d'événements [JavaScript](https://flaviocopes.com/javascript-events/), sauf que cette fois vous définissez tout en JavaScript, pas dans votre HTML, et vous passez une fonction, pas une chaîne.

Les noms d'événements réels sont un peu différents car dans React vous utilisez camelCase pour tout, donc `onclick` devient `onClick`, `onsubmit` devient `onSubmit`.

Pour référence, voici l'ancien HTML avec des événements JavaScript mélangés :

```
<button onclick="handleChangeCurrency()">...<;/button>
```

#### Gestionnaires d'événements

C'est une convention d'avoir des gestionnaires d'événements définis comme méthodes sur la classe de composant :

```
class Converter extends React.Component {
  handleChangeCurrency = event => {
    this.setState({ currency: this.state.currency === '€' ? '$' : '€' })
  }
}
```

Tous les gestionnaires reçoivent un objet événement qui respecte, multi-navigateur, la spécification [W3C UI Events spec](https://www.w3.org/TR/DOM-Level-3-Events/).

#### Lier `this` dans les méthodes

Si vous utilisez des composants de classe, n'oubliez pas de lier les méthodes. Les méthodes des classes ES6 par défaut ne sont pas liées. Cela signifie que `this` n'est pas défini sauf si vous définissez les méthodes comme des fonctions fléchées :

```
class Converter extends React.Component {
  handleClick = e => {
    /* ... */
  }
  //...
}
```

lors de l'utilisation de la syntaxe d'initialisation de propriété avec Babel (activée par défaut dans `create-react-app`), sinon vous devez la lier manuellement dans le constructeur :

```
class Converter extends React.Component {
  constructor(props) {
    super(props)
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick(e) {}
}
```

### Référence des événements

Il existe de nombreux événements pris en charge, voici une liste de résumé.

#### Presse-papiers

* onCopy
* onCut
* onPaste

#### Composition

* onCompositionEnd
* onCompositionStart
* onCompositionUpdate

#### Clavier

* onKeyDown
* onKeyPress
* onKeyUp

#### Focus

* onFocus
* onBlur

#### Formulaire

* onChange
* onInput
* onSubmit

#### Souris

* onClick
* onContextMenu
* onDoubleClick
* onDrag
* onDragEnd
* onDragEnter
* onDragExit
* onDragLeave
* onDragOver
* onDragStart
* onDrop
* onMouseDown
* onMouseEnter
* onMouseLeave
* onMouseMove
* onMouseOut
* onMouseOver
* onMouseUp

#### Sélection

* onSelect

#### Tactile

* onTouchCancel
* onTouchEnd
* onTouchMove
* onTouchStart

#### UI

* onScroll

#### Roue de la souris

* onWheel

#### Médias

* onAbort
* onCanPlay
* onCanPlayThrough
* onDurationChange
* onEmptied
* onEncrypted
* onEnded
* onError
* onLoadedData
* onLoadedMetadata
* onLoadStart
* onPause
* onPlay
* onPlaying
* onProgress
* onRateChange
* onSeeked
* onSeeking
* onStalled
* onSuspend
* onTimeUpdate
* onVolumeChange
* onWaiting

#### Image

* onLoad
* onError

#### Animation

* onAnimationStart
* onAnimationEnd
* onAnimationIteration

#### Transition

* onTransitionEnd

### Événements du cycle de vie

Les composants de classe React peuvent avoir des hooks pour plusieurs événements du cycle de vie.

> _Les hooks permettent aux composants fonctionnels d'y accéder également, d'une manière différente._

Au cours de la vie d'un composant, il y a une série d'événements qui sont appelés, et à chaque événement vous pouvez vous accrocher et fournir une fonctionnalité personnalisée.

Quel hook est le meilleur pour quelle fonctionnalité est quelque chose que nous allons voir ici.

Tout d'abord, il y a 3 phases dans le cycle de vie d'un composant React :

* Montage
* Mise à jour
* Démontage

Examinons ces 3 phases en détail et les méthodes qui sont appelées pour chacune.

#### Montage

Lors du montage, vous avez 4 méthodes de cycle de vie avant que le composant ne soit monté dans le DOM : le `constructor`, `getDerivedStateFromProps`, `render` et `componentDidMount`.

#### Constructeur

Le constructeur est la première méthode appelée lors du montage d'un composant.

Vous utilisez généralement le constructeur pour configurer l'état initial en utilisant `this.state = ...`.

#### getDerivedStateFromProps()

Lorsque l'état dépend des props, `getDerivedStateFromProps` peut être utilisé pour mettre à jour l'état en fonction de la valeur des props.

Il a été ajouté dans React 16.3, visant à remplacer la méthode dépréciée `componentWillReceiveProps`.

Dans cette méthode, vous n'avez pas accès à `this` car c'est une méthode statique.

C'est une méthode pure, donc elle ne doit pas causer d'effets secondaires et doit retourner la même sortie lorsqu'elle est appelée plusieurs fois avec la même entrée.

Retourne un objet avec les éléments mis à jour de l'état (ou null si l'état ne change pas)

#### render()

À partir de la méthode render(), vous retournez le JSX qui construit l'interface du composant.

C'est une méthode pure, donc elle ne doit pas causer d'effets secondaires et doit retourner la même sortie lorsqu'elle est appelée plusieurs fois avec la même entrée.
#### componentDidMount()

Cette méthode est celle que vous utiliserez pour effectuer des appels API, ou traiter des opérations sur le DOM.

#### Mise à jour

Lors de la mise à jour, vous avez 5 méthodes de cycle de vie avant que le composant ne soit monté dans le DOM : `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate` et `componentDidUpdate`.

#### getDerivedStateFromProps()

Voir la description ci-dessus pour cette méthode.

#### shouldComponentUpdate()

Cette méthode retourne un booléen, `true` ou `false`. Vous utilisez cette méthode pour indiquer à React s'il doit continuer avec le rerendu, et par défaut elle est `true`. Vous retournerez `false` lorsque le rerendu est coûteux et que vous souhaitez avoir plus de contrôle sur le moment où cela se produit.

#### render()

Voir la description ci-dessus pour cette méthode.

#### getSnapshotBeforeUpdate()

Dans cette méthode, vous avez accès aux props et à l'état du rendu précédent, ainsi qu'au rendu actuel.

Ses cas d'utilisation sont très spécifiques, et c'est probablement celle que vous utiliserez le moins.

#### componentDidUpdate()

Cette méthode est appelée lorsque le composant a été mis à jour dans le DOM. Utilisez-la pour exécuter des API DOM tierces ou appeler des API qui doivent être mises à jour lorsque le DOM change.

Elle correspond à la méthode `componentDidMount()` de la phase de montage.

#### Démontage

Dans cette phase, nous n'avons qu'une seule méthode, `componentWillUnmount`.

#### componentWillUnmount()

La méthode est appelée lorsque le composant est retiré du DOM. Utilisez-la pour effectuer tout type de nettoyage nécessaire.

#### Héritage

Si vous travaillez sur une application qui utilise `componentWillMount`, `componentWillReceiveProps` ou `componentWillUpdate`, celles-ci ont été dépréciées dans React 16.3 et vous devriez migrer vers d'autres méthodes de cycle de vie.

### Formulaires dans React

Les formulaires sont l'un des rares éléments HTML qui sont interactifs par défaut.

Ils ont été conçus pour permettre à l'utilisateur d'interagir avec une page.

Utilisations courantes des formulaires ?

* Recherche
* Formulaires de contact
* Validation des paniers d'achat
* Connexion et inscription
* et plus encore !

En utilisant React, nous pouvons rendre nos formulaires beaucoup plus interactifs et moins statiques.

Il existe deux principales façons de gérer les formulaires dans React, qui diffèrent sur un point fondamental : la gestion des données.

* si les données sont gérées par le DOM, nous les appelons **composants non contrôlés**
* si les données sont gérées par les composants, nous les appelons **composants contrôlés**

Comme vous pouvez l'imaginer, les composants contrôlés sont ce que vous utiliserez la plupart du temps. L'état du composant est la seule source de vérité, plutôt que le DOM. Certains champs de formulaire sont intrinsèquement non contrôlés en raison de leur comportement, comme le champ `<input type="file">`.

Lorsque l'état d'un élément change dans un champ de formulaire géré par un composant, nous le suivons en utilisant l'attribut `onChange`.

```jsx
class Form extends React.Component {
  constructor(props) {
    super(props)
    this.state = { username: '' }
  }
  
  handleChange(event) {}
  
  render() {
    return (
      <form>
        Username:
        <input
          type="text"
          value={this.state.username}
          onChange={this.handleChange}
        />
      </form>
    )
  }
}
```

Pour définir le nouvel état, nous devons lier `this` à la méthode `handleChange`, sinon `this` n'est pas accessible depuis cette méthode :

```
class Form extends React.Component {
  constructor(props) {
    super(props)
    this.state = { username: '' }
    this.handleChange = this.handleChange.bind(this)
  }
  
  handleChange(event) {
    this.setState({ value: event.target.value })
  }
  
  render() {
    return (
      <form>
        <input
          type="text"
          value={this.state.username}
          onChange={this.handleChange}
        />
      </form>
    )
  }
}
```

De même, nous utilisons l'attribut `onSubmit` sur le formulaire pour appeler la méthode `handleSubmit` lorsque le formulaire est soumis :

```
class Form extends React.Component {
  constructor(props) {
    super(props)
    this.state = { username: '' }
    this.handleChange = this.handleChange.bind(this)
    this.handleSubmit = this.handleSubmit.bind(this)
  }
  
  handleChange(event) {
    this.setState({ value: event.target.value })
  }
  
  handleSubmit(event) {
    alert(this.state.username)
    event.preventDefault()
  }
  
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type="text"
          value={this.state.username}
          onChange={this.handleChange}
        />
        <input type="submit" value="Submit" />
      </form>
    )
  }
}
```

La validation dans un formulaire peut être gérée dans la méthode `handleChange` : vous avez accès à l'ancienne valeur de l'état et à la nouvelle. Vous pouvez vérifier la nouvelle valeur et, si elle n'est pas valide, rejeter la valeur mise à jour (et communiquer cela d'une manière ou d'une autre à l'utilisateur).

Les formulaires HTML sont incohérents. Ils ont une longue histoire, et cela se voit. React, cependant, rend les choses plus cohérentes pour nous, et vous pouvez obtenir (et mettre à jour) des champs en utilisant son attribut `value`.

Voici un exemple de `textarea` :

```
<textarea value={this.state.address} onChange={this.handleChange} />
```

Il en va de même pour la balise `select` :

```jsx
<select value="{this.state.age}" onChange="{this.handleChange}">
  <option value="teen">Less than 18</option>
  <option value="adult">18+</option>
</select>
```

Précédemment, nous avons mentionné le champ `<input type="file">`. Cela fonctionne un peu différemment.

Dans ce cas, vous devez obtenir une référence au champ en attribuant l'attribut `ref` à une propriété définie dans le constructeur avec `React.createRef()`, et utiliser cela pour obtenir la valeur dans le gestionnaire de soumission :

```jsx
class FileInput extends React.Component {
  constructor(props) {
    super(props)
    this.curriculum = React.createRef()
    this.handleSubmit = this.handleSubmit.bind(this)
  }
  
  handleSubmit(event) {
    alert(this.curriculum.current.files[0].name)
    event.preventDefault()
  }
  
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input type="file" ref={this.curriculum} />
        <input type="submit" value="Submit" />
      </form>
    )
  }
}
```

C'est la méthode des **composants non contrôlés**. L'état est stocké dans le DOM plutôt que dans l'état du composant (remarquez que nous avons utilisé `this.curriculum` pour accéder au fichier téléchargé, et n'avons pas touché à l'`state`.

Je sais ce que vous pensez — au-delà de ces bases, il doit y avoir une bibliothèque qui simplifie toute cette gestion de formulaire et automatise la validation, la gestion des erreurs et plus encore, n'est-ce pas ? Il y en a une excellente, [Formik](https://github.com/jaredpalmer/formik).

### Référencer un élément DOM

React est excellent pour abstraire le DOM lorsque vous construisez des applications.

Mais que faire si vous souhaitez accéder à l'élément DOM qu'un composant React représente ?

Peut-être devez-vous ajouter une bibliothèque qui interagit directement avec le DOM comme une bibliothèque de graphiques, peut-être devez-vous appeler une API DOM, ou ajouter un focus sur un élément.

> _Quelle que soit la raison, une bonne pratique consiste à s'assurer qu'il n'y a pas d'autre moyen de le faire sans accéder directement au DOM._

Dans le JSX de votre composant, vous pouvez attribuer la référence de l'élément DOM à une propriété de composant en utilisant cet attribut :

```
ref={el => this.someProperty = el}
```

Mettons cela en contexte, par exemple avec un élément `button` :

```
<button ref={el => (this.button = el)} />
```

`button` fait référence à une propriété du composant, qui peut ensuite être utilisée par les méthodes du cycle de vie du composant (ou d'autres méthodes) pour interagir avec le DOM :

```
class SomeComponent extends Component {
  render() {
    return <button ref={el => (this.button = el)} />
  }
}
```

Dans un composant fonctionnel, le mécanisme est le même, vous évitez simplement d'utiliser `this` (puisqu'il ne pointe pas vers l'instance du composant) et utilisez une propriété à la place :

```jsx
function SomeComponent() {
  let button
  return <button ref={el => (button = el)} />
}
```

### Rendu côté serveur

Le **Server Side Rendering**, également appelé **SSR**, est la capacité d'une application JavaScript à se rendre sur le serveur plutôt que dans le navigateur.

Pourquoi voudrions-nous jamais faire cela ?

* il permet à votre site d'avoir un temps de chargement de la première page plus rapide, ce qui est la clé d'une bonne expérience utilisateur
* il est essentiel pour le SEO : les moteurs de recherche ne peuvent pas (encore ?) indexer efficacement et correctement les applications qui se rendent exclusivement côté client. Malgré les dernières améliorations de l'indexation dans Google, il existe d'autres moteurs de recherche, et Google n'est pas parfait dans ce domaine de toute façon. De plus, Google favorise les sites avec des temps de chargement rapides, et devoir charger côté client n'est pas bon pour la vitesse
* c'est génial lorsque les gens partagent une page de votre site sur les réseaux sociaux, car ils peuvent facilement rassembler les métadonnées nécessaires pour partager le lien de manière agréable (images, titre, description..)

Sans le Server Side Rendering, tout ce que votre serveur envoie est une page HTML sans corps, juste quelques balises de script qui sont ensuite utilisées par le navigateur pour rendre l'application.

Les applications rendues côté client sont excellentes pour toute interaction utilisateur ultérieure après le chargement de la première page. Le Server Side Rendering nous permet d'obtenir le meilleur des deux mondes entre les applications rendues côté client et les applications rendues côté serveur : la page est générée côté serveur, mais toutes les interactions avec la page une fois qu'elle a été chargée sont gérées côté client.

Cependant, le Server Side Rendering a aussi ses inconvénients :

* il est juste de dire qu'une preuve de concept SSR simple est simple, mais la complexité du SSR peut croître avec la complexité de votre application
* rendre une grande application côté serveur peut être assez intensif en ressources, et sous une charge lourde, cela pourrait même fournir une expérience plus lente que le rendu côté client, puisque vous avez un seul goulot d'étranglement

### Un exemple très simpliste de ce qu'il faut pour rendre une application React côté serveur

Les configurations SSR peuvent devenir très, très complexes et la plupart des tutoriels intègreront Redux, React Router et de nombreux autres concepts dès le départ.

Pour comprendre comment fonctionne le SSR, commençons par les bases pour implémenter une preuve de concept.

> _N'hésitez pas à sauter ce paragraphe si vous souhaitez simplement examiner les bibliothèques qui fournissent le SSR et ne pas vous soucier du travail de base._

Pour implémenter le SSR de base, nous allons utiliser Express.

> _Si vous êtes nouveau dans Express, ou avez besoin de vous mettre à jour, consultez mon Express Handbook gratuit ici : [https://flaviocopes.com/page/ebooks/](https://flaviocopes.com/page/ebooks/)._

Avertissement : la complexité du SSR peut croître avec la complexité de votre application. Il s'agit de la configuration minimale pour rendre une application React de base. Pour des besoins plus complexes, vous devrez peut-être faire un peu plus de travail ou également consulter les bibliothèques SSR pour React.

Je suppose que vous avez démarré une application React avec `create-react-app`. Si vous essayez simplement, installez-en une maintenant en utilisant `npx create-react-app ssr`.

Allez dans le dossier principal de l'application avec le terminal, puis exécutez :

```bash
npm install express
```

Vous avez un ensemble de dossiers dans votre répertoire d'application. Créez un nouveau dossier appelé `server`, puis allez dedans et créez un fichier nommé `server.js`.

Suivant les conventions de `create-react-app`, l'application se trouve dans le fichier `src/App.js`. Nous allons charger ce composant, et le rendre en une chaîne en utilisant [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html), qui est fourni par `react-dom`.

Vous obtenez le contenu du fichier `./build/index.html`, et remplacez le `<div id="root"></div>` placeholder, qui est la balise où l'application s'accroche par défaut, par ``<div id="root">\${ReactDOMServer.renderToString(<App />)}</div>`.

Tout le contenu à l'intérieur du dossier `build` sera servi tel quel, statiquement par Express.

```
import path from 'path'
import fs from 'fs'

import express from 'express'
import React from 'react'
import ReactDOMServer from 'react-dom/server'

import App from '../src/App'

const PORT = 8080
const app = express()

const router = express.Router()

const serverRenderer = (req, res, next) => {
  fs.readFile(path.resolve('./build/index.html'), 'utf8', (err, data) => {
    if (err) {
      console.error(err)
      return res.status(500).send('An error occurred')
    }
    return res.send(
      data.replace(
        '<div id="root"></div>',
        `<div id="root">${ReactDOMServer.renderToString(<App />)}</div>`
      )
    )
  })
}
router.use('^/$', serverRenderer)

router.use(
  express.static(path.resolve(__dirname, '..', 'build'), { maxAge: '30d' })
)

// dire à l'application d'utiliser les règles ci-dessus
app.use(router)

// app.use(express.static('./build'))
app.listen(PORT, () => {
  console.log(`SSR running on port ${PORT}`)
})
```

Maintenant, dans l'application cliente, dans votre `src/index.js`, au lieu d'appeler `ReactDOM.render()` :

```
ReactDOM.render(<App />, document.getElementById('root'))
```

appelez `[ReactDOM.hydrate()](https://reactjs.org/docs/react-dom.html#hydrate)`, qui est la même chose mais a la capacité supplémentaire d'attacher des écouteurs d'événements au balisage existant une fois que React est chargé :

```
ReactDOM.hydrate(<App />, document.getElementById('root'))
```

Tout le code Node.js doit être transpilé par Babel, car le code Node.js côté serveur ne connaît rien du JSX, ni des modules ES (que nous utilisons pour les instructions `include`).

Installez ces 3 packages :

```bash
npm install @babel/register @babel/preset-env @babel/preset-react ignore-styles express
```

`[ignore-styles](https://www.npmjs.com/package/ignore-styles)` est un utilitaire Babel qui lui dira d'ignorer les fichiers CSS importés en utilisant la syntaxe `import`.

Créons un point d'entrée dans `server/index.js` :

```
require('ignore-styles')

require('@babel/register')({
  ignore: [/(node_modules)/],
  presets: ['@babel/preset-env', '@babel/preset-react']
})

require('./server')
```

Construisez l'application React, afin que le dossier build/ soit peuplé :

```bash
npm run build
```

et exécutons cela :

```bash
node server/index.js
```

J'ai dit que c'était une approche simpliste, et c'est le cas :

* elle ne gère pas correctement le rendu des images lors de l'utilisation d'importations, qui nécessitent Webpack pour fonctionner (et qui compliquent beaucoup le processus)
* elle ne gère pas les métadonnées de l'en-tête de la page, qui sont essentielles pour le SEO et le partage social (entre autres)

Donc, bien que ce soit un bon exemple d'utilisation de `ReactDOMServer.renderToString()` et `ReactDOM.hydrate` pour obtenir ce rendu côté serveur de base, ce n'est pas suffisant pour une utilisation réelle.

#### Server Side Rendering utilisant des bibliothèques

Le SSR est difficile à faire correctement, et React n'a pas de moyen standard pour l'implémenter.

Il est encore très débattu si cela vaut la peine de se donner tant de mal, de complications et de surcharge pour obtenir les avantages, plutôt que d'utiliser une technologie différente pour servir ces pages. [Cette discussion sur Reddit](https://www.reddit.com/r/reactjs/comments/7o6oj6/serverside_rendering_not_worth_it/) contient de nombreuses opinions à ce sujet.

Lorsque le Server Side Rendering est une question importante, ma suggestion est de s'appuyer sur des bibliothèques et des outils pré-construits qui ont eu cet objectif à l'esprit depuis le début.

En particulier, je suggère **Next.js** et **Gatsby**, deux projets que nous verrons plus tard.

### L'API Context

L'API Context est un moyen élégant de transmettre l'état à travers l'application sans avoir à utiliser les props. Elle a été introduite pour vous permettre de transmettre l'état (et permettre à l'état de se mettre à jour) à travers l'application, sans avoir à utiliser les props pour cela.

L'équipe React suggère de rester avec les props si vous n'avez que quelques niveaux d'enfants à transmettre, car c'est encore une API beaucoup moins compliquée que l'API Context.

Dans de nombreux cas, elle nous permet d'éviter d'utiliser Redux, simplifiant ainsi nos applications et aussi l'apprentissage de l'utilisation de React.

Comment cela fonctionne-t-il ?

Vous créez un contexte en utilisant `React.createContext()`, qui retourne un objet Context :

```
const { Provider, Consumer } = React.createContext()
```

Ensuite, vous créez un composant wrapper qui retourne un composant **Provider**, et vous ajoutez comme enfants tous les composants à partir desquels vous souhaitez accéder au contexte :

```
class Container extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      something: 'hey'
    }
  }
  
  render() {
    return (
      <Provider value={{ state: this.state }}>{this.props.children}</Provider>
    )
  }
}

class HelloWorld extends React.Component {
  render() {
    return (
      <Container>
        <Button />
      </Container>
    )
  }
}
```

J'ai utilisé Container comme nom de ce composant car ce sera un fournisseur global. Vous pouvez également créer des contextes plus petits.

À l'intérieur d'un composant qui est enveloppé dans un Provider, vous utilisez un composant **Consumer** pour utiliser le contexte :

```
class Button extends React.Component {
  render() {
    return (
      <Consumer>
        {context => <button>{context.state.something}</button>}
      </Consumer>
    )
  }
}
```

Vous pouvez également passer des fonctions dans une valeur Provider, et ces fonctions seront utilisées par le Consumer pour mettre à jour l'état du contexte :

```
<Provider value={{
  state: this.state,
  updateSomething: () => this.setState({something: 'ho!'})
  {this.props.children}
</Provider>

/* ... */
<Consumer>
  {(context) => (
    <button onClick={context.updateSomething}>{context.state.something}</button>
  )}
</Consumer>
```

Vous pouvez voir cela en action [dans ce Glitch](https://glitch.com/edit/#!/flavio-react-context-api-example?path=app/components/HelloWorld.jsx).

Vous pouvez créer plusieurs contextes, pour distribuer votre état à travers les composants, tout en l'exposant et en le rendant accessible par n'importe quel composant que vous souhaitez.

Lorsque vous utilisez plusieurs fichiers, vous créez le contenu dans un fichier, et l'importez dans tous les endroits où vous l'utilisez :

```
//context.js
import React from 'react'
export default React.createContext()

//component1.js
import Context from './context'
//... use Context.Provider

//component2.js
import Context from './context'
//... use Context.Consumer
```

### Composants d'ordre supérieur

Vous êtes peut-être familier avec les fonctions d'ordre supérieur en JavaScript. Ce sont des fonctions qui acceptent des fonctions comme arguments, et/ou retournent des fonctions.

Deux exemples de ces fonctions sont `Array.map()` ou `Array.filter()`.

Dans React, nous étendons ce concept aux composants, et ainsi nous avons un **composant d'ordre supérieur (HOC)** lorsque le composant accepte un composant en entrée et retourne un composant en sortie.

En général, les composants d'ordre supérieur vous permettent de créer du code qui est composable et réutilisable, et aussi plus encapsulé.

Nous pouvons utiliser un HOC pour ajouter des méthodes ou des propriétés à l'état d'un composant, ou un store Redux par exemple.

Vous pourriez vouloir utiliser des composants d'ordre supérieur lorsque vous souhaitez améliorer un composant existant, opérer sur l'état ou les props, ou son balisage rendu.

Il existe une convention de préfixer un composant d'ordre supérieur avec la chaîne `with` (c'est une convention, donc ce n'est pas obligatoire), donc si vous avez un composant `Button`, son homologue HOC devrait être appelé `withButton`.

Créons-en un.

L'exemple le plus simple jamais d'un HOC est celui qui retourne simplement le composant inchangé :

```
const withElement = Element => () => <Element />
```

Rendons cela un peu plus utile et ajoutons une propriété à ce bouton, en plus de toutes les props qu'il avait déjà, la couleur :

```
const withColor = Element => props => <Element {...props} color="red" />
```

Nous utilisons ce HOC dans un composant JSX :

```
const Button = () => {
  return <button>test</button>
}

const ColoredButton = withColor(Button)
```

et nous pouvons enfin rendre le composant ColoredButton dans notre JSX d'application :

```jsx
function App() {
  return (
    <div className="App">
      <h1>Hello</h1>
      <ColoredButton />
    </div>
  )
}
```

C'est un exemple très simple mais espérons que vous pouvez saisir l'essentiel des HOC avant d'appliquer ces concepts à des scénarios plus complexes.

### Render Props

Un modèle courant utilisé pour partager l'état entre les composants est d'utiliser la prop `children`.

À l'intérieur d'un composant JSX, vous pouvez rendre `{this.props.children}` qui injecte automatiquement tout JSX passé dans le composant parent en tant qu'enfants :

```
class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      /*...*/
    }
  }
  
  render() {
    return <div>{this.props.children}</div>
  }
}

const Children1 = () => {}

const Children2 = () => {}

const App = () => (
  <Parent>
    <Children1 />
    <Children2 />
  </Parent>
)
```

Cependant, il y a un problème ici : l'état du composant parent ne peut pas être accessible depuis les enfants.

Pour pouvoir partager l'état, vous devez utiliser un composant avec une prop de rendu, et au lieu de passer des composants en tant qu'enfants du composant parent, vous passez une fonction que vous exécutez ensuite dans `{this.props.children()}`. La fonction peut accepter des arguments :

```
class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = { name: 'Flavio' }
  }
  
  render() {
    return <div>{this.props.children(this.state.name)}</div>
  }
}

const Children1 = props => {
  return <p>{props.name}</p>
}

const App = () => <Parent>{name => <Children1 name={name} />}</Parent>
```

Au lieu d'utiliser la prop `children`, qui a une signification très spécifique, vous pouvez utiliser n'importe quelle prop, et ainsi vous pouvez utiliser ce modèle plusieurs fois sur le même composant :

```
class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = { name: 'Flavio', age: 35 }
  }
  
  render() {
    return (
      <div>
        <p>Test</p>
        {this.props.someprop1(this.state.name)}
        {this.props.someprop2(this.state.age)}
      </div>
    )
  }
}

const Children1 = props => {
  return <p>{props.name}</p>
}

const Children2 = props => {
  return <p>{props.age}</p>
}

const App = () => (
  <Parent
    someprop1={name => <Children1 name={name} />}
    someprop2={age => <Children2 age={age} />}
  />
)

ReactDOM.render(<App />, document.getElementById('app'))
```

### Hooks

Les Hooks sont une fonctionnalité qui sera introduite dans React 16.7, et qui va changer la façon dont nous écrivons les applications React à l'avenir.

Avant l'arrivée des Hooks, certaines choses clés dans les composants n'étaient possibles qu'en utilisant des composants de classe : avoir leur propre état, et utiliser les événements de cycle de vie. Les composants de fonction, plus légers et plus flexibles, étaient limités en fonctionnalité.

**Les Hooks permettent aux composants de fonction d'avoir un état et de répondre aux événements de cycle de vie** également, et rendent en quelque sorte les composants de classe obsolètes. Ils permettent également aux composants de fonction d'avoir une bonne façon de gérer les événements.

#### Accéder à l'état

En utilisant l'API `useState()`, vous pouvez créer une nouvelle variable d'état, et avoir un moyen de la modifier. `useState()` accepte la valeur initiale de l'élément d'état et retourne un tableau contenant la variable d'état, et la fonction que vous appelez pour modifier l'état. Puisqu'il retourne un tableau, nous utilisons la [destructuration de tableau](https://flaviocopes.com/es6/#destructuring-assignments) pour accéder à chaque élément individuel, comme ceci : `const [count, setCount] = useState(0)`

Voici un exemple pratique :

```
import { useState } from 'react'

const Counter = () => {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>Vous avez cliqué {count} fois</p>
      <button onClick={() => setCount(count + 1)}>Cliquez-moi</button>
    </div>
  )
}

ReactDOM.render(<Counter />, document.getElementById('app'))
```

Vous pouvez ajouter autant d'appels `useState()` que vous voulez, pour créer autant de variables d'état que vous voulez. Assurez-vous simplement de l'appeler au niveau supérieur d'un composant (pas dans un `if` ou dans un autre bloc).

[Exemple sur Codepen](https://codepen.io/flaviocopes/pen/maVPKa)

#### Accéder aux hooks de cycle de vie

Une autre fonctionnalité très importante des Hooks est de permettre aux composants de fonction d'avoir accès aux hooks de cycle de vie.

En utilisant des composants de classe, vous pouvez enregistrer une fonction sur les événements `componentDidMount`, `componentWillUnmount` et `componentDidUpdate`, et ceux-ci serviront de nombreux cas d'utilisation, de l'initialisation des variables aux appels d'API en passant par le nettoyage.

Les Hooks fournissent l'API `useEffect()`. L'appel accepte une fonction comme argument.

La fonction s'exécute lorsque le composant est rendu pour la première fois, et à chaque nouveau rendu/mise à jour suivante. React met d'abord à jour le DOM, puis appelle toute fonction passée à `useEffect()`. Tout cela sans bloquer le rendu de l'UI, même avec du code bloquant, contrairement aux anciens `componentDidMount` et `componentDidUpdate`, ce qui rend nos applications plus rapides.

Exemple :

```
const { useEffect, useState } = React

const CounterWithNameAndSideEffect = () => {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('Flavio')
  
  useEffect(() => {
    console.log(`Salut ${name} vous avez cliqué ${count} fois`)
  })
  
  return (
    <div>
      <p>
        Salut {name} vous avez cliqué {count} fois
      </p>
      <button onClick={() => setCount(count + 1)}>Cliquez-moi</button>
      <button onClick={() => setName(name === 'Flavio' ? 'Roger' : 'Flavio')}>
        Changer le nom
      </button>
    </div>
  )
}

ReactDOM.render(
  <CounterWithNameAndSideEffect />,
  document.getElementById('app')
)
```

Le même travail que `componentWillUnmount` peut être réalisé en **retournant** optionnellement une fonction depuis notre paramètre `useEffect()` :

```
useEffect(() => {
  console.log(`Salut ${name} vous avez cliqué ${count} fois`)
  return () => {
    console.log(`Démonté`)
  }
})
```

`useEffect()` peut être appelé plusieurs fois, ce qui est bien pour séparer la logique non liée (quelque chose qui afflige les événements de cycle de vie des composants de classe).

Puisque les fonctions `useEffect()` sont exécutées à chaque nouveau rendu/mise à jour suivante, nous pouvons dire à React de sauter une exécution, pour des raisons de performance, en ajoutant un deuxième paramètre qui est un tableau contenant une liste de variables d'état à surveiller. React ne réexécutera l'effet de bord que si l'un des éléments de ce tableau change.

```
useEffect(
  () => {
    console.log(`Salut ${name} vous avez cliqué ${count} fois`)
  },
  [name, count]
)
```

De même, vous pouvez dire à React d'exécuter l'effet de bord une seule fois (au moment du montage), en passant un tableau vide :

```
useEffect(() => {
  console.log(`Composant monté`)
}, [])
```

`useEffect()` est idéal pour ajouter des logs, accéder aux API tierces et bien plus encore.

[Exemple sur Codepen](https://codepen.io/flaviocopes/pen/WLrxXp)

#### Gérer les événements dans les composants de fonction

Avant les hooks, vous utilisiez soit des composants de classe, soit vous passiez un gestionnaire d'événements en utilisant des props.

Maintenant, nous pouvons utiliser l'API intégrée `useCallback()` :

```
const Button = () => {
  const handleClick = useCallback(() => {
    //...faire quelque chose
  })
  return <button onClick={handleClick} />
}
```

Tout paramètre utilisé à l'intérieur de la fonction doit être passé via un deuxième paramètre à `useCallback()`, dans un tableau :

```
const Button = () => {
  let name = '' //... ajouter la logique
  const handleClick = useCallback(
    () => {
      //...faire quelque chose
    },
    [name]
  )
  return <button onClick={handleClick} />
}
```

#### Activer la communication inter-composants en utilisant des hooks personnalisés

La capacité à écrire vos propres hooks est la fonctionnalité qui va modifier de manière significative la façon dont vous écrivez les applications React à l'avenir.

En utilisant des hooks personnalisés, vous avez une autre façon de partager l'état et la logique entre les composants, ajoutant une amélioration significative aux modèles de render props et de composants d'ordre supérieur. Qui sont toujours excellents, mais maintenant avec des hooks personnalisés, ils ont moins de pertinence dans de nombreux cas d'utilisation.

Comment créer un hook personnalisé ?

Un hook est simplement une fonction qui commence conventionnellement par `use`. Il peut accepter un nombre arbitraire d'arguments, et retourner tout ce qu'il veut.

Exemples :

```
const useGetData() {
  //...
  return data
}
```

ou

```
const useGetUser(username) {
  //...const user = fetch(...)
  //...const userData = ...
  return [user, userData]
}
```

Dans vos propres composants, vous pouvez utiliser le hook comme ceci :

```
const MyComponent = () => {
  const data = useGetData()
  const [user, userData] = useGetUser('flavio')
  //...
}
```

Quand exactement ajouter des hooks au lieu de fonctions régulières devrait être déterminé sur une base de cas d'utilisation, et seule l'expérience le dira.

### Code splitting

Les applications JavaScript modernes peuvent être assez volumineuses en termes de taille de bundle. Vous ne voulez pas que vos utilisateurs aient à télécharger un package de 1 Mo de JavaScript (votre code et les bibliothèques que vous utilisez) juste pour charger la première page, n'est-ce pas ? Mais c'est ce qui se passe par défaut lorsque vous livrez une application Web moderne construite avec le bundling Webpack.

Ce bundle contiendra du code qui ne s'exécutera peut-être jamais car l'utilisateur ne s'arrête que sur la page de connexion et ne voit jamais le reste de votre application.

Le code splitting est la pratique de ne charger le JavaScript que lorsque vous en avez besoin.

Cela améliore :

* la performance de votre application
* l'impact sur la mémoire, et donc l'utilisation de la batterie sur les appareils mobiles
* la taille des KiloBytes (ou MegaBytes) téléchargés

React 16.6.0, sorti en octobre 2018, a introduit une façon de réaliser le code splitting qui devrait prendre la place de tous les outils ou bibliothèques précédemment utilisés : **React.lazy** et **Suspense**.

`React.lazy` et `Suspense` forment le moyen parfait de charger paresseusement une dépendance et de ne la charger que lorsque cela est nécessaire.

Commençons par `React.lazy`. Vous l'utilisez pour importer n'importe quel composant :

```
import React from 'react'

const TodoList = React.lazy(() => import('./TodoList'))

export default () => {
  return (
    <div>
      <TodoList />
    </div>
  )
}
```

Le composant TodoList sera dynamiquement ajouté à la sortie dès qu'il sera disponible. Webpack créera un bundle séparé pour celui-ci, et se chargera de le charger lorsque cela sera nécessaire.

`Suspense` est un composant que vous pouvez utiliser pour envelopper tout composant chargé paresseusement :

```
import React from 'react'

const TodoList = React.lazy(() => import('./TodoList'))

export default () => {
  return (
    <div>
      <React.Suspense>
        <TodoList />
      </React.Suspense>
    </div>
  )
}
```

Il se charge de gérer la sortie pendant que le composant chargé paresseusement est récupéré et rendu.

Utilisez sa prop `fallback` pour sortir du JSX ou un composant :

```
...
      <React.Suspense fallback={<p>Veuillez patienter</p>}>
        <TodoList />
      </React.Suspense>
...
```

Tout cela fonctionne bien avec React Router :

```jsx
import React from 'react'
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'

const TodoList = React.lazy(() => import('./routes/TodoList'))
const NewTodo = React.lazy(() => import('./routes/NewTodo'))

const App = () => (
  <Router>
    <React.Suspense fallback={<p>Veuillez patienter</p>}>
      <Switch>
        <Route exact path="/" component={TodoList} />
        <Route path="/new" component={NewTodo} />
      </Switch>
    </React.Suspense>
  </Router>
)
```

### SECTION 4 : EXEMPLES PRATIQUES

2 applications très simples pour expliquer certains des concepts introduits jusqu'à présent.

### Un exemple très simple de construction d'un compteur dans React

Dans cet exemple court, nous allons construire un exemple très simple d'un compteur dans React, en appliquant de nombreux concepts et théories décrits précédemment.

Utilisons Codepen pour cela. Nous commençons par forker le [modèle React pen](https://codepen.io/flaviocopes/pen/VqeaxB).

> _Dans Codepen, nous n'avons pas besoin d'importer React et ReactDOM car ils sont déjà ajoutés dans la portée._

Nous affichons le compte dans une div, et nous ajoutons quelques boutons pour incrémenter ce compte :

```
const Button = ({ increment }) => {
  return <button>+{increment}</button>
}

const App = () => {
  let count = 0
  
  return (
    <div>
      <Button increment={1} />
      <Button increment={10} />
      <Button increment={100} />
      <Button increment={1000} />
      <span>{count}</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('app'))
```

Ajoutons la fonctionnalité qui nous permet de changer le compte en cliquant sur les boutons, en ajoutant une prop `onClickFunction` :

```jsx
const Button = ({ increment, onClickFunction }) => {
  const handleClick = () => {
    onClickFunction(increment)
  }
  return <button onClick={handleClick}>+{increment}</button>
}

const App = () => {
  let count = 0
  
  const incrementCount = increment => {
    //TODO
  }
  
  return (
    <div>
      <Button increment={1} onClickFunction={incrementCount} />
      <Button increment={10} onClickFunction={incrementCount} />
      <Button increment={100} onClickFunction={incrementCount} />
      <Button increment={1000} onClickFunction={incrementCount} />
      <span>{count}</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('app'))
```

Ici, chaque élément Button a 2 props : `increment` et `onClickFunction`. Nous créons 4 boutons différents, avec 4 valeurs d'incrément : 1, 10, 100, 1000.

Lorsque le bouton dans le composant Button est cliqué, la fonction `incrementCount` est appelée.

Cette fonction doit incrémenter le compte local. Comment pouvons-nous faire cela ? Nous pouvons utiliser des hooks :

```jsx
const { useState } = React

const Button = ({ increment, onClickFunction }) => {
  const handleClick = () => {
    onClickFunction(increment)
  }
  return <button onClick={handleClick}>+{increment}</button>
}

const App = () => {
  const [count, setCount] = useState(0)
  
  const incrementCount = increment => {
    setCount(count + increment)
  }
  
  return (
    <div>
      <Button increment={1} onClickFunction={incrementCount} />
      <Button increment={10} onClickFunction={incrementCount} />
      <Button increment={100} onClickFunction={incrementCount} />
      <Button increment={1000} onClickFunction={incrementCount} />
      <span>{count}</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('app'))
```

`useState()` initialise la variable count à 0 et nous fournit la méthode `setCount()` pour mettre à jour sa valeur.

Nous utilisons les deux dans l'implémentation de la méthode `incrementCount()`, qui appelle `setCount()` en mettant à jour la valeur à la valeur existante de `count`, plus l'incrément passé par chaque composant Button.

Le code complet de l'exemple peut être vu à [https://codepen.io/flaviocopes/pen/QzEQPR](https://codepen.io/flaviocopes/pen/QzEQPR)

### Récupérer et afficher les informations des utilisateurs GitHub via l'API

Exemple très simple d'un formulaire qui accepte un nom d'utilisateur GitHub et une fois qu'il reçoit un événement `submit`, il demande à l'API GitHub les informations de l'utilisateur, et les imprime.

Ce code crée un composant **Card** réutilisable. Lorsque vous entrez un nom dans le champ `input` géré par le composant **Form**, ce nom est _lié à son état_.

Lorsque _Add card_ est pressé, le formulaire d'entrée est effacé en effaçant l'état `userName` du composant **Form**.

L'exemple utilise, en plus de React, la bibliothèque [Axios](https://flaviocopes.com/axios/). C'est une bibliothèque utile et légère pour gérer les requêtes réseau. Ajoutez-la aux paramètres de Pen dans Codepen, ou installez-la localement en utilisant `npm install axios`.

Nous commençons par créer le composant `Card`, celui qui affichera notre image et nos détails tels que recueillis depuis GitHub. Il obtient ses données via props, en utilisant

* `props.avatar_url` l'avatar de l'utilisateur
* `props.name` le nom de l'utilisateur
* `props.blog` l'URL du site web de l'utilisateur

```jsx
const Card = props => {
  return (
    <div style={{ margin: '1em' }}>
      <img alt="avatar" style={{ width: '70px' }} src={props.avatar_url} />
      <div>
        <div style={{ fontWeight: 'bold' }}>{props.name}</div>
        <div>{props.blog}</div>
      </div>
    </div>
  )
}
```

Nous créons une liste de ces composants, qui sera passée par un composant parent dans la prop `cards` à `CardList`, qui itère simplement dessus en utilisant `map()` et produit une liste de cartes :

```jsx
const CardList = props => (
  <div>
    {props.cards.map(card => (
      <Card {...card} />
    ))}
  </div>
)
```

Le composant parent est App, qui stocke le tableau `cards` dans son propre état, géré en utilisant le Hook `useState()` :

```jsx
const App = () => {
  const [cards, setCards] = useState([])
  
  return (
    <div>
      <CardList cards={cards} />
    </div>
  )
}
```

Cool ! Nous devons maintenant avoir un moyen de demander à GitHub les détails d'un seul nom d'utilisateur. Nous allons le faire en utilisant un composant `Form`, où nous gérons notre propre état (`username`), et nous demandons à GitHub des informations sur un utilisateur en utilisant leurs API publiques, via Axios :

```jsx
const Form = props => {
  const [username, setUsername] = useState('')
  
  handleSubmit = event => {
    event.preventDefault()
    
    axios.get(`https://api.github.com/users/${username}`).then(resp => {
      props.onSubmit(resp.data)
      setUsername('')
    })
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={username}
        onChange={event => setUsername(event.target.value)}
        placeholder="Nom d'utilisateur GitHub"
        required
      />
      <button type="submit">Ajouter une carte</button>
    </form>
  )
}
```

Lorsque le formulaire est soumis, nous appelons l'événement `handleSubmit`, et après l'appel réseau, nous appelons `props.onSubmit` en passant les données que nous avons obtenues de GitHub au parent (`App`).

Nous l'ajoutons à `App`, en passant une méthode pour ajouter une nouvelle carte à la liste des cartes, `addNewCard`, en tant que sa prop `onSubmit` :

```jsx
const App = () => {
  const [cards, setCards] = useState([])
  
  addNewCard = cardInfo => {
    setCards(cards.concat(cardInfo))
  }
  
  return (
    <div>
      <Form onSubmit={addNewCard} />
      <CardList cards={cards} />
    </div>
  )
}
```

Enfin, nous rendons l'application :

```
ReactDOM.render(<App />, document.getElementById('app'))
```

Voici le code source complet de notre petite application React :

```jsx
const { useState } = React

const Card = props => {
  return (
    <div style={{ margin: '1em' }}>
      <img alt="avatar" style={{ width: '70px' }} src={props.avatar_url} />
      <div>
        <div style={{ fontWeight: 'bold' }}>{props.name}</div>
        <div>{props.blog}</div>
      </div>
    </div>
  )
}

const CardList = props => <div>{props.cards.map(card => <Card {...card} />)}</div>

const Form = props => {
  const [username, setUsername] = useState('')
  
  handleSubmit = event => {
    event.preventDefault()
    
    axios
      .get(`https://api.github.com/users/${username}`)
      .then(resp => {
        props.onSubmit(resp.data)
        setUsername('')
      })
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={username}
        onChange={event => setUsername(event.target.value)}
        placeholder="Nom d'utilisateur GitHub"
        required
      />
      <button type="submit">Ajouter une carte</button>
    </form>
  )
}

const App = () => {
  const [cards, setCards] = useState([])
  
  addNewCard = cardInfo => {
    setCards(cards.concat(cardInfo))
  }
  
  return (
    <div>
      <Form onSubmit={addNewCard} />
      <CardList cards={cards} />
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('app'))
```

Voici le résultat final :

![Image](https://cdn-media-1.freecodecamp.org/images/cZoqPqmbwvuUaIiWJ16fTj6VOhTIquXDECnP)

Consultez-le sur Codepen à l'adresse [https://codepen.io/flaviocopes/pen/oJLyeY](https://codepen.io/flaviocopes/pen/oJLyeY)

### SECTION 5 : STYLISATION

### CSS dans React

En utilisant React, vous avez diverses façons d'ajouter du style à vos composants.

#### Utilisation de classes et de CSS

La première et la plus simple est d'utiliser des classes, et d'utiliser un fichier CSS normal pour cibler ces classes :

```
const Button = () => {
  return <button className="button">Un bouton</button>
}

.button {
  background-color: yellow;
}
```

Vous pouvez importer la feuille de style en utilisant une instruction d'importation, comme ceci :

```
import './style.css'
```
et [Webpack](https://flaviocopes.com/webpack/) s'occupera d'ajouter la propriété CSS au bundle.

#### Utilisation de l'attribut style

Une deuxième méthode consiste à utiliser l'attribut `style` attaché à un élément JSX. Avec cette approche, vous n'avez pas besoin d'un fichier CSS séparé.

```
const Button = () => {
  return <button style={{ backgroundColor: 'yellow' }}>Un bouton</button>
}
```

Le CSS est maintenant défini d'une manière légèrement différente. Tout d'abord, remarquez les doubles accolades : c'est parce que `style` accepte un objet. Nous passons un objet JavaScript, qui est défini entre accolades. Nous pourrions aussi faire ceci :

```
const buttonStyle = { backgroundColor: 'yellow' }
const Button = () => {
  return <button style={buttonStyle}>Un bouton</button>
}
```

Lorsque vous utilisez `create-react-app`, ces styles sont autopréfixés par défaut grâce à son utilisation de [Autoprefixer](https://github.com/postcss/autoprefixer).

De plus, le style est maintenant en camelCase au lieu d'utiliser des tirets. Chaque fois qu'une propriété CSS a un tiret, supprimez-le et commencez le mot suivant en majuscule.

Les styles ont l'avantage d'être locaux au composant, et ils ne peuvent pas fuir vers d'autres composants dans d'autres parties de l'application, quelque chose que l'utilisation de classes et d'un fichier CSS externe ne peut pas fournir.

#### Utilisation des modules CSS

Les **modules CSS** semblent être un compromis parfait : vous utilisez des classes, mais le CSS est limité au composant, ce qui signifie que tout style que vous ajoutez ne peut pas être appliqué à d'autres composants sans votre permission. Et pourtant, vos styles sont définis dans un fichier CSS séparé, ce qui est plus facile à maintenir que le CSS en JavaScript (et vous pouvez utiliser vos anciens noms de propriétés CSS).

Commencez par créer un fichier CSS qui se termine par `.module.css`, par exemple `Button.module.css`. Un bon choix est de lui donner le même nom que le composant que vous allez styliser.

Ajoutez votre CSS ici, puis importez-le dans le fichier de composant que vous souhaitez styliser :

```
import style from './Button.module.css'
```

Vous pouvez maintenant l'utiliser dans votre JSX :

```
const Button = () => {
  return <button className={style.content}>Un bouton</button>
}
```

C'est tout ! Dans le balisage résultant, React générera une classe spécifique et unique pour chaque composant rendu, et assignera le CSS à cette classe, de sorte que le CSS n'affecte pas d'autre balisage.

### SASS dans React

Lorsque vous construisez une application React en utilisant `[create-react-app](https://flaviocopes.com/react-create-react-app/)`, vous avez de nombreuses options à votre disposition en matière de stylisation.

> _Bien sûr, si vous n'utilisez pas `create-react-app`, vous avez tous les choix possibles, mais nous limitons la discussion aux options fournies par `create-react-app`._

Vous pouvez styliser en utilisant des classes simples et des fichiers CSS, en utilisant l'attribut style ou les modules CSS, pour commencer.

SASS/SCSS est une option très populaire, très appréciée par de nombreux développeurs.

Vous pouvez l'utiliser sans aucune configuration, à partir de `create-react-app` 2.

Tout ce dont vous avez besoin est un fichier `.sass` ou `.scss`, et vous l'importez simplement dans un composant :

```
import './styles.scss'
```

Vous pouvez voir un exemple de son fonctionnement à l'adresse [https://codesandbox.io/s/18qq31rp3](https://codesandbox.io/s/18qq31rp3).

### Styled Components

Les Styled Components sont l'une des nouvelles façons d'utiliser le CSS dans le JavaScript moderne. Ils sont destinés à être le successeur des modules CSS, une façon d'écrire du CSS qui est limité à un seul composant, et ne fuit pas vers d'autres éléments de la page.

#### Une brève histoire

Il était une fois, le Web était vraiment simple et le CSS n'existait même pas. Nous disposions les pages en utilisant des **tableaux** et des frames. Le bon temps.

Puis le **CSS** est apparu, et après un certain temps, il est devenu clair que les frameworks pouvaient grandement aider, surtout dans la construction de grilles et de mises en page, Bootstrap et Foundation jouant un grand rôle dans cela.

Les préprocesseurs comme **SASS** et autres ont beaucoup aidé à ralentir l'adoption des frameworks, et à mieux organiser le code, des conventions comme **BEM** et **SMACSS** se sont développées, surtout au sein des équipes.

Les conventions ne sont pas une solution à tout, et elles sont complexes à retenir, donc ces dernières années, avec l'adoption croissante de [JavaScript](https://flaviocopes.com/javascript/) et des processus de construction dans chaque projet frontend, le CSS a trouvé sa place dans JavaScript (**CSS-in-JS**).

De nouveaux outils ont exploré de nouvelles façons de faire du CSS-in-JS et quelques-uns ont réussi avec une popularité croissante :

* React Style
* jsxstyle
* Radium

et plus.

#### Présentation des Styled Components

L'un des outils les plus populaires est **Styled Components**.

Il est destiné à être le successeur des **modules CSS**, une façon d'écrire du CSS qui est limité à un seul composant, et ne fuit pas vers d'autres éléments de la page.

(plus d'informations sur les modules CSS [ici](https://css-tricks.com/css-modules-part-1-need/) et [ici](https://glenmaddern.com/articles/css-modules))

Les Styled Components vous permettent d'écrire du CSS simple dans vos composants sans vous soucier des collisions de noms de classes.

#### Installation

Installez simplement styled-components en utilisant [npm](https://flaviocopes.com/npm/) ou [yarn](https://flaviocopes.com/yarn/) :

```bash
npm install styled-components
yarn add styled-components
```

C'est tout ! Maintenant, tout ce que vous avez à faire est d'ajouter cette importation :

```
import styled from 'styled-components'
```

#### Votre premier composant stylisé

Avec l'objet `styled` importé, vous pouvez maintenant commencer à créer des Styled Components. En voici le premier :

```jsx
const Button = styled.button`
  font-size: 1.5em;
  background-color: black;
  color: white;
`
```

`Button` est maintenant un composant React à part entière.

Nous l'avons créé en utilisant une fonction de l'objet styled, appelée `button` dans ce cas, et en passant quelques propriétés CSS dans un [littéral de gabarit](https://flaviocopes.com/ecmascript/#template-literals).

Maintenant, ce composant peut être rendu dans notre conteneur en utilisant la syntaxe normale de React :

```
render(<Button />)
```

Les Styled Components offrent d'autres fonctions que vous pouvez utiliser pour créer d'autres composants, pas seulement `button`, comme `section`, `h1`, `input` et bien d'autres.

La syntaxe utilisée, avec les guillemets inversés, peut sembler étrange au début, mais elle s'appelle [Tagged Templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), c'est du JavaScript simple et c'est une façon de passer un argument à la fonction.

#### Utilisation des props pour personnaliser les composants

Lorsque vous passez des props à un Styled Component, il les transmet au nœud [DOM](https://flaviocopes.com/dom/) monté.

Par exemple, voici comment nous passons les props `placeholder` et `type` à un composant `input` :

```
const Input = styled.input`
  //...
`

render(
  <div>
    <Input placeholder="..." type="text" />
  </div>
)
```

Cela fera exactement ce que vous pensez, en insérant ces props comme attributs HTML.

Les props, au lieu d'être simplement transmises au [DOM](https://flaviocopes.com/dom/), peuvent également être utilisées pour personnaliser un composant en fonction de la valeur de la prop. Voici un exemple :

```
const Button = styled.button`
  background: ${props => (props.primary ? 'black' : 'white')};
  color: ${props => (props.primary ? 'white' : 'black')};
`

render(
  <div>
    <Button>Un bouton normal</Button>
    <Button>Un bouton normal</Button>
    <Button primary>Le bouton principal</Button>
  </div>
)
```

La définition de la prop `primary` change la couleur du bouton.

#### Étendre un Styled Component existant

Si vous avez un composant et que vous souhaitez en créer un similaire, simplement stylisé légèrement différemment, vous pouvez utiliser `extend` :

```
const Button = styled.button`
  color: black;
  //...
`

const WhiteButton = Button.extend`
  color: white;
`

render(
  <div>
    <Button>Un bouton noir, comme tous les boutons</Button>
    <WhiteButton>Un bouton blanc</WhiteButton>
  </div>
)
```

#### C'est du CSS normal

Dans les Styled Components, vous pouvez utiliser le CSS que vous connaissez et aimez déjà. C'est juste du CSS normal. Ce n'est pas du pseudo CSS ni du CSS en ligne avec ses limitations.

Vous pouvez utiliser des requêtes média, de la [nesting](https://tabatkins.github.io/specs/css-nesting/) et tout ce dont vous pourriez avoir besoin.

#### Utilisation des préfixes de fournisseurs

Les Styled Components ajoutent automatiquement tous les préfixes de fournisseurs nécessaires, vous n'avez donc pas à vous soucier de ce problème.

### SECTION 6 : OUTILS

### Babel

Babel est un outil génial, et il existe depuis un certain temps, mais de nos jours, presque tous les développeurs JavaScript s'y fient. Cela va continuer, car Babel est maintenant indispensable et a résolu un gros problème pour tout le monde.

Quel problème ?

Le problème que tout développeur Web a sûrement eu : une fonctionnalité de JavaScript est disponible dans la dernière version d'un navigateur, mais pas dans les versions plus anciennes. Ou peut-être que Chrome ou Firefox l'implémentent, mais pas Safari iOS et Edge.

Par exemple, ES6 a introduit les **fonctions fléchées** :

```
[1, 2, 3].map((n) => n + 1)
```

Qui est maintenant supporté par tous les navigateurs modernes. IE11 ne le supporte pas, ni Opera Mini (Comment le sais-je ? En vérifiant le [Tableau de compatibilité ES6](http://kangax.github.io/compat-table/es6/#test-arrow_functions)).

Alors, comment devriez-vous gérer ce problème ? Devriez-vous avancer et laisser ces clients avec des navigateurs plus anciens/incompatibles derrière, ou devriez-vous écrire un code JavaScript plus ancien pour rendre tous vos utilisateurs heureux ?

Entrez Babel. Babel est un **compilateur** : il prend du code écrit dans un standard, et le transpile en code écrit dans un autre standard.

Vous pouvez configurer Babel pour transpiler le JavaScript ES2017 moderne en syntaxe JavaScript ES5 :

```
[1, 2, 3].map(function(n) {
  return n + 1
})
```

Cela doit se produire au moment de la construction, vous devez donc configurer un flux de travail qui gère cela pour vous. [Webpack](https://flaviocopes.com/webpack/) est une solution courante.

(P.S. si tout ce truc _ES_ vous semble confus, voir plus sur les versions ES [dans le guide ECMAScript](https://flaviocopes.com/ecmascript/))

#### Installation de Babel

Babel s'installe facilement en utilisant [npm](https://flaviocopes.com/npm/), localement dans un projet :

```
npm install --save-dev @babel/core @babel/cli
```

Puisque npm vient maintenant avec `[npx](https://flaviocopes.com/node/npx/)`, les packages CLI installés localement peuvent être exécutés en tapant la commande dans le dossier du projet :

Nous pouvons donc exécuter Babel en tapant simplement

```
npx babel script.js
```

#### Un exemple de configuration Babel

Babel, tel quel, ne fait rien d'utile, vous devez le configurer et ajouter des plugins.

> [_Voici une liste des plugins Babel_](https://babeljs.io/docs/en/plugins)

Pour résoudre le problème dont nous avons parlé dans l'introduction (utilisation des fonctions fléchées dans tous les navigateurs), nous pouvons exécuter

```
npm install --save-dev \
    @babel/plugin-transform-es2015-arrow-functions
```

pour télécharger le package dans le dossier `node_modules` de notre application, puis nous devons ajouter

```json
{
  "plugins": ["transform-es2015-arrow-functions"]
}
```

au fichier `.babelrc` présent dans le dossier racine de l'application. Si vous n'avez pas ce fichier, vous créez simplement un fichier vide et y mettez ce contenu.

> _ASTUCE : Si vous n'avez jamais vu un fichier point (un fichier commençant par un point), cela peut sembler étrange au début car ce fichier peut ne pas apparaître dans votre gestionnaire de fichiers, car c'est un fichier caché._

Maintenant, si nous avons un fichier `script.js` avec ce contenu :

```jsx
var a = () => {};
var a = (b) => b;

const double = [1,2,3].map((num) => num * 2);
console.log(double); // [2,4,6]

var bob = {
  _name: "Bob",
  _friends: ["Sally", "Tom"],
  printFriends() {
    this._friends.forEach(f =>
      console.log(this._name + " knows " + f));
  }
};
console.log(bob.printFriends());
```

l'exécution de `babel script.js` produira le code suivant :

```jsx
var a = function () {};var a = function (b) {
  return b;
};

const double = [1, 2, 3].map(function (num) {
  return num * 2;
});
console.log(double); // [2,4,6]

var bob = {
  _name: "Bob",
  _friends: ["Sally", "Tom"],
  printFriends() {
    var _this = this;
    
    this._friends.forEach(function (f) {
      return console.log(_this._name + " knows " + f);
    });
  }
};
console.log(bob.printFriends());
```

Comme vous pouvez le voir, toutes les fonctions fléchées ont été converties en fonctions JavaScript ES5.

#### Préréglages Babel

Nous venons de voir dans l'article précédent comment Babel peut être configuré pour transpiler des fonctionnalités JavaScript spécifiques.

Vous pouvez ajouter beaucoup plus de plugins, mais vous ne pouvez pas ajouter les fonctionnalités de configuration une par une, ce n'est pas pratique.

C'est pourquoi Babel offre des **préréglages**.

Les préréglages les plus populaires sont `env` et `react`.

> _Astuce : Babel 7 a déprécié (et supprimé) les préréglages annuels comme `preset-es2017`, et les préréglages de stage. Utilisez `@babel/preset-env` à la place._

#### Préréglage `env`

Le préréglage `env` est très pratique : vous lui dites quels environnements vous souhaitez supporter, et il fait tout pour vous, **en supportant toutes les fonctionnalités modernes de JavaScript**.

Par exemple, "supporter les deux dernières versions de chaque navigateur, mais pour Safari, supportons toutes les versions depuis Safari 7"

```
{
  "presets": [
    ["env", {
      "targets": {
        "browsers": ["last 2 versions", "safari >= 7"]
      }
    }]
  ]
}
```

ou "Je n'ai pas besoin de support pour les navigateurs, laissez-moi simplement travailler avec [Node.js](https://flaviocopes.com/node/) 6.10"

```
{
  "presets": [
    ["env", {
      "targets": {
        "node": "6.10"
      }
    }]
  ]
}
```

#### Préréglage `react`

Le préréglage `react` est très pratique lorsque vous écrivez des applications React : ajout de `preset-flow`, `syntax-jsx`, `transform-react-jsx`, `transform-react-display-name`.

En l'incluant, vous êtes prêt à développer des applications React, avec des transformations JSX et le support de Flow.

#### Plus d'informations sur les préréglages

[https://babeljs.io/docs/plugins/](https://babeljs.io/docs/plugins/)

#### Utilisation de Babel avec webpack

Si vous souhaitez exécuter du JavaScript moderne dans le navigateur, Babel seul ne suffit pas, vous devez également bundler le code. Webpack est l'outil parfait pour cela.

Le JS moderne nécessite deux étapes différentes : une étape de compilation et une étape d'exécution. Cela est dû au fait que certaines fonctionnalités ES6+ nécessitent un polyfill ou un helper d'exécution.

Pour installer la fonctionnalité runtime de polyfill de Babel, exécutez

```
npm install @babel/polyfill \
            @babel/runtime \
            @babel/plugin-transform-runtime
```

Maintenant, dans votre fichier `webpack.config.js`, ajoutez :

```js
entry: [
  'babel-polyfill',
  // vos scripts d'application doivent être ici
],

module: {
  loaders: [
    // Le loader Babel compile ES2015 en ES5 pour
    // un support complet des navigateurs
    {
      loader: 'babel-loader',
      test: /\.js$/,
      // inclure uniquement les fichiers présents dans le sous-répertoire `src`
      include: [path.resolve(__dirname, "src")],
      // exclure node_modules, équivalent à la ligne ci-dessus
      exclude: /node_modules/,
      query: {
        // Utiliser le préréglage ES2015 par défaut
        // pour inclure toutes les fonctionnalités ES2015
        presets: ['es2015'],
        plugins: ['transform-runtime']
      }
    }
  ]
}
```

En gardant les informations sur les préréglages et les plugins à l'intérieur du fichier `webpack.config.js`, nous pouvons éviter d'avoir un fichier `.babelrc`.

### Webpack

Webpack est un outil qui vous permet de compiler des modules JavaScript, également connu sous le nom de **module bundler**. Étant donné un grand nombre de fichiers, il génère un seul fichier (ou quelques fichiers) qui exécute votre application.

Il peut effectuer de nombreuses opérations :

* vous aide à bundler vos ressources.
* surveille les changements et relance les tâches.
* peut exécuter la transpilation Babel en ES5, vous permettant d'utiliser les dernières fonctionnalités JavaScript sans vous soucier de la compatibilité avec les navigateurs.
* peut transpiler CoffeeScript en JavaScript
* peut convertir les images en ligne en URI de données.
* vous permet d'utiliser require() pour les fichiers CSS.
* peut exécuter un serveur web de développement.
* peut gérer le remplacement de modules à chaud.
* peut diviser les fichiers de sortie en plusieurs fichiers, pour éviter d'avoir un énorme fichier js à charger lors de la première visite de la page.
* peut effectuer du [tree shaking](https://flaviocopes.com/javascript-glossary/#tree-shaking).

Webpack n'est pas limité à une utilisation en frontend, il est également utile dans le développement backend Node.js.

Les prédécesseurs de webpack, et des outils encore largement utilisés, incluent :

* Grunt
* Broccoli
* Gulp

Il y a beaucoup de similitudes dans ce que ceux-ci et Webpack peuvent faire, mais la principale différence est que ceux-ci sont connus comme des **task runners**, tandis que webpack est né comme un module bundler.

C'est un outil plus ciblé : vous spécifiez un point d'entrée pour votre application (il pourrait même s'agir d'un fichier HTML avec des balises de script) et webpack analyse les fichiers et bundle tout ce dont vous avez besoin pour exécuter l'application dans un seul fichier JavaScript de sortie (ou dans plus de fichiers si vous utilisez le code splitting).

#### Installation de webpack

Webpack peut être installé globalement ou localement pour chaque projet.

#### Installation globale

Voici comment l'installer globalement avec [Yarn](https://flaviocopes.com/yarn/) :

```bash
yarn global add webpack webpack-cli
```

avec [npm](https://flaviocopes.com/npm/) :

```
npm i -g webpack webpack-cli
```

une fois cela fait, vous devriez pouvoir exécuter

```
webpack-cli
```

#### Installation locale

Webpack peut également être installé localement. C'est la configuration recommandée, car webpack peut être mis à jour par projet, et vous avez moins de résistance à utiliser les dernières fonctionnalités pour un petit projet plutôt que de mettre à jour tous les projets que vous avez qui utilisent webpack.

Avec [Yarn](https://flaviocopes.com/yarn/) :

```
yarn add webpack webpack-cli -D
```

avec [npm](https://flaviocopes.com/npm/) :

```
npm i webpack webpack-cli --save-dev
```

Une fois cela fait, ajoutez ceci à votre fichier `package.json` :

```
{
  //...
  "scripts": {
    "build": "webpack"
  }
}
```

une fois cela fait, vous pouvez exécuter webpack en tapant

```
yarn build
```

dans la racine du projet.

#### Configuration de Webpack

Par défaut, webpack (à partir de la version 4) ne nécessite aucune configuration si vous respectez ces conventions :

* le **point d'entrée** de votre application est `./src/index.js`
* la sortie est placée dans `./dist/main.js`.
* Webpack fonctionne en mode production

Vous pouvez bien sûr personnaliser chaque petit détail de webpack lorsque vous en avez besoin. La configuration de webpack est stockée dans le fichier `webpack.config.js`, dans le dossier racine du projet.

#### Le point d'entrée

Par défaut, le point d'entrée est `./src/index.js`. Cet exemple simple utilise le fichier `./index.js` comme point de départ :

```
module.exports = {
  /*...*/
  entry: './index.js'
  /*...*/
}
```

#### La sortie

Par défaut, la sortie est générée dans `./dist/main.js`. Cet exemple place le bundle de sortie dans `app.js` :

```
module.exports = {
  /*...*/
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.js'
  }
  /*...*/
}
```

#### Loaders

L'utilisation de webpack vous permet d'utiliser des instructions `import` ou `require` dans votre code JavaScript pour inclure non seulement d'autres fichiers JavaScript, mais aussi tout type de fichier, par exemple CSS.

Webpack vise à gérer toutes nos dépendances, pas seulement JavaScript, et les loaders sont un moyen de le faire.

Par exemple, dans votre code, vous pouvez utiliser :

```
import 'style.css'
```

en utilisant cette configuration de loader :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
    ]
  }
  /*...*/
}
```

L'[expression régulière](https://flaviocopes.com/javascript-regular-expressions/) cible tout fichier CSS.

Un loader peut avoir des options :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      }
    ]
  }
  /*...*/
}
```

Vous pouvez nécessiter plusieurs loaders pour chaque règle :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.css$/,
        use:
          [
            'style-loader',
            'css-loader',
          ]
      }
    ]
  }
  /*...*/
}
```
Dans cet exemple, `css-loader` interprète la directive `import 'style.css'` dans le CSS. `style-loader` est ensuite responsable de l'injection de ce CSS dans le DOM, en utilisant une balise `<style>`.

L'ordre est important, et il est inversé (le dernier est exécuté en premier).

Quels types de loaders existent-ils ? Beaucoup ! [Vous pouvez trouver la liste complète ici](https://webpack.js.org/loaders/).

Un loader couramment utilisé est Babel, qui est utilisé pour transpiler le JavaScript moderne en code ES5 :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  }
  /*...*/
}
```

Cet exemple fait en sorte que Babel préprocesse tous nos fichiers React/JSX :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  },
  resolve: {
    extensions: [
      '.js',
      '.jsx'
    ]
  }
  /*...*/
}
```

[Voir les options de `babel-loader` ici](https://webpack.js.org/loaders/babel-loader/).

#### Plugins

Les plugins sont comme des loaders, mais en plus puissants. Ils peuvent faire des choses que les loaders ne peuvent pas faire, et ils sont le principal bloc de construction de webpack.

Prenons cet exemple :

```
module.exports = {
  /*...*/
  plugins: [
    new HTMLWebpackPlugin()
  ]
  /*...*/
}
```

Le plugin `HTMLWebpackPlugin` a pour tâche de créer automatiquement un fichier HTML, en ajoutant le chemin du bundle JS de sortie, afin que le JavaScript soit prêt à être servi.

Il existe [de nombreux plugins disponibles](https://webpack.js.org/plugins/).

Un plugin utile, `CleanWebpackPlugin`, peut être utilisé pour vider le dossier `dist/` avant de créer une sortie, afin de ne pas laisser de fichiers lorsque vous changez le nom du fichier de sortie :

```
module.exports = {
  /*...*/
  plugins: [
    new CleanWebpackPlugin(['dist']),
  ]
  /*...*/
}
```

#### Le mode webpack

Ce mode (introduit dans webpack 4) définit l'environnement dans lequel webpack fonctionne. Il peut être défini sur `development` ou `production` (par défaut en production, donc vous ne le définissez que lorsque vous passez en développement)

```
module.exports = {
  entry: './index.js',
  mode: 'development',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.js'
  }
}
```

Mode développement :

* construit très rapidement
* est moins optimisé que la production
* ne supprime pas les commentaires
* fournit des messages d'erreur et des suggestions plus détaillés
* offre une meilleure expérience de débogage

Le mode production est plus lent à construire, car il doit générer un bundle plus optimisé. Le fichier JavaScript résultant est plus petit, car il supprime de nombreuses choses qui ne sont pas nécessaires en production.

J'ai créé une application d'exemple qui imprime simplement une instruction `console.log`.

Voici le bundle de production :

![Image](https://cdn-media-1.freecodecamp.org/images/kbXOiSFaO06VSDxcLC29Nh4a8ycSoaL9LDup)

Voici le bundle de développement :

![Image](https://cdn-media-1.freecodecamp.org/images/W-1sAge4rvYL0aH00e7FuyJ5NLv7PJYpves0)

#### Exécuter webpack

Webpack peut être exécuté manuellement depuis la ligne de commande s'il est installé globalement, mais généralement vous écrivez un script dans le fichier `package.json`, qui est ensuite exécuté en utilisant `npm` ou `yarn`.

Par exemple, cette définition de script `package.json` que nous avons utilisée précédemment :

```
"scripts": {
  "build": "webpack"
}
```

nous permet d'exécuter `webpack` en exécutant

```bash
npm run build
```

ou

```bash
yarn run build
```

ou simplement

```bash
yarn build
```

#### Surveillance des changements

Webpack peut reconstruire automatiquement le bundle lorsqu'un changement se produit dans votre application, et continuer à écouter le prochain changement.

Il suffit d'ajouter ce script :

```js
"scripts": {
  "watch": "webpack --watch"
}
```

et exécuter

```bash
npm run watch
```

ou

```bash
yarn run watch
```

ou simplement

```
yarn watch
```

Une fonctionnalité intéressante du mode watch est que le bundle n'est modifié que si la construction n'a pas d'erreurs. S'il y a des erreurs, `watch` continuera à écouter les changements et tentera de reconstruire le bundle, mais le bundle actuel et fonctionnel n'est pas affecté par ces constructions problématiques.

#### Gestion des images

Webpack nous permet d'utiliser des images de manière très pratique, en utilisant le loader `[file-loader](https://webpack.js.org/loaders/file-loader/)`.

Cette configuration simple :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          'file-loader'
        ]
      }
    ]
  }
  /*...*/
}
```

Vous permet d'importer des images dans votre JavaScript :

```
import Icon from './icon.png'

const img = new Image()
img.src = Icon
element.appendChild(img)
```

(`img` est un HTMLImageElement. Consultez la [documentation sur Image](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image))

`file-loader` peut également gérer d'autres types d'actifs, comme les polices, les fichiers CSV, XML, et plus encore.

Un autre outil pratique pour travailler avec les images est le loader `url-loader`.

Cet exemple charge tout fichier PNG de moins de 8 Ko sous forme d'[URL de données](https://flaviocopes.com/data-urls/).

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.png$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192
            }
          }
        ]
      }
    ]
  }
  /*...*/
}
```

#### Traiter votre code SASS et le transformer en CSS

En utilisant `sass-loader`, `css-loader` et `style-loader` :

```
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader'
        ]
      }
    ]
  }
  /*...*/
}
```

#### Générer des Source Maps

Puisque webpack regroupe le code, les Source Maps sont obligatoires pour obtenir une référence au fichier original qui a déclenché une erreur, par exemple.

Vous dites à webpack de générer des source maps en utilisant la propriété `devtool` de la configuration :

```
module.exports = {
  /*...*/
  devtool: 'inline-source-map',
  /*...*/
}
```

`devtool` a [de nombreuses valeurs possibles](https://webpack.js.org/configuration/devtool/), les plus utilisées sont probablement :

* `none` : n'ajoute pas de source maps
* `source-map` : idéal pour la production, fournit une source map séparée qui peut être minimisée, et ajoute une référence dans le bundle, afin que les outils de développement sachent que la source map est disponible. Bien sûr, vous devez configurer le serveur pour éviter de livrer cela, et l'utiliser uniquement à des fins de débogage
* `inline-source-map` : idéal pour le développement, intègre la source map sous forme d'URL de données

### SECTION 7 : TESTS

### Jest

Jest est une bibliothèque pour tester le code JavaScript.

C'est un projet open source maintenu par Facebook, et il est particulièrement bien adapté pour les tests de code React, bien qu'il ne soit pas limité à cela : il peut tester n'importe quel code JavaScript. Ses points forts sont :

* il est rapide
* il peut effectuer des **tests de snapshot**
* il est opiniâtre, et fournit tout ce dont vous avez besoin sans que vous ayez à faire des choix

Jest est un outil très similaire à Mocha, bien qu'ils aient des différences :

* Mocha est moins opiniâtre, tandis que Jest a un certain ensemble de conventions
* Mocha nécessite plus de configuration, tandis que Jest fonctionne généralement directement, grâce à son caractère opiniâtre
* Mocha est plus ancien et plus établi, avec plus d'intégrations d'outils

À mon avis, la plus grande fonctionnalité de Jest est qu'il s'agit d'une solution prête à l'emploi qui fonctionne sans avoir à interagir avec d'autres bibliothèques de test pour accomplir son travail.

#### Installation

Jest est automatiquement installé dans `create-react-app`, donc si vous utilisez cela, vous n'avez pas besoin d'installer Jest.

Jest peut être installé dans n'importe quel autre projet en utilisant [Yarn](https://flaviocopes.com/yarn/) :

```
yarn add --dev jest
```

ou [npm](https://flaviocopes.com/npm/) :

```
npm install --save-dev jest
```

remarquez comment nous instruisons les deux de placer Jest dans la partie `devDependencies` du fichier `package.json`, afin qu'il ne soit installé que dans l'environnement de développement et non en production.

Ajoutez cette ligne à la partie scripts de votre fichier `package.json` :

```
{
  "scripts": {
    "test": "jest"
  }
}
```

afin que les tests puissent être exécutés en utilisant `yarn test` ou `npm run test`.

Alternativement, vous pouvez installer Jest globalement :

```
yarn global add jest
```

et exécuter tous vos tests en utilisant l'outil de ligne de commande `jest`.

#### Créer le premier test Jest

Les projets créés avec `create-react-app` ont Jest installé et préconfiguré, mais ajouter Jest à n'importe quel projet est aussi simple que de taper

```
yarn add --dev jest
```

Ajoutez à votre `package.json` cette ligne :

```
{
  "scripts": {
    "test": "jest"
  }
}
```

et exécutez vos tests en exécutant `yarn test` dans votre shell.

Maintenant, vous n'avez aucun test ici, donc rien ne sera exécuté :

![Image](https://cdn-media-1.freecodecamp.org/images/QJ4lMCN6PhDyBBZ8mPyLmLciew9p9cUE9ug0)

Créons le premier test. Ouvrez un fichier `math.js` et tapez quelques fonctions que nous testerons plus tard :

```
const sum = (a, b) => a + b
const mul = (a, b) => a * b
const sub = (a, b) => a - b
const div = (a, b) => a / b

export default { sum, mul, sub, div }
```

Maintenant, créez un fichier `math.test.js`, dans le même dossier, et là nous utiliserons Jest pour tester les fonctions définies dans `math.js` :

```
const { sum, mul, sub, div } = require('./math')

test('Adding 1 + 1 equals 2', () => {
  expect(sum(1, 1)).toBe(2)
})
test('Multiplying 1 * 1 equals 1', () => {
  expect(mul(1, 1)).toBe(1)
})
test('Subtracting 1 - 1 equals 0', () => {
  expect(sub(1, 1)).toBe(0)
})
test('Dividing 1 / 1 equals 1', () => {
  expect(div(1, 1)).toBe(1)
})
```

L'exécution de `yarn test` entraîne l'exécution de Jest sur tous les fichiers de test qu'il trouve, et nous retourne le résultat final :

![Image](https://cdn-media-1.freecodecamp.org/images/vGSvRogM-QF8N3EP5j9vUYYrkWvRc89OhE98)

#### Exécuter Jest avec VS Code

Visual Studio Code est un excellent éditeur pour le développement JavaScript. L'[extension Jest](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest) offre une intégration de premier ordre pour nos tests.

Une fois que vous l'avez installée, elle détectera automatiquement si vous avez installé Jest dans vos devDependencies et exécutera les tests. Vous pouvez également invoquer les tests manuellement en sélectionnant la commande **Jest: Start Runner**. Elle exécutera les tests et restera en mode watch pour les réexécuter chaque fois que vous modifiez l'un des fichiers qui a un test (ou un fichier de test) :

![Image](https://cdn-media-1.freecodecamp.org/images/WYyCsxacP34Fss8u9jT5lT0u3O--1Uwz9cKW)

#### Matchers

Dans l'article précédent, j'ai utilisé `toBe()` comme seul **matcher** :

```
test('Adding 1 + 1 equals 2', () => {
  expect(sum(1, 1)).toBe(2)
})
```

Un matcher est une méthode qui vous permet de tester des valeurs.

Les matchers les plus couramment utilisés, comparant la valeur du résultat de `expect()` avec la valeur passée en argument, sont :

* `toBe` compare l'égalité stricte, en utilisant `===
* `toEqual` compare les valeurs de deux variables. Si c'est un objet ou un tableau, il vérifie l'égalité de toutes les propriétés ou éléments
* `toBeNull` est vrai lorsque l'on passe une valeur nulle
* `toBeDefined` est vrai lorsque l'on passe une valeur définie (opposé à ci-dessus)
* `toBeUndefined` est vrai lorsque l'on passe une valeur indéfinie
* `toBeCloseTo` est utilisé pour comparer les valeurs flottantes, en évitant les erreurs d'arrondi
* `toBeTruthy` vrai si la valeur est considérée comme vraie (comme un `if` le fait)
* `toBeFalsy` vrai si la valeur est considérée comme fausse (comme un `if` le fait)
* `toBeGreaterThan` vrai si le résultat de expect() est supérieur à l'argument
* `toBeGreaterThanOrEqual` vrai si le résultat de expect() est égal à l'argument, ou supérieur à l'argument
* `toBeLessThan` vrai si le résultat de expect() est inférieur à l'argument
* `toBeLessThanOrEqual` vrai si le résultat de expect() est égal à l'argument, ou inférieur à l'argument
* `toMatch` est utilisé pour comparer des chaînes avec une [expression régulière](https://flaviocopes.com/javascript-regular-expressions/) correspondant à un motif
* `toContain` est utilisé dans les tableaux, vrai si le tableau attendu contient l'argument dans son ensemble d'éléments
* `toHaveLength(number)` : vérifie la longueur d'un tableau
* `toHaveProperty(key, value)` : vérifie si un objet a une propriété, et vérifie optionnellement sa valeur
* `toThrow` vérifie si une fonction que vous passez lance une exception (en général) ou une exception spécifique
* `toBeInstanceOf()` : vérifie si un objet est une instance d'une classe

Tous ces matchers peuvent être niés en utilisant `.not.` dans l'instruction, par exemple :

```js
test('Adding 1 + 1 does not equal 3', () => {
  expect(sum(1, 1)).not.toBe(3)
})
```

Pour une utilisation avec les promesses, vous pouvez utiliser `.resolves` et `.rejects` :

```
expect(Promise.resolve('lemon')).resolves.toBe('lemon')

expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus')
```

#### Configuration

Avant d'exécuter vos tests, vous voudrez effectuer une initialisation.

Pour faire quelque chose une fois avant que tous les tests ne s'exécutent, utilisez la fonction `beforeAll()` :

```
beforeAll(() => {
  //do something
})
```

Pour effectuer quelque chose avant chaque test, utilisez `beforeEach()` :

```
beforeEach(() => {
  //do something
})
```

#### Nettoyage

Tout comme vous pouvez le faire avec la configuration, vous pouvez également effectuer quelque chose après chaque test :

```
afterEach(() => {
  //do something
})
```

et après que tous les tests se terminent :

```
afterAll(() => {
  //do something
})
```

#### Regrouper les tests en utilisant describe()

Vous pouvez créer des groupes de tests, dans un seul fichier, qui isolent les fonctions de configuration et de nettoyage :

```
describe('first set', () => {
  beforeEach(() => {
    //do something
  })
  afterAll(() => {
    //do something
  })
  test(/*...*/)
  test(/*...*/)
})

describe('second set', () => {
  beforeEach(() => {
    //do something
  })
  beforeAll(() => {
    //do something
  })
  test(/*...*/)
  test(/*...*/)
}) 
```

#### Tester le code asynchrone

Le code asynchrone en JavaScript moderne peut avoir essentiellement 2 formes : les callbacks et les promesses. Sur les promesses, nous pouvons utiliser async/await.

#### Callbacks

Vous ne pouvez pas avoir un test dans un callback, car Jest ne l'exécutera pas — l'exécution du fichier de test se termine avant que le callback ne soit appelé. Pour corriger cela, passez un paramètre à la fonction de test, que vous pouvez appeler `done`. Jest attendra que vous appeliez `done()` avant de terminer ce test :

```
//uppercase.js
function uppercase(str, callback) {
  callback(str.toUpperCase())
}
module.exports = uppercase

//uppercase.test.js
const uppercase = require('./src/uppercase')

test(`uppercase 'test' to equal 'TEST'`, (done) => {
  uppercase('test', (str) => {
    expect(str).toBe('TEST')
    done()
  }
})
```

![Image](https://cdn-media-1.freecodecamp.org/images/wsyP30ZeaXYM6LTu4UOiTIg4cFjUOo4GtutV)

#### Promesses

Avec des fonctions qui retournent des promesses, nous retournons simplement une promesse depuis le test :

```
//uppercase.js
const uppercase = str => {
  return new Promise((resolve, reject) => {
    if (!str) {
      reject('Empty string')
      return
    }
    resolve(str.toUpperCase())
  })
}
module.exports = uppercase

//uppercase.test.js
const uppercase = require('./uppercase')
test(`uppercase 'test' to equal 'TEST'`, () => {
  return uppercase('test').then(str => {
    expect(str).toBe('TEST')
  })
})
```

![Image](https://cdn-media-1.freecodecamp.org/images/8j7LKC8uKE5Tw0X4WN4Gm0rD3NziyPxNwyCn)

Les promesses qui sont rejetées peuvent être testées en utilisant `.catch()` :

```
//uppercase.js
const uppercase = str => {
  return new Promise((resolve, reject) => {
    if (!str) {
      reject('Empty string')
      return
    }
    resolve(str.toUpperCase())
  })
}

module.exports = uppercase

//uppercase.test.js
const uppercase = require('./uppercase')

test(`uppercase 'test' to equal 'TEST'`, () => {
  return uppercase('').catch(e => {
    expect(e).toMatch('Empty string')
  })
})
```

![Image](https://cdn-media-1.freecodecamp.org/images/F9HWCuZKWwG1RMZdNkDAaGMRsC0zaIsMokia)

#### Async/await

Pour tester les fonctions qui retournent des promesses, nous pouvons également utiliser async/await, ce qui rend la syntaxe très simple et directe :

```
//uppercase.test.js
const uppercase = require('./uppercase')
test(`uppercase 'test' to equal 'TEST'`, async () => {
  const str = await uppercase('test')
  expect(str).toBe('TEST')
})
```

![Image](https://cdn-media-1.freecodecamp.org/images/7xWQMgM0PC9AGUBewAzcCgNWvHIjjxerfRxR)

#### Mocking

Dans les tests, le **mocking** vous permet de tester des fonctionnalités qui dépendent de :

* **Base de données**
* Requêtes **Réseau**
* Accès aux **Fichiers**
* Tout système **Externe**

afin que :

1. vos tests s'exécutent **plus rapidement**, offrant un temps de réponse rapide pendant le développement
2. vos tests sont **indépendants** des conditions réseau, ou de l'état de la base de données
3. vos tests ne **polluent** aucun stockage de données car ils ne touchent pas la base de données
4. tout changement effectué dans un test ne modifie pas l'état pour les tests suivants, et la réexécution de la suite de tests doit commencer à partir d'un point de départ connu et reproductible
5. vous n'avez pas à vous soucier de la limitation de taux sur les appels d'API et les requêtes réseau

Le mocking est utile lorsque vous souhaitez éviter les effets secondaires (par exemple, écrire dans une base de données) ou que vous souhaitez sauter des portions de code lentes (comme l'accès au réseau), et évite également les implications de l'exécution de vos tests plusieurs fois (par exemple, imaginez une fonction qui envoie un e-mail ou appelle une API limitée en taux).

Encore plus important, si vous écrivez un **test unitaire**, vous devez tester la fonctionnalité d'une fonction de manière isolée, et non avec tout ce qu'elle touche.

En utilisant des mocks, vous pouvez inspecter si une fonction de module a été appelée et quels paramètres ont été utilisés, avec :

* `expect().toHaveBeenCalled()` : vérifie si une fonction espionnée a été appelée
* `expect().toHaveBeenCalledTimes()` : compte combien de fois une fonction espionnée a été appelée
* `expect().toHaveBeenCalledWith()` : vérifie si la fonction a été appelée avec un ensemble spécifique de paramètres
* `expect().toHaveBeenLastCalledWith()` : vérifie les paramètres de la dernière fois que la fonction a été invoquée

#### Espionner des packages sans affecter le code des fonctions

Lorsque vous importez un package, vous pouvez dire à Jest d'« espionner » l'exécution d'une fonction particulière, en utilisant `spyOn()`, sans affecter le fonctionnement de cette méthode.

Exemple :

```
const mathjs = require('mathjs')

test(`The mathjs log function`, () => {
  const spy = jest.spyOn(mathjs, 'log')
  const result = mathjs.log(10000, 10)
  
  expect(mathjs.log).toHaveBeenCalled()
  expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})
```

#### Mock un package entier

Jest fournit un moyen pratique de mock un package entier. Créez un dossier `__mocks__` à la racine du projet, et dans ce dossier créez un fichier JavaScript pour chacun de vos packages.

Supposons que vous importiez `mathjs`. Créez un fichier `__mocks__/mathjs.js` à la racine de votre projet, et ajoutez ce contenu :

```
module.exports = {
  log: jest.fn(() => 'test')
}
```

Cela mockera la fonction log() du package. Ajoutez autant de fonctions que vous souhaitez mock :

```
const mathjs = require('mathjs')

test(`The mathjs log function`, () => {
  const result = mathjs.log(10000, 10)
  expect(result).toBe('test')
  expect(mathjs.log).toHaveBeenCalled()
  expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})
```

#### Mock une seule fonction

Plus simplement, vous pouvez mock une seule fonction en utilisant `jest.fn()` :

```
const mathjs = require('mathjs')

mathjs.log = jest.fn(() => 'test')
test(`The mathjs log function`, () => {
  const result = mathjs.log(10000, 10)
  expect(result).toBe('test')
  expect(mathjs.log).toHaveBeenCalled()
  expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})
```

Vous pouvez également utiliser `jest.fn().mockReturnValue('test')` pour créer un mock simple qui ne fait rien sauf retourner une valeur.
#### Mocks pré-construits

Vous pouvez trouver des mocks pré-construits pour les bibliothèques populaires. Par exemple, ce package [https://github.com/jefflau/jest-fetch-mock](https://github.com/jefflau/jest-fetch-mock) vous permet de mock les appels `fetch()`, et de fournir des valeurs de retour d'exemple sans interagir avec le serveur réel dans vos tests.

#### Tests de snapshot

Les tests de snapshot sont une fonctionnalité assez cool offerte par Jest. Il peut mémoriser comment vos composants UI sont rendus, et les comparer au test actuel, en levant une erreur s'il y a une incompatibilité.

Voici un test simple sur le composant App d'une application `create-react-app` simple (assurez-vous d'installer `react-test-renderer`) :

```
import React from 'react'
import App from './App'
import renderer from 'react-test-renderer'

it('renders correctly', () => {
  const tree = renderer.create(<App />).toJSON()
  expect(tree).toMatchSnapshot()
})
```

La première fois que vous exécutez ce test, Jest sauvegarde le snapshot dans le dossier `__snapshots__`. Voici ce que contient App.test.js.snap :

```js
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div
  className="App"
>
  <header
    className="App-header"
  >
    <img
      alt="logo"
      className="App-logo"
      src="logo.svg"
    />
    <h1
      className="App-title"
    >
      Welcome to React
    </h1>
  </header>
  <p
    className="App-intro"
  >
    To get started, edit
    <code>
      src/App.js
    </code>
     and save to reload.
  </p>
</div>
`
```

Comme vous pouvez le voir, il s'agit du code que le composant App rend, rien de plus.

La prochaine fois, le test compare la sortie de `<App` /> à ceci. Si App change, vous obtenez une erreur :

![Image](https://cdn-media-1.freecodecamp.org/images/imS-QSkC1rmVVRYLkLYSJrGk5b3DOjodEJkx)

Lorsque vous utilisez `yarn test` dans `create-react-app`, vous êtes en **mode watch**, et à partir de là, vous pouvez appuyer sur `w` et afficher plus d'options :

```bash
Watch Usage
  Press u to update failing snapshots.
  Press p to filter by a filename regex pattern.
  Press t to filter by a test name regex pattern.
  Press q to quit watch mode.
  Press Enter to trigger a test run.
```

Si votre changement est intentionnel, appuyer sur `u` mettra à jour les snapshots échoués, et fera passer le test.

Vous pouvez également mettre à jour le snapshot en exécutant `jest -u` (ou `jest --updateSnapshot`) en dehors du mode watch.

### Tester les composants React

La manière la plus simple de commencer à tester les composants React est de faire des tests de snapshot, une technique de test qui vous permet de tester les composants en isolation.

Si vous êtes familier avec les tests logiciels, c'est comme les tests unitaires que vous faites pour les classes : vous testez chaque fonctionnalité du composant.

Je suppose que vous avez créé une application React avec `create-react-app`, qui vient déjà avec **Jest** installé, le package de test dont nous aurons besoin.

Commençons par un test simple. CodeSandbox est un excellent environnement pour essayer cela. Commencez avec un sandbox React, et créez un composant `App.js` dans un dossier `components`, et ajoutez un fichier `App.test.js`.

```
import React from 'react'

export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  )
}
```

Notre premier test est simple :

```
test('First test', () => {
  expect(true).toBeTruthy()
})
```

Lorsque CodeSandbox détecte des fichiers de test, il les exécute automatiquement pour vous, et vous pouvez cliquer sur le bouton Tests en bas de la vue pour afficher vos résultats de test :

![Image](https://cdn-media-1.freecodecamp.org/images/DKFPyZSWF0O2ldKLAMyz7i0Di9NLqMs-ChQ4)

Un fichier de test peut contenir plusieurs tests :

![Image](https://cdn-media-1.freecodecamp.org/images/iWZgjKzyxhyAtvjpsyTTEpzs4pKot938aVjk)

Faisons quelque chose d'un peu plus utile maintenant, pour tester réellement un composant React. Nous n'avons que App pour l'instant, qui ne fait pas grand-chose d'utile, alors commençons par configurer l'environnement avec une petite application avec plus de fonctionnalités : l'application de compteur que nous avons construite précédemment. Si vous l'avez sautée, vous pouvez revenir en arrière et lire comment nous l'avons construite, mais pour une référence plus facile, je l'ajoute ici à nouveau.

Il s'agit simplement de 2 composants : App et Button. Créez le fichier `App.js` :

```
import React, { useState } from 'react'
import Button from './Button'

const App = () => {
  const [count, setCount] = useState(0)
  
  const incrementCount = increment => {
    setCount(count + increment)
  }
  
  return (
    <div>
      <Button increment={1} onClickFunction={incrementCount} />
      <Button increment={10} onClickFunction={incrementCount} />
      <Button increment={100} onClickFunction={incrementCount} />
      <Button increment={1000} onClickFunction={incrementCount} />
      <span>{count}</span>
    </div>
  )
}

export default App
```

et le fichier `Button.js` :

```
import React from 'react'

const Button = ({ increment, onClickFunction }) => {
  const handleClick = () => {
    onClickFunction(increment)
  }
  return <button onClick={handleClick}>+{increment}</button>
}

export default Button
```

Nous allons utiliser `react-testing-library`, qui est d'une grande aide car il nous permet d'inspecter la sortie de chaque composant et d'appliquer des événements sur eux. Vous pouvez en lire plus à ce sujet sur [https://github.com/kentcdodds/react-testing-library](https://github.com/kentcdodds/react-testing-library) ou regarder [cette vidéo](https://www.youtube.com/watch?v=JKOwJUM4_RM).

Testons d'abord le composant Button.

Nous commençons par importer `render` et `fireEvent` de `react-testing-library`, deux helpers. Le premier nous permet de rendre du JSX. Le second nous permet d'émettre des événements sur un composant.

Créez un `Button.test.js` et placez-le dans le même dossier que `Button.js`.

```
import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import Button from './Button'
```

Les boutons sont utilisés dans l'application pour accepter un événement de clic et ensuite ils appellent une fonction passée à la prop `onClickFunction`. Nous ajoutons une variable `count` et nous créons une fonction qui l'incrémente :

```
let count

const incrementCount = increment => {
  count += increment
}
```

Maintenant, passons aux tests réels. Nous initialisons d'abord count à 0, et nous rendons un composant `+1` `Button` en passant un `1` à `increment` et notre fonction `incrementCount` à `onClickFunction`.

Ensuite, nous obtenons le contenu du premier enfant du composant, et nous vérifions qu'il affiche `+1`.

Nous procédons ensuite au clic sur le bouton, et nous vérifions que le compte est passé de 0 à 1 :

```
test('+1 Button works', () => {
  count = 0
  const { container } = render(
    <Button increment={1} onClickFunction={incrementCount} />
  )
  const button = container.firstChild
  expect(button.textContent).toBe('+1')
  expect(count).toBe(0)
  fireEvent.click(button)
  expect(count).toBe(1)
})
```

De manière similaire, nous testons un bouton +100, cette fois en vérifiant que la sortie est `+100` et que le clic sur le bouton incrémente le compte de 100.

```js
test('+100 Button works', () => {
  count = 0
  const { container } = render(
    <Button increment={100} onClickFunction={incrementCount} />
  )
  const button = container.firstChild
  expect(button.textContent).toBe('+100')
  expect(count).toBe(0)
  fireEvent.click(button)
  expect(count).toBe(100)
})
```

Testons maintenant le composant App. Il affiche 4 boutons et le résultat dans la page. Nous pouvons inspecter chaque bouton et voir si le résultat augmente lorsque nous cliquons dessus, en cliquant plusieurs fois également :

```
import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import App from './App'

test('App works', () => {
  const { container } = render(<App />)
  console.log(container)
  const buttons = container.querySelectorAll('button')
  
  expect(buttons[0].textContent).toBe('+1')
  expect(buttons[1].textContent).toBe('+10')
  expect(buttons[2].textContent).toBe('+100')
  expect(buttons[3].textContent).toBe('+1000')
  
  const result = container.querySelector('span')
  expect(result.textContent).toBe('0')
  fireEvent.click(buttons[0])
  expect(result.textContent).toBe('1')
  fireEvent.click(buttons[1])
  expect(result.textContent).toBe('11')
  fireEvent.click(buttons[2])
  expect(result.textContent).toBe('111')
  fireEvent.click(buttons[3])
  expect(result.textContent).toBe('1111')
  fireEvent.click(buttons[2])
  expect(result.textContent).toBe('1211')
  fireEvent.click(buttons[1])
  expect(result.textContent).toBe('1221')
  fireEvent.click(buttons[0])
  expect(result.textContent).toBe('1222')
})
```

Vérifiez le code fonctionnant sur ce CodeSandbox : [https://codesandbox.io/s/pprl4y0wq](https://codesandbox.io/s/pprl4y0wq)

### SECTION 8 : L'ÉCOSYSTÈME REACT

L'écosystème autour de React est énorme. Ici, je vous présente 4 des projets les plus populaires basés sur React : React Router, Redux, Next.js, Gatsby.

### React Router

React Router est la bibliothèque de routage React de facto, et c'est l'un des projets les plus populaires construits sur React.

React, à sa base, est une bibliothèque très simple, et elle ne dicte rien sur le routage.

Le routage dans une Single Page Application est la manière d'introduire certaines fonctionnalités pour naviguer dans l'application via des liens, qui sont **attendus** dans les applications web normales :

1. Le navigateur doit **changer l'URL** lorsque vous naviguez vers un écran différent
2. Le **Deep linking** doit fonctionner : si vous pointez le navigateur vers une URL, l'application doit reconstruire la même vue qui était présentée lorsque l'URL a été générée.
3. Le bouton **retour (et avant) du navigateur** doit fonctionner comme prévu.

**Le routage relie la navigation de votre application aux fonctionnalités de navigation offertes par le navigateur** : la **barre d'adresse** et les **boutons de navigation**.

React Router offre un moyen d'écrire votre code de sorte que **il affichera certains composants de votre application uniquement si la route correspond à ce que vous définissez**.

### Installation

Avec [npm](https://flaviocopes.com/npm/) :

```
npm install react-router-dom
```

Avec [Yarn](https://flaviocopes.com/yarn/) :

```bash
yarn add react-router-dom
```

### Types de routes

React Router fournit deux types de routes différents :

* `BrowserRouter`
* `HashRouter`

L'un construit des URL classiques, l'autre construit des URL avec le hash :

```
https://application.com/dashboard   /* BrowserRouter */
https://application.com/#/dashboard /* HashRouter    */
```

Le choix de l'un ou de l'autre est principalement dicté par les navigateurs que vous devez supporter. `BrowserRouter` utilise l'[History API](https://flaviocopes.com/history-api/), qui est relativement récente, et non supportée dans IE9 et les versions antérieures. Si vous n'avez pas à vous soucier des anciens navigateurs, c'est le choix recommandé.

### Composants

Les 3 composants avec lesquels vous interagirez le plus lorsque vous travaillerez avec React Router sont :

* `BrowserRouter`, généralement aliasé comme `Router`
* `Link`
* `Route`

`BrowserRouter` enveloppe tous vos composants Route.

Les composants `Link` sont - comme vous pouvez l'imaginer - utilisés pour générer des liens vers vos routes

Les composants `Route` sont responsables de l'affichage - ou du masquage - des composants qu'ils contiennent.

### BrowserRouter

Voici un exemple simple du composant BrowserRouter. Vous l'importez depuis react-router-dom, et vous l'utilisez pour envelopper toute votre application :

```jsx
import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router } from 'react-router-dom'

ReactDOM.render(
  <Router>
      <div>
        <!-- -->
      </div>
  </Router>,
  document.getElementById('app')
)
```

Un composant BrowserRouter ne peut avoir qu'un seul élément enfant, donc nous enveloppons tout ce que nous allons ajouter dans un élément `div`.

### Link

Le composant Link est utilisé pour déclencher de nouvelles routes. Vous l'importez depuis `react-router-dom`, et vous pouvez ajouter les composants Link pour pointer vers différentes routes, avec l'attribut `to` :

```
import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Link } from 'react-router-dom'

ReactDOM.render(
  <Router>
      <div>
        <aside>
          <Link to={`/dashboard`}>Dashboard</Link>
          <Link to={`/about`}>About</Link>
        </aside>
        <!-- -->
      </div>
  </Router>,
  document.getElementById('app')
)
```

### Route

Maintenant, ajoutons le composant Route dans l'extrait ci-dessus pour que les choses fonctionnent comme nous le voulons :

```
import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Link, Route } from 'react-router-dom'

const Dashboard = () => (
  <div>
    <h2>Dashboard</h2>
    ...
  </div>
)

const About = () => (
  <div>
    <h2>About</h2>
    ...
  </div>
)

ReactDOM.render(
  <Router>
    <div>
      <aside>
        <Link to={`/`}>Dashboard</Link>
        <Link to={`/about`}>About</Link>
      </aside>
      
      <main>
        <Route exact path="/" component={Dashboard} />
        <Route path="/about" component={About} />
      </main>
    </div>
  </Router>,
  document.getElementById('app')
)
```

Vérifiez cet exemple sur Glitch : [https://flaviocopes-react-router-v4.glitch.me/](https://flaviocopes-react-router-v4.glitch.me/)

Lorsque la route correspond à `/`, l'application affiche le composant **Dashboard**.

Lorsque la route est changée en cliquant sur le lien "About" vers `/about`, le composant Dashboard est supprimé et le composant **About** est inséré dans le DOM.

Remarquez l'attribut `exact`. Sans cela, `path="/"` correspondrait également à `/about`, puisque `/` est contenu dans la route.

### Correspondre à plusieurs chemins

Vous pouvez avoir une route répondre à plusieurs chemins simplement en utilisant une regex, car `path` peut être une chaîne d'expressions régulières :

```
<Route path="/(about|who)/" component={Dashboard} />
```

### Rendu en ligne

Au lieu de spécifier une propriété `component` sur `Route`, vous pouvez définir une prop `render` :

```jsx
<Route
  path="/(about|who)/"
  render={() => (
    <div>
      <h2>About</h2>
      ...
    </div>
  )}
/>
```

### Correspondre à un paramètre de route dynamique

Vous avez déjà vu comment utiliser des routes statiques comme

```
const Posts = () => (
  <div>
    <h2>Posts</h2>
    ...
  </div>
)

//...

<Route exact path="/posts" component={Posts} />
```

Voici comment gérer les routes dynamiques :

```
const Post = ({match}) => (
  <div>
    <h2>Post #{match.params.id}</h2>
    ...
  </div>
)

//...

<Route exact path="/post/:id" component={Post} />
```

Dans votre composant Route, vous pouvez rechercher les paramètres dynamiques dans `match.params`.

`match` est également disponible dans les routes rendues en ligne, et cela est particulièrement utile dans ce cas, car nous pouvons utiliser le paramètre `id` pour rechercher les données du post dans notre source de données avant de rendre Post :

```
const posts = [
  { id: 1, title: 'First', content: 'Hello world!' },
  { id: 2, title: 'Second', content: 'Hello again!' }
]

const Post = ({post}) => (
  <div>
    <h2>{post.title}</h2>
    {post.content}
  </div>
)

//...

<Route exact path="/post/:id" render={({match}) => (
  <Post post={posts.find(p => p.id === match.params.id)} />
)} />
```

### Redux

Redux est un gestionnaire d'état qui est généralement utilisé avec React, mais il n'est pas lié à cette bibliothèque — il peut être utilisé avec d'autres technologies également, mais nous nous en tiendrons à React pour le bien de l'explication.

Redux est un moyen de gérer l'état d'une application, et de le déplacer vers un **store global externe**.

Il y a quelques concepts à comprendre, mais une fois que vous les avez compris, Redux est une approche très simple au problème.

Redux est très populaire avec les applications React, mais il n'est en aucun cas unique à React : il existe des liaisons pour presque tous les frameworks populaires. Cela dit, je vais faire quelques exemples en utilisant React car c'est son cas d'utilisation principal.

#### Quand utiliser Redux ?

Redux est idéal pour les applications moyennes à grandes, et vous ne devriez l'utiliser que lorsque vous avez des difficultés à gérer l'état avec la gestion d'état par défaut de React, ou l'autre bibliothèque que vous utilisez.

Les applications simples ne devraient pas en avoir besoin du tout (et il n'y a rien de mal avec les applications simples).

#### Arbre d'état immuable

Dans Redux, l'état entier de l'application est représenté par **un** objet [JavaScript](https://flaviocopes.com/javascript/), appelé **State** ou **State Tree**.

Nous l'appelons **Immutable State Tree** parce qu'il est en lecture seule : il ne peut pas être changé directement.

Il ne peut être changé qu'en dispatchant une **Action**.

#### Actions

Une **Action** est **un objet JavaScript qui décrit un changement de manière minimale** (avec juste les informations nécessaires) :

```js
{
  type: 'CLICKED_SIDEBAR'
}

// e.g. avec plus de données
{
  type: 'SELECTED_USER',
  userId: 232
}
```

La seule exigence d'un objet action est d'avoir une propriété `type`, dont la valeur est généralement une chaîne de caractères.

#### Les types d'actions doivent être des constantes

Dans une application simple, un type d'action peut être défini comme une chaîne de caractères, comme je l'ai fait dans l'exemple de la leçon précédente.

Lorsque l'application grandit, il est préférable d'utiliser des constantes :

```
const ADD_ITEM = 'ADD_ITEM'
const action = { type: ADD_ITEM, title: 'Third item' }
```

et de séparer les actions dans leurs propres fichiers, et de les importer

```
import { ADD_ITEM, REMOVE_ITEM } from './actions'
```

#### Créateurs d'actions

Les **Créateurs d'Actions** sont des fonctions qui créent des actions.

```
function addItem(t) {
  return {
    type: ADD_ITEM,
    title: t
  }
}
```

Vous exécutez généralement les créateurs d'actions en combinaison avec le déclenchement du dispatcher :

```
dispatch(addItem('Milk'))
```

ou en définissant une fonction de dispatcher d'action :

```
const dispatchAddItem = i => dispatch(addItem(i))
dispatchAddItem('Milk')
```

#### Réducteurs

Lorsque une action est déclenchée, quelque chose doit se passer, l'état de l'application doit changer.

C'est le travail des **réducteurs**.

Un **réducteur** est une **fonction pure** qui calcule le prochain State Tree basé sur le State Tree précédent, et l'action dispatchée.

```jsx
;(currentState, action) => newState
```

Une fonction pure prend une entrée et retourne une sortie sans changer l'entrée ou autre chose. Ainsi, un réducteur retourne un objet State Tree complètement nouveau qui remplace le précédent.

#### Ce qu'un réducteur ne doit pas faire

Un réducteur doit être une fonction pure, donc il doit :

* ne jamais muter ses arguments
* ne jamais muter l'état, mais plutôt en créer un nouveau avec `Object.assign({}, ...)`
* ne jamais générer d'effets secondaires (aucun appel d'API changeant quoi que ce soit)
* ne jamais appeler de fonctions non pures, des fonctions qui changent leur sortie en fonction de facteurs autres que leur entrée (par exemple, `Date.now()` ou `Math.random()`)

Il n'y a pas de renforcement, mais vous devez respecter les règles.

#### Plusieurs réducteurs

Puisque l'état d'une application complexe pourrait être très large, il n'y a pas un seul réducteur, mais de nombreux réducteurs pour chaque type d'action.

#### Une simulation d'un réducteur

À sa base, Redux peut être simplifié avec ce modèle simple :

#### L'état

```
{
  list: [
    { title: "First item" },
    { title: "Second item" },
  ],
  title: 'Groceries list'
}
```

#### Une liste d'actions

```
{ type: 'ADD_ITEM', title: 'Third item' }
{ type: 'REMOVE_ITEM', index: 1 }
{ type: 'CHANGE_LIST_TITLE', title: 'Road trip list' }
```

#### Un réducteur pour chaque partie de l'état

```
const title = (state = '', action) => {
    if (action.type === 'CHANGE_LIST_TITLE') {
      return action.title
    } else {
      return state
    }
}

const list = (state = [], action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      return state.concat([{ title: action.title }])
    case 'REMOVE_ITEM':
      return state.map((item, index) =>
        action.index === index
          ? { title: item.title }
          : item
    default:
      return state
  }
}
```

#### Un réducteur pour l'état entier

```
const listManager = (state = {}, action) => {
  return {
    title: title(state.title, action),
    list: list(state.list, action)
  }
}
```

#### Le Store

Le **Store** est un objet qui :

* **conserve l'état** de l'application
* **expose l'état** via `getState()`
* permet de **mettre à jour l'état** via `dispatch()`
* permet de (dés)enregistrer un **écouteur de changement d'état** en utilisant `subscribe()`

Un store est **unique** dans l'application.

Voici comment un store pour l'application listManager est créé :

```
import { createStore } from 'redux'
import listManager from './reducers'
let store = createStore(listManager)
```

#### Puis-je initialiser le store avec des données côté serveur ?

Bien sûr, **il suffit de passer un état initial** :

```
let store = createStore(listManager, preexistingState)
```

#### Obtenir l'état

```
store.getState()
```

#### Mettre à jour l'état

```
store.dispatch(addItem('Something'))
```

#### Écouter les changements d'état

```
const unsubscribe = store.subscribe(() =>
  const newState = store.getState()
)

unsubscribe()
```

#### Flux de données

Le flux de données dans Redux est toujours **unidirectionnel**.

Vous appelez `dispatch()` sur le Store, en passant une Action.

Le Store se charge de transmettre l'Action au Réducteur, générant le prochain État.

Le Store met à jour l'État et alerte tous les Écouteurs.

### Next.js

Travailler sur une application moderne [JavaScript](https://flaviocopes.com/javascript/) alimentée par [React](https://flaviocopes.com/react/) est génial jusqu'à ce que vous réalisiez qu'il y a quelques problèmes liés au rendu de tout le contenu côté client.

Premièrement, la page prend plus de temps à devenir visible pour l'utilisateur, car avant que le contenu ne se charge, tout le JavaScript doit se charger, et votre application doit s'exécuter pour déterminer ce qu'il faut afficher sur la page.

Deuxièmement, si vous construisez un site web public, vous avez un problème de SEO de contenu. Les moteurs de recherche s'améliorent pour exécuter et indexer les applications JavaScript, mais c'est beaucoup mieux si nous pouvons leur envoyer du contenu au lieu de les laisser le découvrir.

La solution à ces deux problèmes est le **rendu côté serveur**, également appelé **pré-rendu statique**.

Next.js est l'un des frameworks React pour faire tout cela de manière très simple, mais il n'est pas limité à cela. Il est présenté par ses créateurs comme un **outil de chaîne de construction à configuration zéro, à commande unique pour les applications React**.

Il fournit une structure commune qui vous permet de construire facilement une application frontend React, et de gérer transparemment le rendu côté serveur pour vous.

Voici une liste non exhaustive des principales fonctionnalités de Next.js :

* **Rechargement à chaud du code** : Next.js recharge la page lorsqu'il détecte tout changement sauvegardé sur le disque.
* **Routage automatique** : toute URL est mappée au système de fichiers, aux fichiers placés dans le dossier `pages`, et vous n'avez besoin d'aucune configuration (vous avez bien sûr des options de personnalisation).
* **Composants en fichier unique** : en utilisant [styled-jsx](https://github.com/zeit/styled-jsx), complètement intégré comme construit par la même équipe, il est trivial d'ajouter des styles limités au composant.
* **Rendu côté serveur** : vous pouvez (optionnellement) rendre les composants React côté serveur, avant d'envoyer le HTML au client.
* **Compatibilité avec l'écosystème** : Next.js s'intègre bien avec le reste de l'écosystème JavaScript, Node et React.
* **Fractionnement automatique du code** : les pages sont rendues avec uniquement les bibliothèques et le JavaScript dont elles ont besoin, pas plus.
* **Préchargement** : le composant `Link`, utilisé pour lier différentes pages, prend en charge une propriété `prefetch` qui précharge automatiquement les ressources de la page (y compris le code manquant dû au fractionnement du code) en arrière-plan.
* **Composants dynamiques** : vous pouvez importer des modules JavaScript et des composants React dynamiquement ([https://github.com/zeit/next.js#dynamic-import](https://github.com/zeit/next.js#dynamic-import)).
* **Exportations statiques** : en utilisant la commande `next export`, Next.js vous permet d'exporter un site entièrement statique à partir de votre application.

#### Installation

Next.js prend en charge toutes les principales plateformes : Linux, macOS, Windows.

Un projet Next.js est facilement démarré avec npm :

```
npm install next react react-dom
```

ou avec [Yarn](https://flaviocopes.com/yarn/) :

```
yarn add next react react-dom
```

#### Premiers pas

Créez un fichier `package.json` avec ce contenu :

```
{
  "scripts": {
    "dev": "next"
  }
}
```

Si vous exécutez cette commande maintenant :

```
npm run dev
```

le script générera une erreur se plaignant de ne pas trouver le dossier `pages`. C'est la seule chose dont Next.js a besoin pour fonctionner.

Créez un dossier `pages` vide, et exécutez à nouveau la commande, et Next.js démarrera un serveur sur `localhost:3000`.

Si vous allez à cette URL maintenant, vous serez accueilli par une page 404 conviviale, avec un design propre et agréable.

![Image](https://cdn-media-1.freecodecamp.org/images/wBBqzsveZC9evvtqiPb6yrFav9V5UjExd0HE)

Next.js gère également d'autres types d'erreurs, comme les erreurs 500 par exemple.

#### Créer une page

Dans le dossier `pages`, créez un fichier `index.js` avec un simple composant fonctionnel React :

```
export default () => (
  <div>
    <p>Hello World!</p>
  </div>
)
```

Si vous visitez `localhost:3000`, ce composant sera automatiquement rendu.

Pourquoi est-ce si simple ?

Next.js utilise une structure de pages déclarative, qui est basée sur la structure du système de fichiers.

En termes simples, les pages sont à l'intérieur d'un dossier `pages`, et l'URL de la page est déterminée par le nom du fichier de la page. Le système de fichiers est l'API des pages.

#### Rendu côté serveur

Ouvrez la source de la page, `Affichage -> Développeur -> Affichage` Source avec Chrome.

Comme vous pouvez le voir, le HTML généré par le composant est envoyé directement dans la source de la page. Il n'est pas rendu côté client, mais plutôt rendu sur le serveur.

L'équipe Next.js voulait créer une expérience de développement pour les pages rendues côté serveur similaire à celle que vous obtenez lorsque vous créez un projet PHP de base, où vous déposez simplement des fichiers PHP et vous les appelez, et ils apparaissent comme des pages. Bien sûr, en interne, tout est très différent, mais la facilité apparente d'utilisation est claire.

#### Ajouter une deuxième page

Créons une autre page, dans `pages/contact.js`

```
export default () => (
  <div>
    <p>
      <a href="mailto:my@email.com">Contactez-nous !</a>
    </p>
  </div>
)
```

Si vous pointez votre navigateur vers `localhost:3000/contact`, cette page sera rendue. Comme vous pouvez le voir, cette page est également rendue côté serveur.

#### Rechargement à chaud

Notez comment vous n'avez pas eu à redémarrer le processus `npm` pour charger la deuxième page. Next.js le fait pour vous sous le capot.

#### Rendu côté client

Le rendu côté serveur est très pratique lors du premier chargement de la page, pour toutes les raisons que nous avons vues ci-dessus, mais lorsqu'il s'agit de naviguer à l'intérieur du site web, le rendu côté client est essentiel pour accélérer le chargement de la page et améliorer l'expérience utilisateur.

Next.js fournit un composant `Link` que vous pouvez utiliser pour construire des liens. Essayez de lier les deux pages ci-dessus.

Changez `index.js` en ce code :

```jsx
import Link from 'next/link'

export default () => (
  <div>
    <p>Hello World!</p>
    <Link href="/contact">
      <a>Contactez-moi !</a>
    </Link>
  </div>
)
```

Maintenant, retournez dans le navigateur et essayez ce lien. Comme vous pouvez le voir, la page de contact se charge immédiatement, sans actualisation de la page.

C'est la navigation côté client qui fonctionne correctement, avec un support complet pour l'[**API History**](https://flaviocopes.com/history-api/), ce qui signifie que le bouton de retour de vos utilisateurs ne se cassera pas.

Si vous faites maintenant un `cmd-clic` sur le lien, la même page de contact s'ouvrira dans un nouvel onglet, maintenant rendue côté serveur.

#### Pages dynamiques

Un bon cas d'utilisation pour Next.js est un blog, car c'est quelque chose que tous les développeurs savent comment cela fonctionne, et c'est un bon exemple simple de la façon de gérer les pages dynamiques.

Une page dynamique est une page qui n'a pas de contenu fixe, mais affiche plutôt certaines données basées sur certains paramètres.

Changez `index.js` en

```jsx
import Link from 'next/link'

const Post = props => (
  <li>
    <Link href={`/post?title=${props.title}`}>
      <a>{props.title}</a>
    </Link>
  </li>
)

export default () => (
  <div>
    <h2>Mon blog</h2>
    <ul>
      <li>
        <Post title="Yet another post" />
        <Post title="Second post" />
        <Post title="Hello, world!" />
      </li>
    </ul>
  </div>
)
```

Cela créera une série de posts et remplira le paramètre de requête title avec le titre du post :

![Image](https://cdn-media-1.freecodecamp.org/images/nEBXVSebNz6KzUWgNg62w-clo2vL7tnLIYpl)

Maintenant, créez un fichier `post.js` dans le dossier `pages`, et ajoutez :

```
export default props => <h1>{props.url.query.title}</h1>
```

Maintenant, en cliquant sur un seul post, le titre du post sera rendu dans une balise `h1` :

![Image](https://cdn-media-1.freecodecamp.org/images/urgIpOydqbjE4i9nyELblMonOjrK0Plrn3OJ)

Vous pouvez utiliser des URLs propres sans paramètres de requête. Le composant Link de Next.js nous aide en acceptant un attribut `as`, que vous pouvez utiliser pour passer un slug :

```jsx
import Link from 'next/link'

const Post = props => (
  <li>
    <Link as={`/${props.slug}`} href={`/post?title=${props.title}`}>
      <a>{props.title}</a>
    </Link>
  </li>
)

export default () => (
  <div>
    <h2>Mon blog</h2>
    <ul>
      <li>
        <Post slug="yet-another-post" title="Yet another post" />
        <Post slug="second-post" title="Second post" />
        <Post slug="hello-world" title="Hello, world!" />
      </li>
    </ul>
  </div>
)
```

#### CSS-in-JS

Next.js fournit par défaut un support pour [styled-jsx](https://github.com/zeit/styled-jsx), qui est une solution CSS-in-JS fournie par la même équipe de développement, mais vous pouvez utiliser n'importe quelle bibliothèque que vous préférez, comme Styled Components.

Exemple :

```jsx
export default () => (
  <div>
    <p>
      <a href="mailto:my@email.com">Contactez-nous !</a>
    </p>
    <style jsx>{`
      p {
        font-family: 'Courier New';
      }
      a {
        text-decoration: none;
        color: black;
      }
      a:hover {
        opacity: 0.8;
      }
    `}</style>
  </div>
)
```

Les styles sont limités au composant, mais vous pouvez également modifier les styles globaux en ajoutant `global` à l'élément `style` :

```jsx
export default () => (
  <div>
    <p>
      <a href="mailto:my@email.com">Contactez-nous !</a>
    </p>
    <style jsx global>{`
      body {
        font-family: 'Benton Sans', 'Helvetica Neue';
        margin: 2em;
      }
      h2 {
        font-style: italic;
        color: #373fff;
      }
    `}</style>
  </div>
)
```

#### Exporter un site statique

Une application Next.js peut être facilement exportée en tant que site statique, qui peut être déployé sur l'un des hôtes de sites statiques super rapides, comme [Netlify](https://flaviocopes.com/netlify/) ou [Firebase Hosting](https://flaviocopes.com/firebase-hosting/), sans avoir besoin de configurer un environnement Node.

Le processus nécessite que vous déclariez les URLs qui composent le site, mais c'est [un processus simple](https://github.com/zeit/next.js/#static-html-export).

#### Déploiement

Créer une copie de l'application prête pour la production, sans les cartes sources ou d'autres outils de développement qui ne sont pas nécessaires dans la version finale, est facile.

Au début de ce tutoriel, vous avez créé un fichier `package.json` avec ce contenu :

```json
{
  "scripts": {
    "dev": "next"
  }
}
```

qui était la façon de démarrer un serveur de développement en utilisant `npm run dev`.

Maintenant, ajoutez simplement le contenu suivant à `package.json` :

```json
{
  "scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
  }
}
```

et préparez votre application en exécutant `npm run build` et `npm run start`.

#### Now

L'entreprise derrière Next.js fournit un service d'hébergement génial pour les applications Node.js, appelé [**Now**](https://zeit.co/now).

Bien sûr, ils intègrent leurs deux produits afin que vous puissiez déployer des applications Next.js de manière transparente, [une fois que vous avez installé Now](https://zeit.co/download), en exécutant la commande `now` dans le dossier de l'application.

En coulisses, Now configure un serveur pour vous, et vous n'avez pas besoin de vous soucier de quoi que ce soit, il suffit d'attendre que l'URL de votre application soit prête.

#### Zones

Vous pouvez configurer plusieurs instances Next.js pour écouter différentes URLs, mais l'application pour un utilisateur externe semblera simplement être alimentée par un seul serveur : [https://github.com/zeit/next.js/#multi-zones](https://github.com/zeit/next.js/#multi-zones)

#### Plugins

Next.js dispose d'une liste de plugins à l'adresse [https://github.com/zeit/next-plugins](https://github.com/zeit/next-plugins)

#### Kit de démarrage sur Glitch

Si vous cherchez à expérimenter, je recommande Glitch. Consultez mon [Kit de démarrage Next.js sur Glitch](https://glitch.com/edit/#!/flavio-starter-nextjs).

### Gatsby

Gatsby est une plateforme pour construire des applications et des sites web en utilisant React.

C'est l'un des outils qui vous permettent de construire sur un ensemble de technologies et de pratiques collectivement connues sous le nom de [JAMstack](https://flaviocopes.com/jamstack/).

Gatsby est l'un des enfants cool dans l'espace du développement frontend en ce moment. Pourquoi ? Je pense que les raisons sont :

* l'explosion de l'approche JAMstack pour construire des applications web et des sites web
* l'adoption rapide de la technologie [Progressive Web Apps](https://flaviocopes.com/progressive-web-apps/) dans l'industrie, qui est l'une des fonctionnalités clés de Gatsby
* il est construit en React et [GraphQL](https://flaviocopes.com/graphql/), qui sont deux technologies très populaires et en croissance
* il est vraiment puissant
* il est rapide
* la documentation est excellente
* l'effet de réseau (les gens l'utilisent, créent des sites, font des tutoriels, les gens en savent plus, créant un cycle)
* tout est en JavaScript (pas besoin d'apprendre un nouveau langage de templating)
* il cache la complexité, au début, mais nous permet d'accéder à chaque étape pour personnaliser

Tous ces points sont excellents, et Gatsby vaut définitivement le coup d'œil.

#### Comment ça marche ?

Avec Gatsby, vos applications sont construites en utilisant des composants React.

Le contenu que vous allez rendre dans un site est généralement écrit en utilisant Markdown, mais vous pouvez utiliser n'importe quel type de source de données, comme un CMS headless ou un service web comme Contentful.

Gatsby construit le site, et il est compilé en HTML statique qui peut être déployé sur n'importe quel serveur web que vous souhaitez, comme Netlify, AWS S3, GitHub Pages, des fournisseurs d'hébergement réguliers, PAAS et plus. Tout ce dont vous avez besoin est un endroit qui sert des pages HTTP simples et vos ressources au client.

J'ai mentionné les Progressive Web Apps dans la liste. Gatsby génère automatiquement votre site en tant que PWA, avec un service worker qui accélère le chargement des pages et la mise en cache des ressources.

Vous pouvez améliorer la fonctionnalité de Gatsby via des plugins.

#### Installation

Vous pouvez installer Gatsby en exécutant simplement ceci dans votre terminal :

```bash
npm install -g gatsby-cli
```

Cela installe l'utilitaire CLI `gatsby`.

(quand une nouvelle version est disponible, mettez-le à jour en appelant à nouveau cette commande)

Vous créez un nouveau site "Hello World" en exécutant

```bash
gatsby new mysite https://github.com/gatsbyjs/gatsby-starter-hello-world
```

Cette commande crée un tout nouveau site Gatsby dans le dossier `mysite`, en utilisant le _starter_ disponible à l'adresse [https://github.com/gatsbyjs/gatsby-starter-hello-world](https://github.com/gatsbyjs/gatsby-starter-hello-world).

![Image](https://cdn-media-1.freecodecamp.org/images/rNWB5DuHCS526rLjNuhwMdYAErq4TTAJFqg5)

Un _starter_ est un site exemple sur lequel vous pouvez construire. Un autre starter commun est `default`, disponible à l'adresse [https://github.com/gatsbyjs/gatsby-starter-default](https://github.com/gatsbyjs/gatsby-starter-default).

> [_Voici une liste de tous les starters que vous pouvez utiliser_](https://www.gatsbyjs.org/docs/gatsby-starters/)_._

#### Exécuter le site Gatsby

Après que le terminal ait terminé l'installation du starter, vous pouvez exécuter le site web en appelant

```bash
cd mysite
gatsby develop
```

ce qui démarrera un nouveau serveur web et servira le site sur le port 8000 en localhost.

![Image](https://cdn-media-1.freecodecamp.org/images/tThFtYg35ax6YBnuLS9z4y92JYUhdxJZaBaj)

Et voici notre starter Hello World en action :

![Image](https://cdn-media-1.freecodecamp.org/images/i-aQLpALPcniL3pkUylOWeoqYCKvnzDHX8Sx)

### Inspecter le site

Si vous ouvrez le site que vous avez créé avec votre éditeur de code préféré (j'utilise [VS Code](https://flaviocopes.com/vscode/)), vous trouverez qu'il y a 3 dossiers :

* `.cache`, un dossier caché qui contient les internes de Gatsby, rien que vous ne devriez changer pour le moment
* `public`, qui contient le site web résultant une fois que vous l'avez construit
* `src` contient les composants React, dans ce cas, seulement le composant `index`
* `static` qui contiendra les ressources statiques comme le CSS et les images

![Image](https://cdn-media-1.freecodecamp.org/images/x5XH1s5uMEQdUfnZB6BM2-T9HXkDwv1xLhPd)

Maintenant, faire un simple changement à la page par défaut est facile, il suffit d'ouvrir `src/pages/index.js` et de changer "Hello world!" en autre chose, et d'enregistrer. Le navigateur devrait instantanément **recharger à chaud** le composant (ce qui signifie que la page ne s'actualise pas réellement, mais le contenu change - un truc rendu possible par la technologie sous-jacente).

Pour ajouter une deuxième page, il suffit de créer un autre fichier .js dans ce dossier, avec le même contenu que `index.js` (modifiez le contenu) et l'enregistrer.

Par exemple, j'ai créé un fichier `second.js` avec ce contenu :

```jsx
import React from 'react'

export default () => <div>Deuxième page !</div>
```

et j'ai ouvert le navigateur à l'adresse [http://localhost:8000/second](http://localhost:8000/second) :

![Image](https://cdn-media-1.freecodecamp.org/images/g4uWZNxitB4AAVbqOFmCKKPugS7yrxKYH-ld)

#### Lier les pages

Vous pouvez lier ces pages en important un composant React fourni par Gatsby appelé `Link` :

```
import { Link } from "gatsby"
```

et l'utiliser dans votre composant [JSX](https://flaviocopes.com/jsx/) :

```
<Link to="/second/">Deuxième</Link>
```

#### Ajouter du CSS

Vous pouvez importer n'importe quel fichier CSS en utilisant une importation JavaScript :

```
import './index.css'
```

Vous pouvez utiliser le style React :

```jsx
<p style={{
    margin: '0 auto',
    padding: '20px'
  }}>Hello world</p>
```

#### Utiliser des plugins

Gatsby fournit beaucoup de choses prêt à l'emploi, mais de nombreuses autres fonctionnalités sont fournies par des [plugins](https://www.gatsbyjs.org/plugins/).

Il existe 3 types de plugins :

* **plugins source** récupèrent des données à partir d'une source. Créent des nœuds qui peuvent ensuite être filtrés par des plugins de transformation
* **plugins de transformation** transforment les données fournies par les plugins source en quelque chose que Gatsby peut utiliser
* **plugins fonctionnels** implémentent une sorte de fonctionnalité, comme l'ajout de la prise en charge des sitemaps ou plus

Certains plugins couramment utilisés sont :

* [gatsby-plugin-react-helmet](https://www.gatsbyjs.org/packages/gatsby-plugin-react-helmet/) qui permet de modifier le contenu de la balise `head`
* [gatsby-plugin-catch-links](https://www.gatsbyjs.org/packages/gatsby-plugin-catch-links/) qui utilise l'[API History](https://flaviocopes.com/history-api/) pour empêcher le navigateur de recharger la page lorsqu'un lien est cliqué, chargeant le nouveau contenu en utilisant AJAX à la place

Un plugin Gatsby est installé en 2 étapes. D'abord, vous l'installez en utilisant `npm`, puis vous l'ajoutez à la configuration Gatsby dans `gatsby-config.js`.

Par exemple, vous pouvez installer le plugin Catch Links :

```
npm install gatsby-plugin-catch-links
```

Dans `gatsby-config.js` (créez-le si vous ne l'avez pas, dans le dossier racine du site web), ajoutez le plugin au tableau `plugins` exporté :

```
module.exports = {
  plugins: ['gatsby-plugin-catch-links']
}
```

C'est tout, le plugin fera maintenant son travail.

#### Construire le site web statique

Une fois que vous avez terminé de modifier le site et que vous souhaitez générer le site statique de production, vous appelerez

```jsx
gatsby build
```

À ce stade, vous pouvez vérifier que tout fonctionne comme vous l'attendez en démarrant un serveur web local en utilisant

```jsx
gatsby serve
```

qui rendra le site aussi proche que possible de ce que vous verrez en production.

#### Déploiement

Une fois que vous avez construit le site en utilisant `gatsby build`, tout ce que vous avez à faire est de déployer le résultat contenu dans le dossier `public`.