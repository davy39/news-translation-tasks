---
title: À quoi s'attendre lors de votre première semaine en tant que développeur logiciel
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2018-05-01T21:21:05.000Z'
originalURL: https://freecodecamp.org/news/what-to-expect-in-your-first-week-as-a-software-developer-322572f17063
coverImage: https://cdn-media-1.freecodecamp.org/images/1*HKru9urHK6ywE91ZZhPbig.jpeg
tags:
- name: jobs
  slug: jobs
- name: learning
  slug: learning
- name: General Programming
  slug: programming
- name: software development
  slug: software-development
- name: technology
  slug: technology
seo_title: À quoi s'attendre lors de votre première semaine en tant que développeur
  logiciel
seo_desc: 'By Harriet Ryder

  You know you enjoy coding, but what’s it like doing it for a job? What might you
  expect in your first week?

  I couldn’t imagine my first week in a new job. Do you start coding right away? What
  if they use a language/framework you have...'
---

Par Harriet Ryder

Vous savez que vous aimez coder, mais à quoi cela ressemble-t-il de le faire pour un travail ? À quoi pouvez-vous vous attendre lors de votre première semaine ?

Je ne pouvais pas imaginer ma première semaine dans un nouvel emploi. Commencez-vous à coder tout de suite ? Et s'ils utilisent un langage/un framework que vous n'avez pas appris ? Comment vous mettez-vous à niveau avec la base de code et savez-vous quelles sont les priorités ? Est-il facile de s'intégrer dans l'équipe ? Vous ouvrez simplement votre éditeur et commencez à coder ? Et si vous faites une erreur horrible et cassez tout ?

J'ai travaillé pendant 2 ans dans un bootcamp de codage, et j'ai entendu des questions similaires de la part de nombreux étudiants. Ils savaient qu'ils aimaient coder et adoraient ce qu'ils faisaient au bootcamp au quotidien, mais ils voulaient savoir à quoi cela ressemble d'entrer dans un vrai travail.

Dans cet article, je vais utiliser des exemples de ce que j'ai fait lors des premiers jours dans mon rôle le plus récent pour essayer de vous donner une idée de ce à quoi vous pouvez vous attendre.

### Contexte

Je travaille en tant que développeur full stack dans une entreprise de taille moyenne. Il y a quatre développeurs dans l'équipe d'ingénierie (moi y compris) et un CTO. Nous travaillons également en étroite collaboration avec un Product Owner, qui est l'un des fondateurs. J'avais quelques années d'expérience en codage.

Tous les services sont sur AWS et nous utilisons NodeJS et Ruby.

### Jour 1 : Principalement l'installation

Je suis arrivée au bureau à 9h. Un tout nouveau MacBook Pro m'attendait sur mon bureau, complet avec des adaptateurs et deux écrans. L'équipe de développement m'a emmenée prendre le petit déjeuner dans un café à proximité, et à notre retour, je me suis assise et j'ai commencé à configurer ma machine.

Puisque j'ai configuré d'innombrables environnements de développement auparavant en travaillant dans un bootcamp de codage, cela a été assez simple et ne m'a pas pris beaucoup de temps. Cependant, je n'avais configuré un environnement Ruby/Rails sur mon propre ordinateur portable qu'une seule fois, donc cette partie m'a pris un peu plus de temps.

On m'a fourni une feuille A4 listant les exigences, les numéros de version, etc., que j'ai veillé à suivre attentivement. On m'a également donné accès à divers sites comme BitBucket, un gestionnaire de mots de passe, AWS et Gitlab, et j'ai configuré mes clés SSH sur ma nouvelle machine.

Avant le déjeuner, je suis allée discuter avec le CTO et nous avons parlé en détail du produit, de l'architecture, et des objectifs et priorités de l'équipe de développement pour l'avenir prévisible.

Après le déjeuner, j'ai cloné certains des services qui composent l'application et j'ai commencé à me familiariser avec la base de code. Heureusement pour moi, j'ai rejoint l'équipe à un moment où il y avait de nouvelles parties fraîches du service en développement, ce qui signifie que je n'avais pas **trop** de code à assimiler.

Pendant les dernières heures de la journée, je me suis assise avec l'un des développeurs seniors pendant qu'il implémentait une fonctionnalité. Nous en avons profité pour qu'il me guide à travers cette partie de l'application, expliquant pourquoi les choses avaient été faites de certaines manières, les parties qui avaient causé des problèmes, et les aspects qui pourraient finir par changer à l'avenir.

### Jour 2 : Tests

On m'a donné la tâche de tester quelques fonctions dans l'un des dépôts de l'application. Donner aux nouveaux employés des tests à écrire est un excellent moyen de les introduire à une base de code et de les familiariser avec une partie de la logique de l'application.

J'ai passé pas mal de temps à simplement lire le code, à comprendre comment tout fonctionnait ensemble, et à voir si je pouvais suivre le flux de la logique. Je m'intéressais aux conventions que l'équipe avait choisies, à la manière dont le code avait été divisé, et aux choix stylistiques. Écrire les tests n'était pas difficile, mais j'ai toujours été très prudente en faisant ma première marque sur une base de code sur laquelle je n'avais pas travaillé auparavant !

Je ne voulais pas que mon travail se distingue, alors j'ai tenté d'observer et d'absorber le style de code qui était actuellement utilisé. Dans une certaine mesure, avoir de bonnes pratiques comme le linting aide beaucoup, mais il y a aussi simplement des choix architecturaux et stylistiques généraux avec lesquels le linting ne peut pas vous aider.

Un léger défi que j'ai eu a été de m'habituer au flux de travail Git que l'équipe utilisait. Chaque équipe a sa propre façon de faire les choses : certaines équipes fusionnent, certaines rebasent, certaines écrasent les commits et d'autres non, certaines suivent des flux de travail populaires comme [celui-ci](http://nvie.com/posts/a-successful-git-branching-model/), et d'autres font simplement des push forcés dans master sans réfléchir. De plus, il y a les conventions du message et de la description du commit à respecter, le processus de révision, et ainsi de suite.

En fin de compte, il y a beaucoup de choses non explicites « c'est comme ça que nous faisons les choses » à assimiler. Après avoir traversé le processus quelques fois, corrigé mes erreurs et posé des questions, c'est maintenant devenu une seconde nature.

Tout le temps où j'écrivais des tests, je prenais des notes dans un carnet et je gardais des extraits de code dans une application appelée [Bear](http://www.bear-writer.com/). Il y avait tellement de choses à assimiler — comment faire les choses, les procédures préférées de l'équipe, les choses que je n'avais pas faites auparavant, et de nouveaux langages et frameworks à apprendre.

J'avais besoin d'être vraiment active dans la prise de notes sur ce que j'apprenais. J'en ai fait un point à la fin ou au début de chaque journée pour réviser mes notes, ajouter des explications supplémentaires aux choses que j'avais écrites à la hâte, et rechercher des choses que je ne comprenais pas complètement. Tout cela a également pris un certain temps.

### Jour 3 : Exploration d'AWS

Dans le cadre de la version que nous avions en cours, nous devions décider comment déployer un service que nous construisions. Nous utilisions AWS, mais il y avait un choix entre utiliser une instance EC2, qui serait le choix le plus simple, car c'est simplement un serveur dans le cloud exécutant votre application, ou quelque chose d'un peu plus sophistiqué comme Elastic Container Service. L'avantage d'ECS est qu'il gérerait la mise à l'échelle de plusieurs instances EC2 et serait donc une bonne option pour l'avenir. Mais ce n'était pas complètement essentiel pour le moment.

Étant donné cela, on m'a donné (je me suis portée volontaire pour) la tâche d'explorer la facilité de déployer notre service sur ECS. Explorer signifie simplement essayer quelque chose pour en évaluer la faisabilité. Si c'était trop difficile, cela ne valait pas la peine, puisque c'était une optimisation future dont nous n'avions pas désespérément besoin pour le moment.

Cela a impliqué beaucoup d'apprentissage pour moi, car je n'avais pas utilisé Amazon ECS auparavant, et l'application était une application Rails, un écosystème Ruby/Rails avec lequel j'étais beaucoup moins familière. J'avais passé peut-être un total de 30 heures à apprendre Ruby avant de rejoindre l'entreprise, puisque je savais que cela faisait partie de leur stack, mais je n'avais presque pas touché à Rails. De plus, la tâche impliquait un peu de travail avec Docker, qui était également nouveau pour moi.

Mon responsable technique m'a donné un bon départ avec ce qui était essentiellement une introduction d'une heure à Docker, ce qui a été extrêmement utile. À partir de là, j'ai passé la majeure partie de la journée à créer une nouvelle application Rails et à suivre divers articles, documentations et exemples pour voir si je pouvais faire fonctionner la chose sur ECS. J'ai presque réussi, mais faire fonctionner l'intégration de la base de données s'est avéré être un obstacle. Il y avait simplement tellement de nouvelles choses.

Je suis sûre que quelqu'un de plus familier avec ECS ou Rails n'aurait pas eu autant de difficultés. Je ne pouvais pas dire que le processus était objectivement difficile. C'était difficile **pour moi**, mais cela ne signifiait pas que c'était difficile pour tout le monde.

Pas une journée extrêmement productive en termes de code ou de sortie utilisable, mais j'ai eu l'impression d'avoir beaucoup appris et de ce point de vue, c'était génial.

### Jour 4 : Travail en binôme et mentorat

Je suis arrivée au bureau à 8h, et en attendant que les autres arrivent, j'ai suivi une partie d'un cours sur Docker que je regardais sur Pluralsight. J'étais toujours désireuse de terminer l'exploration de la veille, mais j'ai reconnu que j'avais besoin de plus de bases dans au moins une des nouvelles technologies avec lesquelles je travaillais.

J'ai passé environ une heure sur le cours, avant que plus de monde n'arrive au bureau et que nous nous mettions à décider qui ferait quoi. Un autre nouveau développeur, qui avait commencé un peu avant moi, venait de revenir de vacances. Nous avons décidé de travailler en binôme sur une tâche. Nous construisions une nouvelle fonctionnalité dans l'application Rails. C'était une tâche assez simple, mais Rails était nouveau pour nous deux, donc c'était génial de la travailler ensemble. Lorsque nous avions besoin d'une explication, nous demandions simplement à l'un des autres développeurs, soit en personne, soit sur Slack. Nous avons eu de grandes discussions de cette manière et j'ai commencé à comprendre comment Rails fonctionne.

Dans l'après-midi, j'ai eu une session de mentorat avec le responsable technique, ce qui était généreux puisque j'avais déjà eu un cours privé sur Docker la veille ! Le mentorat est une opportunité de poser des questions, de résoudre des problèmes ensemble, d'apprendre quelque chose ensemble, ou simplement de profiter des connaissances de quelqu'un. Le transfert de connaissances est très bénéfique.

J'avais beaucoup de questions étranges sur les bases de données et Rails, mais je regrette de ne pas avoir eu un seul objectif pour cette première session. Je suppose que je ne savais simplement pas à quoi m'attendre. Lors des sessions suivantes, j'ai demandé à mon mentor de me montrer comment faire quelque chose de spécifique comme configurer un serveur NGINX ou configurer une instance EC2 pour avoir accès à une base de données — des choses qu'il savait déjà, mais qui me prendraient beaucoup plus de temps à comprendre par moi-même.

### Jour 5 : Réunions et fusions

De nombreuses équipes logicielles utilisent des combinaisons de réunions debout (souvent quotidiennes), de rétrospectives régulières (sur les pratiques de travail ou les problèmes techniques), et de sessions de planification pour organiser leur flux de travail à un niveau élevé, en combinaison avec un outil de suivi où le travail en cours et le travail restant à faire peuvent être visualisés.

Notre équipe ne fait pas exception, et nous avons la majorité de nos réunions planifiées le vendredi. Comme de nombreuses équipes, l'accent lors de nos réunions est mis sur la réflexion sur la manière dont nous avons travaillé et sur ce que nous avons accompli, pour résoudre collectivement tout problème ou blocage, et pour identifier et planifier les travaux à venir afin que nous ayons toujours quelque chose de prêt à avancer.

Nous sortons également prendre le petit déjeuner pour renforcer les liens, ce qui est génial !

Dans l'ensemble, la majeure partie de la matinée a été consacrée à ces activités. J'avais peu à contribuer car je m'efforçais toujours de comprendre toute la terminologie et la structure du produit, et j'étais toujours à une phrase de retard, essayant de rattraper ce qui venait d'être dit. Je me souviens pendant cette première semaine de simplement avoir l'impression que mon cerveau fondait alors que j'essayais de garder tous les divers composants de l'architecture ensemble dans mon esprit (cela s'améliore avec le temps, alors ne vous inquiétez pas !).

Dans l'après-midi, mon binôme et moi avons pu terminer ce sur quoi nous travaillions, solliciter une révision de code, faire des amendements, et ouvrir une demande pour fusionner notre travail dans l'application. Nous n'avons pas déployé car c'était un vendredi après-midi, mais nous l'avons fait le lundi suivant. ?

Merci d'avoir lu, j'espère que cet article vous a donné une idée de ce à quoi votre première semaine en tant que développeur pourrait ressembler.

J'adorerais entendre vos commentaires et expériences !