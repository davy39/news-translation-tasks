---
title: Tutoriel Next.js et Firebase – Comment créer un clone d'Evernote
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2022-02-01T18:30:40.000Z'
originalURL: https://freecodecamp.org/news/nextjs-firebase-tutorial-build-an-evernote-clone
coverImage: https://www.freecodecamp.org/news/content/images/2022/01/How-to-Build-a-Weather-Application-using-React--50-.png
tags:
- name: Firebase
  slug: firebase
- name: Next.js
  slug: nextjs
- name: React
  slug: react
seo_title: Tutoriel Next.js et Firebase – Comment créer un clone d'Evernote
seo_desc: 'By Nishant Kumar

  Next.js is a server-side rendering framework based on React, which is search engine
  optimized.

  So, let''s build an Evernote clone using Next.js to learn how it works.

  We will use the following tech stack:


  Next.js for the UI

  Firebase ...'
---

Par Nishant Kumar

Next.js est un framework de rendu côté serveur basé sur React, qui est optimisé pour les moteurs de recherche.

Alors, créons un clone d'Evernote en utilisant Next.js pour apprendre comment il fonctionne.

Nous utiliserons la pile technologique suivante :

1. Next.js pour l'interface utilisateur
2. Firebase pour la base de données et pour héberger notre application
3. SASS pour les feuilles de style

Alors, commençons.

## Comment créer une application Next

Tout comme la commande que nous utilisons pour créer une application React, nous avons une commande pour créer rapidement une application Next. Elle ressemble à ceci :

```
npx create-next-app@latest
# ou
yarn create next-app
```

Si vous utilisez npm, utilisez `npx create-next-app@latest`. Sinon, si vous utilisez le gestionnaire de paquets Yarn, utilisez `yarn create next-app`.

Mais d'abord, vous devez avoir Node.js installé dans votre système. Allez sur [https://nodejs.org/en/download/](https://nodejs.org/en/download/) pour télécharger et installer Node.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-185459.jpeg)

Donnez un nom au projet, qui est evernote-clone dans notre cas.

Après que le projet ait fini de se créer, nous trouverons une structure de fichiers similaire à ce que nous voyons dans React.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-185727.jpeg)

Commençons l'application maintenant. Tapez simplement `npm run dev`, et voici ce que vous verrez dans votre terminal :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-185921.jpeg)

Et tout comme React, Next vient avec un peu de code de base.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-190055.jpeg)

Supprimons tout ce code et commençons depuis le début.

Ouvrez index.js dans le dossier pages, et vous verrez tout ce code :

```
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>
          Welcome to <a href="https://nextjs.org">Next.js!</a>
        </h1>

        <p className={styles.description}>
          Get started by editing{' '}
          <code className={styles.code}>pages/index.js</code>
        </p>

        <div className={styles.grid}>
          <a href="https://nextjs.org/docs" className={styles.card}>
            <h2>Documentation &rarr;</h2>
            <p>Find in-depth information about Next.js features and API.</p>
          </a>

          <a href="https://nextjs.org/learn" className={styles.card}>
            <h2>Learn &rarr;</h2>
            <p>Learn about Next.js in an interactive course with quizzes!</p>
          </a>

          <a
            href="https://github.com/vercel/next.js/tree/canary/examples"
            className={styles.card}
          >
            <h2>Examples &rarr;</h2>
            <p>Discover and deploy boilerplate example Next.js projects.</p>
          </a>

          <a
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
            className={styles.card}
          >
            <h2>Deploy &rarr;</h2>
            <p>
              Instantly deploy your Next.js site to a public URL with Vercel.
            </p>
          </a>
        </div>
      </main>

      <footer className={styles.footer}>
        <a
          href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          Powered by{' '}
          <span className={styles.logo}>
            <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
          </span>
        </a>
      </footer>
    </div>
  )
}

```

Effacez tout cela pour pouvoir commencer à partir de zéro. Voici ce que vous devriez avoir maintenant :

```
import Head from 'next/head'
import styles from '../styles/Home.module.css'

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>

      </main>
    </div>
  )
}

```

Ce code nettoyé contient les balises Title et les balises Main, où nous pouvons écrire notre code.

```
import Head from 'next/head'
import styles from '../styles/Home.module.css'

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Clone d'Evernote</title>
        <meta name="description" content="Ceci est un clone d'Evernote" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>

      </main>
    </div>
  )
}

```

Tous nos styles sont dans `Home.module.css`, et c'est ainsi que nous créons une feuille de style.

## Comment installer SASS, Firebase et React Quill

Installons maintenant SASS et Firebase.

```
npm i firebase sass react-quill
```

Utilisez la commande ci-dessus qui les installera tous en une seule fois.

Permettez-moi d'expliquer comment nous utiliserons chacun de ces outils :

1. Firebase – Pour stocker nos données de notes dans le backend
2. SASS – Nous utilisons SASS au lieu de CSS, car il fournit de nombreuses fonctionnalités différentes que nous n'avons pas en CSS.
3. React Quill – Un éditeur de zone de texte riche pour les notes.

Maintenant, après les avoir installés, continuons.

Nous devons diviser notre écran en deux parties. La partie gauche contiendra l'option de créer de nouvelles notes, tandis que le côté droit les affichera.

Créez une div à l'intérieur de la main, qui contiendra deux autres divs. Chaque div pointe vers sa classe respective dans la feuille de style.

```
<main className={styles.main}>
        <div className={styles.container}>
          <div className={styles.left}>Gauche</div>
          <div className={styles.right}>Droite</div>
        </div>
      </main>
```

Maintenant, créons un fichier de feuille de style. Nommez-le Evernote.modules.scss.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-191605.jpeg)

Et c'est le fichier où nous ferons notre stylisation.

Organisons maintenant notre conteneur en flex.

```
.container {
    display: flex;
    margin: 10px;
}

.left{
    width: 20rem;
}
```

Nous avons un affichage flex dans le conteneur, et une largeur de 20 rem pour le conteneur de gauche. Cela donne le résultat suivant :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-192230.jpeg)

Maintenant, créez un dossier à l'intérieur de pages appelé components. Il contiendra tous nos micro-composants.

Et à l'intérieur du dossier components, créez un fichier appelé NoteOperations.js.

Ensuite, importez ce composant à l'intérieur du fichier index.js principal, et retournez-le dans le main.

```
import NoteOperations from './components/NoteOperations';

<main>
        <div className={styles.container}>
          <div className={styles.left}>
            <NoteOperations />
          </div>
          <div className={styles.right}>Droite</div>
        </div>
      </main>
```

Mais vous verrez une erreur tout de suite, car nous n'avons rien à l'intérieur du composant NoteOperations.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-192735.jpeg)

Créons un composant fonctionnel NoteOperation.js.

```
export default function NoteOperations() {
    return (
        <>
        </>
    )
}
```

Il retourne un fragment vide pour l'instant. Alors, créons un bouton pour ajouter de nouvelles notes.

```
import styles from '../../styles/Evernote.module.scss'

export default function NoteOperations() {
    return (
        <>
            <div className={styles.btnContainer}>
                <button
                    className={styles.button}>
                    Ajouter une nouvelle note
                </button>
            </div>
        </>
    )
}
```

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-193707.jpeg)

Ce sera notre résultat pour l'instant. Designons notre bouton pour qu'il ait un peu meilleur aspect.

```
.button {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: black;
    color: whitesmoke;
    border: black;
}
```

Ces styles donneront le design de bouton suivant :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-194323.jpeg)

Importons la police Roboto de Google Fonts pour l'utiliser dans nos notes.

```
@import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');
```

Placez-le en haut du fichier de feuille de style afin d'utiliser la police, comme ceci :

```
.button {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: black;
    color: whitesmoke;
    border: black;
    font-family: 'Roboto';
}

```

Et maintenant vous verrez le changement dans la police du bouton.

Maintenant, ajoutons la fonction du bouton. Lorsque nous cliquons sur le bouton Ajouter une nouvelle note, un champ de texte devrait apparaître en bas.

D'abord, créons ce champ de texte :

```
import styles from '../../styles/Evernote.module.scss'

export default function NoteOperations() {
    return (
        <>
            <div className={styles.btnContainer}>
                <button
                    className={styles.button}>
                    Ajouter une nouvelle note
                </button>
            </div>

            <div className={styles.inputContainer}>
                <input placeholder='Entrez le titre..'/> 
            </div>
        </>
    )
}
```

Ajoutons un peu de style à cet élément d'entrée :

```
.input{
    width: 15rem;
    height: 2rem;
    outline: none;
    border-radius: 5px;
    border: 1px solid gray;
    margin: 5px 0;
}
```

Voici à quoi ressemble notre entrée maintenant :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-195052.jpeg)

Mais ce bouton ne devrait apparaître que lorsque nous cliquons sur le bouton Ajouter une nouvelle note. Nous devons donc utiliser l'état React pour cela.

```
import { useState } from 'react'

const [isInputVisible, setInputVisible] = useState(false);
```

Nous importons donc le hook useState de React et nous avons un état `isInputVisible`.

Nous avons également besoin d'une fonction qui sera déclenchée lorsque nous cliquons sur le bouton.

```
import styles from '../../styles/Evernote.module.scss'
import { useState } from 'react'
export default function NoteOperations() {
    const [isInputVisible, setInputVisible] = useState(false);
    const inputToggle = () => {
        setInputVisible(!isInputVisible)
    }
    return (
        <>
            <div className={styles.btnContainer}>
                <button
                    onClick={inputToggle}
                    className={styles.button}>
                    Ajouter une nouvelle note
                </button>
            </div>

            <div className={styles.inputContainer}>
                <input className={styles.input} placeholder='Entrez le titre..'/> 
            </div>
        </>
    )
}
```

Ainsi, lorsque nous cliquons sur notre bouton Ajouter une nouvelle note, il basculera IsInputVisible entre vrai et faux. Et en fonction de cette condition, nous devons afficher notre élément d'entrée.

```
{isInputVisible ? (
                <div className={styles.inputContainer}>
                    <input className={styles.input} placeholder='Entrez le titre..' />
                </div>
            ) : (
                <></>
            )}
```

Nous utilisons donc un opérateur ternaire pour vérifier. Si l'état isInputVisible est vrai, il affichera le champ de saisie, sinon il le cachera.

Voici le code complet jusqu'à ce point :

```
import styles from '../../styles/Evernote.module.scss'
import { useState } from 'react'
export default function NoteOperations() {
    const [isInputVisible, setInputVisible] = useState(false);
    const inputToggle = () => {
        setInputVisible(!isInputVisible)
    }
    return (
        <>
            <div className={styles.btnContainer}>
                <button
                    onClick={inputToggle}
                    className={styles.button}>
                    Ajouter une nouvelle note
                </button>
            </div>

            {isInputVisible ? (
                <div className={styles.inputContainer}>
                    <input className={styles.input} placeholder='Entrez le titre..' />
                </div>
            ) : (
                <></>
            )}
        </>
    )
}
```

Maintenant, nous devons obtenir les données du champ de saisie. Nous avons donc besoin d'un état supplémentaire.

Créons un état et lions la fonction setState au champ de saisie en utilisant l'événement onChange. Cela signifie que chaque fois que notre saisie change, ou lorsque nous tapons, la valeur de l'état sera mise à jour.

```
const [noteTitle, setNoteTitle] = useState('');

<div className={styles.inputContainer}>
                    <input 
                    className={styles.input} 
                    placeholder='Entrez le titre..' 
                    onChange={(e) => setNoteTitle(e.target.value)}
                    />
                </div>
```

## Comment envoyer des données à Firebase

Maintenant, envoyons nos données à Firebase Firestore.

Rendez-vous sur [https://firebase.google.com/](https://firebase.google.com/) et créez un nouveau projet.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-200136.jpeg)

Il retournera toutes les données de configuration dont nous avons besoin pour les ajouter à notre application Next.

Si vous voulez apprendre comment tout cela fonctionne, j'ai une playlist complète à ce sujet sur YouTube. [Assurez-vous de la consulter ici](https://www.youtube.com/playlist?list=PLWgH1O_994O8B_HVG2iuyqBEWPGa5Lhoj).

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-200350.jpeg)

Ainsi, après avoir créé un projet, nous devons créer une application. Et après avoir créé une application, elle nous retournera des données de configuration.

```
// Importez les fonctions dont vous avez besoin depuis les SDK dont vous avez besoin
import { initializeApp } from "firebase/app";
// TODO: Ajoutez des SDK pour les produits Firebase que vous souhaitez utiliser
// https://firebase.google.com/docs/web/setup#available-libraries

// Configuration Firebase de votre application web
const firebaseConfig = {
  apiKey: "AIzaSyAaLhtQ-B698GWyLNihGVRaNWBOKtBH8wU",
  authDomain: "evernoteclone-7682f.firebaseapp.com",
  projectId: "evernoteclone-7682f",
  storageBucket: "evernoteclone-7682f.appspot.com",
  messagingSenderId: "332984082327",
  appId: "1:332984082327:web:ae2776c3a56f4d98816ed2"
};

// Initialisez Firebase
const app = initializeApp(firebaseConfig);
```

Créez un nouveau fichier appelé firebaseConfig.js dans notre application Next et ajoutez-les là. Le fichier ressemblera à quelque chose comme ceci :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-200803.jpeg)

Puisque nous allons utiliser la base de données Firestore, nous devons également importer les fonctions Firestore.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-201008.jpeg)

Nous devons également les exporter. Maintenant, nous pouvons utiliser la base de données Firestore dans notre application.

## Comment ajouter nos notes à Firestore

Maintenant, ajoutons nos notes à la base de données Firestore.

Dans NoteOperations.js, importez le fichier de configuration firebase.

```
import { app, database } from '../../firebaseConfig';
```

Nous avons également besoin de quelques fonctions de Firebase Firestore, alors importons-les.

```
import { collection, addDoc } from 'firebase/firestore';
```

Ici, nous utiliserons `collection` pour créer une collection, et addDoc ajoutera nos données à cette collection.

Alors, créons d'abord une collection. Nous nommerons cette collection dbInstance.

```
const dbInstance = collection(database, 'notes');
```

Elle prend la base de données de l'import firebaseConfig et le nom de la collection.

Créons un bouton pour sauvegarder les notes dans la base de données Firestore.

```
<button
   className={styles.saveBtn}>
   Sauvegarder la note
</button>
```

Et maintenant, nous ajouterons les styles du bouton Sauvegarder la note.

```
.saveBtn{
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: rgb(119, 27, 27);
    color: whitesmoke;
    border: rgb(119, 27, 27);
    font-family: 'Roboto';
}
```

Mais attendez – puisque nous utilisons SASS, nous pouvons définir des variables pour nos couleurs.

```
$dark-red: rgb(119, 27, 27);
$black: black;
$whiteSmoke: whiteSmoke;
```

Maintenant, nous pouvons utiliser ces couleurs n'importe où.

```
@import url("https://fonts.googleapis.com/css2?family=Roboto&display=swap");

$dark-red: rgb(119, 27, 27);
$black: black;
$whiteSmoke: whiteSmoke;
$gray: gray;

.container {
    display: flex;
}

.left {
    width: 20rem;
}

.button {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: $black;
    color: $whiteSmoke;
    border: $black;
    font-family: "Roboto";
}

.input {
    width: 15rem;
    height: 2rem;
    outline: none;
    border-radius: 5px;
    border: 1px solid $gray;
    margin: 5px 0;
}

.saveBtn {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: $dark-red;
    color: $whiteSmoke;
    border: $dark-red;
    font-family: "Roboto";
}

```

Et voici à quoi ressemble notre résultat maintenant.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-214046.jpeg)

Créons une fonction qui sauvegardera la note dans Firebase, et cette fonction s'exécutera lorsque nous cliquerons sur le bouton Sauvegarder la note.

```
const saveNote = () => {

}
```

Et dans le bouton Sauvegarder la note, ajoutez le code suivant :

```
<button
                        onClick={saveNote}
                        className={styles.saveBtn}>
                        Sauvegarder la note
                    </button>
```

Maintenant, dans la fonction saveNote, nous utiliserons la fonction addDoc.

```
const saveNote = () => {
        addDoc(dbInstance, {
            noteTitle: noteTitle
        })
    }
```

Cette fonction addDoc prend deux paramètres. Le premier est dbInstance, que nous avons créé précédemment. Le second est les données que nous voulons envoyer. Ajoutez-les entre accolades.

Maintenant, testons cela en créant une nouvelle note.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-214834.jpeg)

Alors, ajoutez une nouvelle note qui est Note 1. Et nous la verrons dans notre Firebase Firestore.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-214915.jpeg)

## Comment créer le corps des notes

Créons maintenant le corps des notes. Et pour cela, nous utiliserons React Quill que nous avons installé précédemment.

```
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
```

Importez-les en haut de votre composant.

Ensuite, retournez-le après le champ de saisie.

```
<div className={styles.ReactQuill}>
  <ReactQuill />
</div>
```

J'ai également ajouté quelques styles pour React Quill.

```
.ReactQuill{
    width: 15rem;
}
```

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-215508.jpeg)

Et voici notre résultat maintenant.

Obtenons les valeurs de l'éditeur React Quill. Nous avons besoin d'une fonction pour cela, et d'un état.

```
const [noteDesc, setNoteDesc] = useState('')

const addDesc = (value) => {
  setNoteDesc(value)
}
```

Ajoutez cette fonction `addDesc` à notre éditeur React Quill en tant qu'événement onChange.

```
<ReactQuill 
   onChange={addDesc}
/>
```

Ainsi, chaque fois que nous tapons quelque chose dans notre éditeur, il sera sauvegardé dans l'état `noteDesc`.

Maintenant, tout comme nous avons envoyé le titre de la note dans la fonction addDoc, nous devons envoyer ceci aussi.

```
const saveNote = () => {
        addDoc(dbInstance, {
            noteTitle: noteTitle,
            noteDesc: noteDesc
        })
    }
```

Testons cela maintenant.

Ajoutez un titre et une description, puis cliquez sur Sauvegarder la note.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-220032.jpeg)

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-220118.jpeg)

Vous verrez que nous avons un nouveau document avec un titre et une description.

Mais le problème ici est que lorsque nous ajoutons une nouvelle note, les données précédentes sont toujours présentes dans le champ de texte et l'éditeur React quill. Nous devons les effacer lorsque nous cliquons sur Sauvegarder la note.

Alors, effaçons les états lorsque nous cliquons sur le bouton Sauvegarder la note. Rendez-les simplement vides.

```
const saveNote = () => {
        addDoc(dbInstance, {
            noteTitle: noteTitle,
            noteDesc: noteDesc
        })
            .then(() => {
                setNoteTitle('')
                setNoteDesc('')
            })
    }
```

Ajoutez également les états à leurs entrées respectives en utilisant `value`.

```
<input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                        onChange={(e) => setNoteTitle(e.target.value)}
                        value={noteTitle}
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill
                            onChange={addDesc}
                            value={noteDesc}
                        />
                    </div>
```

Voici le code complet jusqu'à ce point :

```
import styles from '../../styles/Evernote.module.scss'
import { useState } from 'react';
import { app, database } from '../../firebaseConfig';
import { collection, addDoc } from 'firebase/firestore';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';

const dbInstance = collection(database, 'notes');
export default function NoteOperations() {
    const [isInputVisible, setInputVisible] = useState(false);
    const [noteTitle, setNoteTitle] = useState('');
    const [noteDesc, setNoteDesc] = useState('')
    const inputToggle = () => {
        setInputVisible(!isInputVisible)
    }

    const addDesc = (value) => {
        setNoteDesc(value)
    }

    const saveNote = () => {
        addDoc(dbInstance, {
            noteTitle: noteTitle,
            noteDesc: noteDesc
        })
            .then(() => {
                setNoteTitle('')
                setNoteDesc('')
            })
    }
    return (
        <>
            <div className={styles.btnContainer}>
                <button
                    onClick={inputToggle}
                    className={styles.button}>
                    Ajouter une nouvelle note
                </button>
            </div>

            {isInputVisible ? (
                <div className={styles.inputContainer}>
                    <input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                        onChange={(e) => setNoteTitle(e.target.value)}
                        value={noteTitle}
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill
                            onChange={addDesc}
                            value={noteDesc}
                        />
                    </div>
                    <button
                        onClick={saveNote}
                        className={styles.saveBtn}>
                        Sauvegarder la note
                    </button>
                </div>
            ) : (
                <></>
            )}
        </>
    )
}
```

Et les styles :

```
@import url("https://fonts.googleapis.com/css2?family=Roboto&display=swap");

$dark-red: rgb(119, 27, 27);
$black: black;
$whiteSmoke: whiteSmoke;
$gray: gray;

.container {
    display: flex;
}

.left {
    width: 20rem;
}

.button {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: $black;
    color: $whiteSmoke;
    border: $black;
    font-family: "Roboto";
}

.input {
    width: 15rem;
    height: 2rem;
    outline: none;
    border-radius: 5px;
    border: 1px solid $gray;
    margin: 5px 0;
}

.saveBtn {
    width: 15rem;
    height: 2rem;
    cursor: pointer;
    background-color: $dark-red;
    color: $whiteSmoke;
    border: $dark-red;
    font-family: "Roboto";
}

.ReactQuill{
    width: 15rem;
}
```

## Comment lire les données de Firestore

Maintenant, obtenons les notes que nous sauvegardons dans Firestore. Pour cela, nous avons besoin de la fonction getDocs, qui est similaire à la fonction addDoc.

Importez-les depuis Firestore :

```
import { collection, addDoc, getDocs } from 'firebase/firestore';
```

Ensuite, créez une fonction appelée getNotes.

```
const getNotes = () => {
        getDocs(dbInstance)
            .then((data) => {
                console.log(data);
            })
    }
```

La fonction getDocs prend dbInstance comme paramètre, et retourne les données de la collection.

Mais nous devons faire une chose de plus. Nous avons besoin d'un hook useEffect qui exécutera cette fonction chaque fois que notre page se charge. Alors, importons-le et ajoutons-le.

```
import { useState, useEffect } from 'react';

useEffect(() => {
    getNotes();
}, [])
```

Si nous vérifions notre console, nous obtiendrons ce qui suit :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-221127.jpeg)

Ces données que nous avons obtenues sont illisibles. Nous devons donc les filtrer pour obtenir les éléments qui sont réellement utiles.

```
const getNotes = () => {
        getDocs(dbInstance)
            .then((data) => {
                console.log(data.docs.map((item) => {
                    return { ...item.data(), id: item.id }
                }));
            })
    }
```

Nous mappons les docs à l'intérieur de nos données, ce qui retourne un élément. Ensuite, nous retournons les données à l'intérieur de l'élément, couplées avec l'id.

Cela donnera le résultat suivant :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-221407.jpeg)

Et c'est ce dont nous avons besoin. Stockons ces données à l'intérieur d'un état de tableau.

```
 const [notesArray, setNotesArray] = useState([]);
 
 const getNotes = () => {
        getDocs(dbInstance)
            .then((data) => {
                setNotesArray(data.docs.map((item) => {
                    return { ...item.data(), id: item.id }
                }));
            })
    }
```

Maintenant, nous devons mapper ce `notesArray` pour voir nos données dans l'interface utilisateur.

```
<div>
                {notesArray.map((note) => {
                    return (
                        <div>
                            <h3>{note.noteTitle}</h3>
                            <p>{note.noteDesc}</p>
                        </div>
                    )
                })}
            </div>
```

Cette fonction Array.map ciblera chaque élément à l'intérieur du tableau, et elle retournera son contenu.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-221852.jpeg)

Maintenant, donnons un peu de style à la façon dont nous affichons nos notes.

```
 <div className={styles.notesDisplay}>
                {notesArray.map((note) => {
                    return (
                        <div className={styles.notesInner}>
                            <h4>{note.noteTitle}</h4>
                            <p>{note.noteDesc}</p>
                        </div>
                    )
                })}
            </div>
```

J'ai ajouté un className aux divs, et un peu de style aussi.

```
.notesInner{
    margin-top: 0.5rem;
    border: 1px solid $dark-red;
    border-radius: 10px;
    width: 15rem;
    text-align: center;
    cursor: pointer;
    font-family: "Roboto";
}

.notesInner:hover{
    background-color: rgb(119, 27, 27);
    color: $whiteSmoke;
}
```

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-222429.jpeg)

Voici à quoi ressemble notre résultat maintenant :

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot--836-.png)

Il a également un effet de survol. Donc, si nous survolons un élément particulier, sa couleur de fond changera.

Maintenant, lorsque nous ajoutons une note, nous devons appeler la fonction getNotes. Cela garantira que nos nouvelles notes sont automatiquement actualisées. Ajoutez donc getNotes dans la fonction addDoc.

```
const saveNote = () => {
        addDoc(dbInstance, {
            noteTitle: noteTitle,
            noteDesc: noteDesc
        })
            .then(() => {
                setNoteTitle('')
                setNoteDesc('')
                getNotes();
            })
    }
```

Mais dans notre résultat, nous obtenons la description des notes avec des balises de paragraphe. Cela est dû au fait que React Quill envoie le style des balises, comme les balises d'en-tête, les balises de liste, etc. Si nous créons une liste en utilisant React Quill, il enverra les données dans des balises de liste.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-223117.jpeg)

Si nous sauvegardons cette note, nous obtiendrons les balises <ol> et <li> suivantes car nous avons ajouté une liste dans l'éditeur.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-223206.jpeg)

Maintenant, corrigeons ce format de sortie.

Nous utiliserons `dangerouslySetInnerHTML` pour rendre la sortie avec les balises.

```
<div dangerouslySetInnerHTML={{ __html: note.noteDesc }}></div>
```

Et maintenant, notre sortie a été corrigée.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-223440.jpeg)

## Afficher une note particulière dans la zone de droite.

Maintenant, nous devons afficher une note particulière dans le conteneur de droite lorsque nous cliquons sur cette note.

Alors, retirez le noteDesc du conteneur de gauche. Nous devons seulement afficher le titre à gauche.

Maintenant, nous avons besoin d'une fonction pour obtenir l'ID d'une note particulière lorsque nous cliquons sur cette note. Alors, créons une fonction.

```
 <div className={styles.notesInner}>
   <h4>{note.noteTitle}</h4>
 </div>
```

Mais, nous avons besoin de la fonction dans notre fichier principal index.js, et nous la passerons en tant que props dans le composant NoteOperations.

```
const getSingleNote = () => {

}
```

Et passez-la en tant que props dans NoteOperations.

```
<NoteOperations getSingleNote={getSingleNote}/>
```

Recevons-la dans le corps de la fonction du composant NoteOperations.

```
export default function NoteOperations({getSingleNote}){
	//Le reste du code ici..
}
```

Nous devons appeler cette fonction lorsque nous cliquons sur une note du côté gauche. Nous passons également l'ID de la note particulière lorsque nous cliquons dessus.

```
<div
  className={styles.notesInner}
  onClick={() => getSingleNote(note.id)}>
   <h4>{note.noteTitle}</h4>
</div>
```

Dans la fonction getSingleNote, dans notre fichier principal index.js, faisons un console.log de notre id pour voir si cela fonctionne ou non.

```
const getSingleNote = (id) => {
  console.log(id)
}
```

Cliquez sur le champ, nous devrions obtenir son ID dans la console.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-224717.jpeg)

Vous voyez, nous y arrivons.

## Comment afficher les notes en fonction de l'ID

Maintenant, créons un autre composant qui sera rendu dans le conteneur de droite. Nommez-le NoteDetails.js.

```
export default function NoteDetails() {
    return (
        <></>
    )
}
```

Et retournez ce composant dans la div du conteneur de droite.

```
import NoteDetails from './components/NoteDetails';

<div className={styles.right}>
	<NoteDetails />
</div>
```

Nous devons passer cet ID à ce composant, mais d'abord nous devons le stocker dans un état.

```
const [ID, setID] = useState(null);

const getSingleNote = (id) => {
   setID(id)
}
```

Ensuite, passez-le dans le composant NoteDetails en tant que props.

```
<NoteDetails ID={ID} />
```

Nous devons importer la base de données et l'application depuis le fichier firebaseConfig dans le composant NoteDetails. Importez également les packages React Quill.

```
import { app, database } from '../../firebaseConfig'
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
export default function NoteDetails() {
    return (
        <></>
    )
}
```

Nous devons recevoir l'ID dans le corps de la fonction et le déstructurer.

```
export default function NoteDetails({ID})
```

Maintenant que nous avons l'ID, nous devons cibler cette note spécifique.

Nous devons clarifier quelle note afficher, en fonction de cet ID. Pour cela, nous avons besoin de doc et getDoc depuis Firebase Firestore. Importez également le hook useEffect.

```
import { useEffect } from 'react'
import { app, database } from '../../firebaseConfig';
import { doc, getDoc } from 'firebase/firestore'
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
```

Créons une fonction pour obtenir une seule note.

```
const getSingleNote = () => {
        if (ID) {
            const singleNote = doc(database, 'notes', ID)
            const data = getDoc(singleNote)
            console.log({ ...data.data(), id: data.id })
        }
    }
```

Nous ciblons cette note en utilisant la fonction doc, puis nous stockons les données dans une variable data, en utilisant getDoc. Nous créons également une vérification. Le contenu de cette fonction ne s'exécutera que lorsque nous avons l'ID.

Placez cette fonction dans le hook useEffect. Ajoutez également l'ID dans le tableau de dépendances. Cela signifie que chaque fois que notre ID change, ce hook useEffect s'exécutera. Et il actualisera les données.

```
useEffect(() => {
  getSingleNote();
}, [ID])
```

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-30-235528.jpeg)

Mais si nous cliquons sur une note, nous obtenons une promesse. Nous devons donc utiliser Async Await pour gérer cela.

```
const getSingleNote = async () => {
        if (ID) {
            const singleNote = doc(database, 'notes', ID)
            const data = await getDoc(singleNote)
            console.log({ ...data.data(), id: data.id })
        }
    }
```

Si nous cliquons sur une note maintenant, nous obtiendrons les données correctes.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-000010.jpeg)

Cette note est un objet. Nous devons donc créer un état d'objet.

```
const [singleNote, setSingleNote] = useState({})
```

Ensuite, définissez les données à l'intérieur de cet état.

```
setSingleNote({ ...data.data(), id: data.id })
```

Affichons nos notes dans l'interface utilisateur maintenant.

```
return (
        <>
            <h2>{singleNote.noteTitle}</h2>
            <div dangerouslySetInnerHTML={{ __html: singleNote.noteDesc }}></div>
        </>
    )
```

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-000413.jpeg)

Et voici notre résultat. Cliquez sur une note du côté gauche, elle sera affichée ici.

Maintenant, si nous chargeons notre page, nous devons définir une note par défaut à afficher à droite. Nous devons donc obtenir toutes les notes dans le composant NoteDetails. Nous ajoutons [0] pour obtenir le premier index du tableau.

```
const getNotes = () => {
        getDocs(dbInstance)
            .then((data) => {
                setSingleNote(data.docs.map((item) => {
                    return { ...item.data(), id: item.id }
                })[0]);
            })
    }

    useEffect(() => {
        getNotes();
    }, [])
```

Importez également toutes les importations nécessaires dans le composant NoteDetails.

Si nous actualisons la page, nous obtiendrons la première note à droite.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-001353.jpeg)

## Comment modifier et supprimer une note

Ajoutons des fonctions pour modifier et supprimer une note. Nous avons donc besoin de deux boutons pour cela.

```
<div>
   <button>Modifier</button>
    <button>Supprimer</button>
 </div>
```

Ajoutons un peu de style.

```
<button className={styles.editBtn}>Modifier</button>
<button className={styles.deleteBtn}>Supprimer</button>
```

```
.editBtn, .deleteBtn{
    width: 5rem;
    height: 2rem;
    background-color: rgb(119, 27, 27);
    color: $whiteSmoke;
    border: none;
    cursor: pointer;
    margin: 10px 10px 10px 0;
}
```

Et nous avons maintenant deux boutons, pour modifier et supprimer.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-003038.jpeg)

Ajoutons la fonctionnalité de modification. Puisque nous avons l'ID, nous pouvons l'utiliser.

Nous voulons deux entrées et un bouton, et ils seront visibles lorsque nous cliquons sur le bouton de modification.

```
const [isEdit, setIsEdit] = useState(false);
```

Nous avons besoin d'un état pour masquer et afficher les champs de saisie. Et aussi une fonction pour définir cet état à vrai.

```
const getEditData = () => {
  setIsEdit(true);
}
```

Si cet état est vrai, nous afficherons nos entrées et notre bouton. Mais d'abord, créons-les.

```
{isEdit ? (
                <div className={styles.inputContainer}>
                    <input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill />
                    </div>
                    <button
                        className={styles.saveBtn}>
                        Mettre à jour la note
                    </button>
                </div>
            ) : (
                <></>
            )}
```

Nous avons également une condition. Si `isEdit` est vrai, nous afficherons les données dans les champs de saisie. Si c'est faux, nous n'afficherons rien.

Maintenant, définissons les valeurs.

```
{isEdit ? (
                <div className={styles.inputContainer}>
                    <input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                        value={singleNote.noteTitle}
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill
                            value={singleNote.noteDesc}
                        />
                    </div>
                    <button
                        className={styles.saveBtn}>
                        Mettre à jour la note
                    </button>
                </div>
            ) : (
                <></>
            )}
```

Mais si nous changeons le titre et le contenu de la note, ils ne changeront pas. Nous devons donc les définir dans un état.

```
const [noteTitle, setNoteTitle] = useState('');
const [noteDesc, setNoteDesc] = useState('');
```

```
<input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                        onChange={(e) => setNoteTitle(e.target.value)}
                        value={singleNote.noteTitle}
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill
                            onChange={setNoteDesc}
                            value={singleNote.noteDesc}
                        />
                    </div>
```

Mais encore, les valeurs ne changeront pas car l'état de onChange et la valeur sont différents. Cela signifie que si nous définissons les données en utilisant setNoteTitle ou setNoteDesc, les valeurs doivent être leurs états respectifs.

```
<div className={styles.inputContainer}>
                    <input
                        className={styles.input}
                        placeholder='Entrez le titre..'
                        onChange={(e) => setNoteTitle(e.target.value)}
                        value={noteTitle}
                    />
                    <div className={styles.ReactQuill}>
                        <ReactQuill
                            onChange={setNoteDesc}
                            value={noteDesc}
                        />
                    </div>
```

Et nous pouvons définir l'état dans la fonction getEditData.

```
const getEditData = () => {
        setIsEdit(true);
        setNoteTitle(singleNote.noteTitle);
        setNoteDesc(singleNote.noteDesc)
    }
```

Maintenant, si nous cliquons sur modifier, nous devrions obtenir nos données dans le champ de saisie et l'éditeur de texte.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-005800.jpeg)

Maintenant, utilisons la fonction updateDoc pour mettre à jour le champ sélectionné.

```
import { 
    doc, 
    getDoc, 
    getDocs, 
    collection,
    updateDoc
} from 'firebase/firestore'
```

Importez updateDoc depuis Firestore.

Créez une fonction pour mettre à jour le document lorsqu'il est cliqué.

```
const editNote = (id) => {
        const collectionById = doc(database, 'notes', id)

        updateDoc(collectionById, {
            noteTitle: noteTitle,
            noteDesc: noteDesc,
        })
    }
```

Nous devons passer cet id en tant que paramètre lorsque nous cliquons sur le bouton. Ajoutez cette fonction au bouton Mettre à jour la note.

```
<button
                        onClick={() => editNote(singleNote.id)}
                        className={styles.saveBtn}>
                        Mettre à jour la note
                    </button>
```

Changez le titre de la note ou le corps de la note, et elle sera modifiée.

![Image](https://www.freecodecamp.org/news/content/images/2022/01/Screenshot-2022-01-31-010422.jpeg)

Mais nous devons également changer les données dans notre interface utilisateur. Nous utiliserons donc une méthode appelée window.location.reload qui rechargera notre page.

```
const editNote = (id) => {
        const collectionById = doc(database, 'notes', id)

        updateDoc(collectionById, {
            noteTitle: noteTitle,
            noteDesc: noteDesc,
        })
            .then(() => {
                window.location.reload()
            })
    }
```

Enfin, ajoutons notre fonction de suppression pour supprimer une note.

Tout comme la fonction editNote, nous aurons une fonction deleteNote.

```
const deleteNote = (id) => {
        const collectionById = doc(database, 'notes', id)

        deleteDoc(collectionById)
            .then(() => {
                window.location.reload()
            })
    }
```

Cette fonction a un `collectionById` pour cibler quel document supprimer, puis le supprime en utilisant la fonction `deleteDoc`.

Ajoutez cette fonction au bouton Supprimer, et passez le singleNote.id comme son ID.

```
<button
    className={styles.deleteBtn}
    onClick={() => deleteNote(singleNote.id)}
  >Supprimer
</button>
```

Si nous cliquons sur le bouton de suppression maintenant, cette note ne sera plus là.

Félicitations – vous avez construit un clone d'EverNote !

## Conclusion

Alors, c'était tout sur comment construire un clone d'Evernote en utilisant NextJS et Firebase.

Vous pouvez améliorer ce projet en créant de meilleures conceptions d'interface utilisateur et d'expérience utilisateur selon vos besoins.

Vous pouvez consulter ma vidéo sur le même sujet à l'adresse [Créons un clone d'Evernote en utilisant NEXT JS et Firebase](https://youtu.be/3446IAFr1Tw), qui se trouve sur ma chaîne YouTube.

Et vous pouvez trouver le code complet ici : [https://github.com/nishant-666/Evernote-Next-Alt](https://github.com/nishant-666/Evernote-Next-Alt)

Merci d'avoir lu !

> Bon apprentissage.