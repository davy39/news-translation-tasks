---
title: Je viens de décrocher un poste de développeur chez Snapchat.
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2017-02-16T19:34:24.000Z'
originalURL: https://freecodecamp.org/news/a-dynamic-framework-for-finding-your-first-programming-job-b4eb0605b4f3
coverImage: https://cdn-media-1.freecodecamp.org/images/1*6u5CNLL0yg9gmSwtRs1aNg.jpeg
tags:
- name: JavaScript
  slug: javascript
- name: Life lessons
  slug: life-lessons
- name: 'self-improvement '
  slug: self-improvement
- name: startup
  slug: startup
- name: 'tech '
  slug: tech
seo_title: Je viens de décrocher un poste de développeur chez Snapchat.
seo_desc: 'By Jon Deng

  About a year ago, while deployed to Iraq as an Army officer, I started coding for
  fun. (You can read the whole story here.) Well, after a lot of studying, I landed
  my first job as a software engineer at Snapchat (Snap) in Venice Beach.

  Th...'
---

Par Jon Deng

Il y a environ un an, alors que j'étais déployé en Irak en tant qu'officier de l'armée, j'ai commencé à coder pour le plaisir. (Vous pouvez lire toute l'histoire [ici](https://medium.com/operation-code/fueling-the-how-i-learned-to-code-while-deployed-to-iraq-ef71d597fcaf#.olpp0lvoy).) Eh bien, après beaucoup d'études, j'ai obtenu mon premier emploi en tant qu'ingénieur logiciel chez Snapchat ([Snap](https://www.snapchat.com/)) à Venice Beach.

La recherche d'emploi n'a pas été facile. J'ai essuyé beaucoup de refus, de fausses pistes et de moments de doute. Mais cette expérience m'a aidé à développer un cadre mental pour aborder des activités qui ont une probabilité élevée de succès à long terme, mais une faible probabilité de succès un jour donné — des activités comme la recherche d'un premier emploi en tant qu'ingénieur logiciel.

Trouver mon emploi particulier était principalement dû à beaucoup de chance (bon timing, une connexion fortuite, une bonne année de financement pour les startups à Los Angeles), donc décrire les étapes spécifiques que j'ai suivies ne serait pas super utile pour vous. C'est parce que j'ai fait les mêmes choses que tout le monde vous dit de faire :

* construire des projets parallèles
* résoudre des problèmes pratiques
* développer votre réseau
* et postuler à un tas d'emplois

Les actions que vous entreprenez, et l'emphase que vous mettez sur chacune, varieront grandement en fonction de votre personnalité et de vos circonstances spécifiques. Cela dit, le cadre mental auquel je suis parvenu pendant ma recherche d'emploi peut vous aider, quelle que soit votre situation.

Je vais donc partager le processus de réflexion qui a finalement conduit à mon cadre mental, tout en vous donnant une rapide introduction à la [programmation dynamique](https://en.wikipedia.org/wiki/Dynamic_programming). J'espère que vous trouverez cela utile ?!

### Comment fonctionne une recherche d'emploi typique pour un développeur

En cherchant mon premier emploi de programmation, j'ai lu plusieurs récits personnels sur la façon dont d'autres programmeurs autodidactes et diplômés de bootcamps ont trouvé leur premier emploi. D'après leurs histoires, la recherche d'emploi semblait suivre un modèle très séquentiel :

1. apprendre à coder
2. affûter vos compétences
3. faire du réseautage
4. travailler sur des problèmes pratiques
5. postuler à des emplois
6. passer des entretiens
7. obtenir des offres d'emploi

En termes de structures de données, je l'imaginais comme le parcours des nœuds d'une liste chaînée.

![Image](https://cdn-media-1.freecodecamp.org/images/dHsKU1ZOSrX2v9-f4CKVuoNOSqod9Nu1b7Ow)
_Passons au suivant ! Image gracieuseté de [crunchify](http://crunchify.com/how-to-iterate-through-linkedlist-instance-in-java/" rel="noopener" target="_blank" title=")_

Je pense qu'un défaut courant lorsque les gens racontent leurs souvenirs (surtout s'ils travaillent comme ingénieurs depuis un certain temps), c'est qu'ils accordent trop d'importance aux relations de cause à effet entre les actions spécifiques qu'ils ont entreprises et le résultat qui s'est produit :

> _J'ai fait A, puis B s'est produit. Donc, A a causé B._

Parce qu'ils ont le bénéfice du recul, leur résultat semble déterministe. **Si vous suivez simplement les mêmes étapes, vous trouverez un bon emploi.**

**Oui. Et non.** D'après mon expérience, à long terme, si vous êtes vraiment engagé dans la programmation et que vous vous poussez constamment à vous améliorer, vous finirez par trouver un emploi digne de vos compétences (que vous ayez ou non un diplôme en informatique d'une certaine école de Palo Alto). La demande pour les ingénieurs logiciels est réelle et ne fait que croître. Mais à court terme, le processus est très aléatoire et repose sur de nombreuses variables que vous ne pouvez ni voir ni contrôler : les besoins en recrutement des entreprises, les tendances du marché, les technologies à la mode pour lesquelles les entreprises recrutent actuellement.

Lorsque j'ai commencé à chercher des emplois à Los Angeles, j'ai envoyé un tas de candidatures, essayant de trouver quelque chose — n'importe quoi. J'aurais codé en échange de nourriture gratuite et de t-shirts si quelqu'un m'avait offert l'opportunité. Voici quelques-unes des premières réponses que j'ai reçues :

> _Vous écrivez un code JavaScript propre et agréable. Et vous étiez super sympathique et nous avons apprécié parler avec vous. Cependant, nous ne vous avons pas vu coder de manière aussi productive que nécessaire. **Pour avancer avec les candidats juniors, nous devons voir un point fort exceptionnel, et nous n'avons pas vu assez d'une telle force chez vous** à ce stade. Cela signifie que nous ne pouvons pas travailler avec vous._

> _Nous pensons tous très bien de vous et chacun a apprécié vous interviewer, avec la conviction que votre motivation, votre éthique de travail et votre curiosité naturelle sont exactement ce que nous recherchons chez un candidat. Malheureusement, étant donné le calendrier où nous en sommes logistiquement, **nous recherchons quelqu'un avec plus d'expérience actuelle en développement front-end.**_

> _Désolé pour tous les retards. Ce processus est plus compliqué que je ne l'avais anticipé. **Je vous donnerai des nouvelles la semaine prochaine** lorsque nous serons plus proches de prendre une décision._

Puis **[silence]** pendant de nombreuses semaines.

Eh bien, c'était banane. J'ai fait un défi de codage qui m'a pris 6 heures et l'entreprise ne peut même pas m'envoyer un email de réponse ?

Recevoir chacun de ces emails (et les nombreuses non-réponses aussi) a été une expérience très douloureuse pour moi. Mais **ne gaspillez jamais une opportunité d'apprendre quelque chose d'utile de l'adversité**. En vous montrant le processus de réflexion que ma recherche d'emploi a inspiré, j'espère que cet article vous donnera un outil pour optimiser les choix que vous faites pendant la recherche d'emploi, et vous donnera l'inspiration pour continuer à vous rapprocher de votre objectif.

> « La douleur est inévitable, la souffrance est optionnelle » - Haruki Murakami

### Le problème du sac à dos

Permettez-moi d'illustrer les étapes que j'ai suivies pour arriver à mon cadre mental, en utilisant une variation d'une question courante d'entretien en informatique : [le problème du sac à dos](https://www.wikiwand.com/en/Knapsack_problem).

**MISE À JOUR : J'ai mis mon code dans un [dépôt GitHub](https://github.com/dengjonathan/jobSearch) avec une petite suite de tests, vous permettant de jouer avec le code et de développer une solution vous-même.**

Voici le problème :

Vous avez un ensemble d'activités que vous pouvez choisir de faire pour augmenter vos chances de trouver un emploi. Chaque activité prend un certain temps, mais procure une certaine quantité d'expérience. Nous n'avons qu'un temps limité pour nous préparer à la recherche d'emploi, donc nous ne pouvons pas tout faire. Notre objectif est de maximiser la quantité de points d'expérience en choisissant l'ensemble optimal d'activités.

Comment écrire une fonction qui choisira l'ensemble optimal d'activités à partir d'une liste d'activités disponibles et d'un temps limité ?

### Solution 1 : Force brute

En reformulant le problème, vous voulez choisir l'ensemble d'activités qui :

1. Prend un temps à accomplir qui est inférieur ou égal au temps total dont vous disposez
2. Maximise les points d'expérience (XP) retournés

La manière la plus intuitive est d'utiliser le même algorithme que nous utiliserions dans la vie quotidienne. Nous essaierions différentes combinaisons d'activités, en vérifiant si elles respectent notre contrainte de temps limité. Nous continuerions à chercher parmi toutes les combinaisons possibles et choisirions celle qui maximise l'XP.

Voici le code pour cet algorithme :

Le problème est que cette approche est vraiment complexe en termes de temps, ce qui signifie que lorsque la taille de notre entrée (nombre d'activités que nous pourrions choisir) augmente, le temps nécessaire pour calculer une solution augmente à un rythme beaucoup plus rapide.

Si nous avons 6 activités possibles, nous commençons par créer toutes les combinaisons possibles avec une seule activité, ce qui nous donne 6 combinaisons contenant une activité.

Ensuite, nous devons créer toutes les combinaisons possibles avec 2 activités. Pour chacune des 6 combinaisons originales, nous devons créer une combinaison avec chacune des 5 activités restantes (vous ne pouvez faire chaque activité qu'une seule fois).

Ensuite, pour créer toutes les combinaisons possibles avec 3 activités, nous devons prendre chacune de nos combinaisons contenant 2 activités et créer une combinaison avec chacune des 4 activités restantes.

Finalement, nous aurons quelque chose qui ressemble à (6 * 5 * 4 * 3 * 2 * 1), ce qui est O(n!). De plus, parce que nous additionnons tous les éléments de chaque combinaison à chaque fois pour calculer le temps total et l'XP, notre complexité temporelle finale est O(n! * n).

Imaginez que, au lieu d'exécuter cet algorithme sur un ordinateur qui peut effectuer des billions d'opérations par seconde, vous devez l'exécuter sur votre cerveau limité, qui prend en réalité 10 heures (dans un monde très optimiste) pour faire un projet parallèle afin d'apprendre un nouveau framework JavaScript MV*.

Et aussi, au lieu d'un choix de 6 activités, vous avez des milliers de choses possibles que vous pourriez faire pour vous préparer à la recherche d'emploi. (Il suffit de chercher « comment coder » sur Google).

**Il est complètement impraticable d'essayer toutes les combinaisons possibles d'activités pour vous préparer à la recherche d'emploi.** La leçon de cet exemple est qu'il y a une quantité presque infinie de choses que vous pourriez faire et qui augmenteront vos chances de trouver un emploi, mais vous ne pouvez pas toutes les essayer. Vous avez besoin d'une meilleure méthode pour déterminer votre ensemble optimal d'activités.

### **Retour sur trace**

Évidemment, en tant que programmeurs (et hackers ?), nous allons vouloir optimiser notre solution actuelle d'une manière ou d'une autre.

Essayons l'approche **BUD** de [Cracking the Coding Interview par Gayle McDowell](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X) (une ressource de préparation géniale, même si vos interviewers ne posent jamais de questions algorithmiques).

1. Quels **goulots d'étranglement** notre solution de force brute a-t-elle ?

Lors de la recherche du goulot d'étranglement, nous essayons généralement d'identifier la partie la plus complexe du processus, c'est-à-dire la partie _n!_ de notre algorithme _O(n! * n)_.

Le **goulot d'étranglement**, ou la partie la plus complexe de notre problème de recherche d'emploi, est le fait que nous devons créer dynamiquement de nombreuses combinaisons différentes et les essayer. Chaque fois que nous ajoutons une autre option, nous avons beaucoup plus de combinaisons possibles à essayer.

Maintenant, je dois admettre que je vous ai un peu induit en erreur. Mon problème de recherche d'emploi, en tant que variation du problème du sac à dos, fait partie d'un ensemble de problèmes appelés [NP-Difficile](https://www.wikiwand.com/en/NP-hardness). En bref, les problèmes sont NP-Difficiles lorsqu'il n'existe aucun moyen efficace connu pour résoudre le problème, ou vérifier qu'une solution à un problème est correcte. Donc, à moins que vous ne soyez un informaticien révolutionnaire, vous ne trouverez probablement pas de moyen objectivement efficace de combiner toutes les activités.

Mais ce n'est pas grave !!! **Parfois, lors des entretiens et de la recherche d'emploi, nous suivons de fausses pistes. Tant que nous apprenons quelque chose du processus, nous n'avons pas vraiment perdu de temps. Même si nous ne pouvons pas trouver un moyen globalement efficace de résoudre le problème, nous pouvons toujours trouver un moyen plus efficace que celui que nous utilisons actuellement.**

Alors, continuons.

2. Mon algorithme fait-il un **travail inutile** ou un **travail dupliqué** ?

C'est là que nous pouvons faire des gains majeurs sur notre solution.

Une chose que nous devrions changer est que pour chaque combinaison possible, nous devons parcourir toutes les activités de l'ensemble pour calculer le total des XP et le temps total de cet ensemble d'activités. C'est un travail dupliqué, car nous additionnons les mêmes valeurs encore et encore.

Si nous sauvegardions simplement le total des XP et le temps de la combinaison dans une variable, nous pourrions simplement ajouter les XP et le temps de chaque nouvelle activité que nous ajoutons au total. Cela réduirait notre solution de O(n! * n) à O(n!).

C'est utile, mais cela ne rend pas fondamentalement notre problème beaucoup plus rapide à exécuter.

Quelle autre optimisation pourrions-nous faire ?

Nous calculons également beaucoup de combinaisons qui ne pourraient pas mener à une solution valide. C'est un travail inutile.

Pour référence, voici la liste des activités à nouveau :

```
const ACTIVITIES = [  {name: 'side-project', time: 10, xp: 12},  {name: 'algorithms', time: 3, xp: 7},  {name: 'networking', time: 1, xp: 0.5},  {name: 'exercise', time: 2, xp: 1.5},  {name: 'systems design', time: 4, xp: 4},  {name: 'making CSS codepens', time: 3, xp: 4}];
```

Supposons que nous avons 8 heures au total pour nous préparer à notre recherche d'emploi. Comment notre algorithme de force brute vérifierait-il les combinaisons ?

En fonction de l'ordre du tableau ACTIVITIES, nous considérerions d'abord un ensemble incluant uniquement l'objet side-project. Il n'existe aucune solution valide contenant l'activité side-project car elle prend 10 heures à faire et nous n'avons que 8 heures au total.

Mais notre algorithme de force brute (étant de force brute) ne le sait pas et vérifiera donc toutes les combinaisons possibles que nous pouvons créer avec side-project.

Il vérifiera donc si [side-project, algorithms] est une solution valide. Ce n'est pas le cas.

Et il vérifiera si [side-project, algorithms, networking] est valide. Ce n'est pas le cas.

Et il vérifiera si [side-project, algorithms, networking, exercise] est valide. Ce n'est pas le cas.

Vous voyez combien de travail inutile nous faisons ?

Et si nous pouvions donner à notre algorithme un peu d'intelligence, afin qu'il puisse vérifier si notre état actuel (les activités que nous avons actuellement sélectionnées) peut mener à une solution valide ? Si les activités que nous avons actuellement sélectionnées peuvent mener à une solution valide (plus précisément, si notre ensemble sélectionné d'activités prend moins ou autant de temps que le temps total dont nous disposons en tant que paramètre de la fonction), alors nous continuons à sélectionner de nouvelles activités et vérifions si elles sont valides.

Sinon, nous arrêtons et désélectionnons la dernière activité que nous avons sélectionnée.

Par exemple, si nous avons un total de 8 heures, nous vérifierons d'abord si une combinaison contenant uniquement side-projects peut éventuellement mener à une solution valide. Comme nous l'avons déterminé précédemment, ce n'est pas possible, car cela prend plus de temps que nous n'en avons actuellement.

Nous désélectionnons donc side-projects et essayons différentes combinaisons commençant par algorithms. En vérifiant si nos activités actuellement sélectionnées pourraient mener à une solution valide, nous évitons d'avoir à vérifier l'une des combinaisons contenant side-projects, car elles ne pourraient pas mener à une solution valide.

Cette approche est appelée retour sur trace. Nous vérifions si l'endroit où nous en sommes pourrait mener à une solution valide, sinon, nous revenons en arrière d'un pas et essayons de faire un choix différent.

Voici le code :

Cette solution implémente les deux optimisations dont nous avons discuté précédemment :

1. Garder une trace du XP total et du temps afin de pouvoir le calculer en O(1) au lieu de faire la somme de l'ensemble complet à chaque fois en O(n)
2. Vérifier si notre ensemble actuel mènera à une solution valide avant d'ajouter récursivement un nouvel élément

Bien que le retour sur trace économise beaucoup de travail, il ne réduit pas vraiment la complexité globale du temps d'exécution de notre algorithme. Il est toujours O(n!), car nous vérifions toujours récursivement la plupart des combinaisons possibles.

Mais la mise en œuvre de l'algorithme de retour sur trace vous a probablement donné un indice sur la façon de continuer à travailler sur le problème. Dans la solution de force brute, nous devions assembler et vérifier l'ensemble de la combinaison pour chaque combinaison possible. Avec le retour sur trace, nous pouvons vérifier si le chemin que nous suivons mènera à une solution valide, avant d'assembler l'ensemble de la combinaison.

Hmmmmm...

**Y a-t-il un moyen de considérer uniquement si nous devons ajouter une autre activité à notre ensemble ou non ?** Ce serait un problème beaucoup plus facile que d'essayer de créer l'ensemble de la combinaison en une seule fois. Cela nous permettrait de diviser notre problème difficile (trouver la combinaison optimale) en une série de problèmes plus petits (décider si nous devons ajouter une seule activité ou non).

### Programmation dynamique

La programmation dynamique est une méthode où nous pouvons diviser notre grand problème d'**optimisation** (quelle combinaison d'activités dois-je choisir ?) en une série de problèmes de **décision** gérables (dois-je inclure cette activité dans ma solution optimale ou non ?). Nous divisons pour mieux régner.

La programmation dynamique est une méthode courante pour résoudre les problèmes NP-Difficiles comme le problème du sac à dos, et coïncidemment aussi une bonne façon de penser à la recherche d'emploi. Il est difficile de déterminer quelle combinaison d'activités vous rendra prêt pour la recherche d'emploi. Il n'existe aucun moyen efficace de trouver la combinaison optimale ou de vérifier si votre choix actuel est optimal.

Mais il est beaucoup plus facile de diviser votre période de temps en jours et semaines individuels, et d'essayer de déterminer quelles activités vous devriez faire pour chaque petite période de temps.

Pour résoudre notre problème de recherche d'emploi en utilisant la programmation dynamique, nous divisons le problème en une série de problèmes plus petits (comment optimiser une période de temps plus courte ?) puis prenons la solution de chacun des problèmes plus petits et les combinons en une solution plus grande.

Cela semble confus ? Passons en revue :

```
const ACTIVITIES = [  {name: 'side-project', time: 10, xp: 12},  {name: 'algorithms', time: 3, xp: 7},  {name: 'networking', time: 1, xp: 0.5},  {name: 'exercise', time: 2, xp: 1.5},  {name: 'systems design', time: 4, xp: 4},  {name: 'making CSS codepens', time: 3, xp: 4}];
```

**Quelle est la solution optimale si nous avons un temps total de t=0 (zéro) pour nous préparer ?**

Si nous n'avons pas de temps, nous ne pouvons faire aucune activité, donc nous retournons un ensemble vide, _[]_.

**D'accord, quelle est maintenant la solution optimale si nous avons un temps total de t=1 ?**

D'abord, voyons quelles activités sont possibles à faire : nous ne pouvons pas faire un projet parallèle (temps t=10) ou étudier les algorithmes (temps t=3). La seule chose que nous pouvons faire est le réseautage (temps t=1).

Nous devons donc décider si l'ajout du réseautage à la solution optimale pour le temps t=0 mènera à une solution optimale.

Si nous ajoutons le réseautage, nous obtenons un XP total de 0,5, ce qui n'est pas mal.

Si nous n'ajoutons pas le réseautage, nous ne pouvons pas vraiment faire autre chose, donc nous obtenons un XP total de 0.

0,5 est toujours mieux que 0, donc si nous n'avons qu'un temps total de t=1, nous devrions faire du réseautage. La solution optimale pour le temps t=1 est _[networking]_.

**Quelle est la solution optimale pour le temps t=2 ?**

Quelles activités sont possibles avec un temps t=2, que nous n'avons pas déjà considérées ? Juste _exercise_.

Si nous choisissons d'ajouter exercise, qui prend un temps t=2, nous n'avons plus de temps pour faire autre chose, donc notre solution est _[exercise]_, ce qui donne 1,5 XP.

Nous comparons la solution optimale incluant exercise (qui donne 1,5 XP) et la solution optimale n'incluant pas exercise (qui donne 0,5 XP). Puisque la solution contenant exercise est meilleure, nous choisissons celle-ci (dans la vraie vie, je pense aussi qu'avec un temps très limité, un peu d'auto-soin est toujours plus utile que plus de préparation ?).

Maintenant, voici où cela devient vraiment intéressant : **Quelle est la solution optimale pour le temps t=3 ?**

Encore une fois, quelles activités sont possibles pour un temps t=3 ?

Nous avons l'option de choisir parmi _[algorithms, exercise, networking]_.

Si nous choisissons _algorithms_ qui prend un temps t=3, nous n'avons pas de temps pour faire autre chose, donc une solution possible est _[algorithms]_.

Si nous choisissons _exercise_ qui prend un temps t=2, il nous reste un temps t=1 pour faire autre chose ? Comment savons-nous quoi choisir pour le temps restant ?

Nous savons que la solution optimale pour un temps t=1 est _[networking]_, donc nous n'avons pas à la recalculer. Nous savons que nous ne pouvons pas faire mieux que la solution optimale pour un temps t=1.

Donc une solution possible est _[exercise, networking]_.

Encore une fois, nous comparons toutes les solutions possibles et voyons que le mieux que nous pouvons faire est _[algorithms]_.

C'est la structure de base d'une solution de programmation dynamique : à chaque quantité de temps, nous testons la décision d'ajouter ou non une activité spécifique. Nous comparons toutes les solutions possibles et déterminons la solution optimale.

Les solutions pour des quantités de temps plus grandes s'appuient sur les solutions optimales pour le même problème avec une quantité de temps plus petite. Cela nous permet d'appeler la fonction de programmation dynamique de manière récursive.

Pour mon exemple, j'ai choisi de trier le tableau des activités par le temps qu'il faut pour les compléter (du plus petit au plus grand). Cela nous permet de déterminer rapidement quels éléments sont possibles dans le temps donné car ils sont triés par temps.

Voici le code :

Wooooo ! Si vous avez réussi à comprendre cet exemple du premier coup, alors vous êtes un apprenant bien plus rapide que moi. J'espère que cela a été intéressant pour trouver des moyens alternatifs de résoudre des questions algorithmiques difficiles !

Enfin, quel est le but de cette série de trois exemples, pourriez-vous demander ?

Non seulement je vous ai discrètement donné un peu de pratique sur une question très similaire à celles que vous pourriez rencontrer lors d'entretiens techniques, mais je vous ai également montré les étapes que j'ai suivies pour arriver à mon cadre mental.

Il existe une quantité presque infinie de combinaisons d'activités que vous pourriez faire, et il n'existe aucun moyen efficace de déterminer l'ensemble optimal d'activités que vous devriez faire. Beaucoup de chemins ne mènent pas à une solution valide, tout comme beaucoup de candidatures et d'entretiens ne mèneront pas à un emploi.

Vous pourriez essayer toutes les combinaisons possibles d'activités de recherche d'emploi (force brute), mais comme nous sommes des êtres humains avec un temps limité, ce n'est pas un moyen efficace d'atteindre notre objectif.

Nous pourrions optimiser notre approche en évaluant à chaque étape si notre approche mènera à notre objectif (retour sur trace). Par exemple, si nous contactons constamment des recruteurs tiers pour nous aider à trouver des pistes d'emploi, et que les recruteurs n'ont pas été très utiles pour générer des entretiens, peut-être devrions-nous revenir en arrière et considérer une activité différente.

Enfin, comme la recherche d'emploi n'est pas une affaire d'un jour, nous pourrions essayer d'optimiser chaque jour et combiner les jours ensemble (programmation dynamique). De cette façon, nous avons un problème gérable à traiter (devrais-je étudier les algorithmes aujourd'hui ?) plutôt qu'un problème vraiment difficile (que devrais-je faire le mois prochain pour me préparer à la recherche d'emploi ?).

Enfin, je tiens à souligner qu'avec les trois approches, même si elles n'étaient pas objectivement efficaces, nous avons finalement atteint une solution. Pendant la recherche d'emploi, il est vraiment important de se rappeler qu'à long terme, vous atteindrez votre objectif, et de continuer à avancer chaque jour.

### Mes conseils pour gérer votre recherche d'emploi de développeur

Je vais succomber à ma tentation de vous donner deux conseils tirés de mon expérience.

1. Il est super difficile de juger votre propre performance pendant les entretiens et les défis de codage — alors concentrez-vous simplement sur le processus. Vous ne saurez pas pendant l'entretien ou immédiatement après si vous vous en sortez bien ou mal.
2. Le succès ou l'échec sont éphémères et ne devraient pas déterminer votre bonheur.

Si vous cherchez votre premier emploi de programmation, j'espère que la lecture de ceci a été utile ou au moins inspirante pour vous — regardez, [un duffer sans talent](https://www.reddit.com/r/funny/comments/4uc5od/despite_a_reputation_for_stupidity_the_shoebill/) comme moi a trouvé un super emploi ! Bonne chance et je voudrais conclure en partageant le meilleur conseil qui m'a été donné pendant ma recherche d'emploi :

> « Ne vous inquiétez pas de savoir si vous êtes assez bon, inquiétez-vous de savoir si vous aimez la programmation et si vous êtes prêt à travailler assez dur. Si vous faites ces deux choses, vous y arriverez. » — paraphrasé d'Edgar Pabon sur le [podcast Breaking Into Startups](http://breakingintostartups.com/edgar-pabon/)

Merci d'avoir lu, et bonne chance avec votre recherche d'emploi !