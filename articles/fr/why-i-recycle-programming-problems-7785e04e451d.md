---
title: Pourquoi je recycle des problèmes de programmation
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2018-12-17T21:39:04.000Z'
originalURL: https://freecodecamp.org/news/why-i-recycle-programming-problems-7785e04e451d
coverImage: https://cdn-media-1.freecodecamp.org/images/0*KxFwlFwFIJrpwAYe
tags:
- name: learning to code
  slug: learning-to-code
- name: General Programming
  slug: programming
- name: 'self-improvement '
  slug: self-improvement
- name: 'tech '
  slug: tech
- name: technology
  slug: technology
seo_title: Pourquoi je recycle des problèmes de programmation
seo_desc: 'By Amy M Haddad

  Many programmers are given the same advice: solve as many problems as possible.
  It’s true that solving new problems can help you gain experience and enhance your
  knowledge. I, too, seek out new problems and projects.

  But I’ve found it...'
---

Par Amy M Haddad

De nombreux programmeurs reçoivent le même conseil : résoudre autant de problèmes que possible. Il est vrai que résoudre de nouveaux problèmes peut vous aider à acquérir de l'expérience et à améliorer vos connaissances. Moi aussi, je cherche des [nouveaux problèmes](https://medium.freecodecamp.org/the-one-question-i-shouldve-asked-before-learning-to-program-17b6d3a629b7) et des projets.

Mais j'ai trouvé tout aussi important de recycler les problèmes : les répéter plusieurs fois, chaque fois avec une intention différente. Il y a beaucoup à gagner de la répétition avec un but.

### Savoir ce que je ne sais pas

Le fait d'avoir résolu un problème une fois ne signifie pas toujours que je peux le résoudre à nouveau.

J'étais à la bibliothèque l'autre jour, en train de travailler sur un problème que j'avais terminé plus tôt dans la semaine, quand je me suis retrouvé bloqué. En quelques jours, j'avais oublié comment résoudre le problème. Au lieu de le faire facilement, je me suis retrouvé à lutter : travaillant à travers erreur après erreur.

Cette expérience m'a montré que je dois travailler davantage sur les conditionnelles et les fonctions. Des situations similaires se sont produites auparavant, c'est pourquoi recycler les problèmes est important : cela teste mes connaissances et révèle mes points faibles.

Résoudre des problèmes renforce également les concepts. C'est bien que je puisse résoudre un problème qui utilise des classes lorsque je les étudie et que le matériel est frais dans mon esprit. Mais puis-je me rappeler comment utiliser des classes une ou deux semaines plus tard ? Faire une deuxième passe sur un problème est un moyen de le découvrir.

### Anciens problèmes, nouveaux trucs

Ajouter des contraintes auto-imposées est une deuxième façon dont je recycle les problèmes de programmation. Par exemple, j'ai récemment utilisé une boucle for pour résoudre un problème impliquant des pangrammes. La deuxième fois, je me suis imposé une contrainte simple : résoudre le problème à nouveau *sans* boucle for. En d'autres termes, je devais essayer une autre approche.

J'ai donc essayé d'utiliser un ensemble, et mon programme est devenu plus propre et plus lisible. Ensuite, je suis allé plus loin avec une autre contrainte : résoudre le problème avec une autre variation d'un ensemble. Au total, j'ai réduit la quantité de code pour ce programme de plus de 50 %. Et j'ai beaucoup appris sur les ensembles dans le processus !

Parfois, les contraintes finissent par compliquer mon code. Dans un problème recyclé, je me suis imposé la contrainte d'utiliser une boucle while, et le programme est devenu long et complexe ; la boucle for que j'avais utilisée dans une itération précédente était une meilleure option. Même ainsi, répéter un problème avec une contrainte m'a aidé à comprendre quand il est avantageux d'utiliser une approche plutôt qu'une autre.

Quoi qu'il en soit, répéter un problème avec des contraintes me sort de ma zone de confort et me fait réfléchir de manière nouvelle et créative. Je me retrouve généralement bloqué et je dois faire des recherches. Dans le processus, je découvre des détails que j'avais négligés et j'apprends de nouvelles façons de faire les choses.

### Apprendre à écrire des tests

Je suis à ma troisième reprise des dizaines de problèmes dans le livre de Brian Hogan *Exercises for Programmers*. J'ai eu une intention différente pour chaque itération. Cette fois-ci, je m'entraîne à écrire mes propres tests.

Voici comment cela fonctionne : je choisis un problème au hasard dans le livre de Hogan et je le résous. J'organise le programme en fichiers séparés ; chaque fichier est responsable d'une partie différente de la solution. Ensuite, j'écris les tests. En fin de compte, je veux écrire les tests d'abord, puis écrire le code, mais je n'en suis pas encore là. En attendant, je m'entraîne beaucoup à écrire et à extraire des fonctions et à importer des fichiers.

Il y a un point plus large à la répétition intentionnelle : elle m'aide à voir des schémas et à les solidifier dans mon esprit, afin que je puisse les utiliser comme modèles mentaux pour de nouveaux problèmes. C'est le conseil que donne George Polya dans son livre *How to Solve It*. Lorsqu'il aborde un nouveau problème, il recommande de "chercher des contacts avec vos connaissances acquises précédemment". Il poursuit :

> *"Essayez de penser à ce qui vous a aidé dans des situations similaires par le passé. Essayez de reconnaître quelque chose de familier dans ce que vous examinez, essayez de percevoir quelque chose d'utile dans ce que vous reconnaissez."*

Il a raison. J'ai récemment terminé un problème où je devais identifier des anagrammes. Avant de taper une ligne de code, je me suis rappelé un problème d'anagramme similaire que j'avais résolu quelques semaines auparavant. Bien que le problème original soit beaucoup plus facile que celui en question, il m'a donné un point de départ.

Recycler des problèmes avec une intention spécifique a été extrêmement bénéfique. Cela solidifie les concepts, me donne une exposition à de nouveaux concepts et construit une base solide de connaissances, et c'est ce que je recherche en tant que programmeur débutant.

*Je suis une écrivaine, écrivant sur la technologie, la productivité et l'art ([amymhaddad.com](https://amymhaddad.com/)), et une programmeuse débutante.*