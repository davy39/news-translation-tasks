---
title: 'Le réseau des anciens de freeCodeCamp : Un réseau de mentorat maison pour
  les anciens de FCC'
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2017-06-25T15:43:06.000Z'
originalURL: https://freecodecamp.org/news/the-freecodecamp-alumni-network-a-homegrown-mentorship-network-for-fcc-alumni-529e4531c34f
coverImage: https://cdn-media-1.freecodecamp.org/images/1*uzAGnPWq3n77VgIY8yujAQ.png
tags:
- name: JavaScript
  slug: javascript
- name: React
  slug: react
- name: 'self-improvement '
  slug: self-improvement
- name: startup
  slug: startup
- name: technology
  slug: technology
seo_title: 'Le réseau des anciens de freeCodeCamp : Un réseau de mentorat maison pour
  les anciens de FCC'
seo_desc: 'By peterWeinberg

  For the last year, I’ve been spending nearly all my free time learning to code.
  I’ve been a regular freeCodeCamp contributor, working on various projects such as
  the new React and Beta curriculums, the Testable Projects, a CDN-loaded...'
---

Par peterWeinberg

Depuis un an, j'ai passé presque tout mon temps libre à apprendre à coder. J'ai été un contributeur régulier de freeCodeCamp, travaillant sur divers projets tels que les nouveaux programmes [React](http://hysterical-amusement.surge.sh/) et [Beta](https://beta.freecodecamp.com/), les [Projets Testables](https://github.com/freeCodeCamp/testable-projects-fcc), une suite de tests front-end chargée via CDN.

Mais il y a environ 3 mois, j'ai décidé de faire un grand pas en avant dans mes compétences en codage. J'avais un seul critère : je voulais relever mon plus grand défi de codage à ce jour.

Le résultat final est le fruit des efforts de 2 Campeurs, 60 jours de développement et des centaines d'heures de travail. Et, bien sûr, un projet que je suis incroyablement excité de présenter : le [Réseau des Anciens de freeCodeCamp](http://www.fcc-alumni.com/) (FCCAN) !

FCCAN est une extension de la communauté freeCodeCamp, où les détenteurs d'au moins un certificat freeCodeCamp peuvent venir pour se connecter.

En bref, notre objectif est de promouvoir des relations significatives parmi les campeurs expérimentés. Surtout ceux qui cherchent à améliorer leurs compétences et/ou à partager leur expertise avec d'autres Campeurs. Voici quelques fonctionnalités que nous savons que vous allez adorer :

* **Authentification utilisateur transparente**. Connectez-vous en utilisant votre compte GitHub et vérifiez avec vos identifiants freeCodeCamp.
* **Opportunités de mentorat**. Un programme de mentorat optionnel pour les mentors et mentorés potentiels.
* **Profil personnel**. Identifiez les compétences et intérêts en codage, les statistiques personnelles, le statut de mentorat, et plus encore.
* **Recherche de membres**. Un moteur de recherche pour vous aider à trouver d'autres membres (et mentors potentiels) en fonction des compétences, des intérêts, de la localisation, et plus encore.
* **Collaboration**. Vous cherchez de l'aide pour votre nouvelle application ? Partagez vos projets open source avec d'autres Campeurs ici.
* **Rester en contact**. Vous avez identifié un mentor potentiel ? Contactez-le via le chat privé de FCCAN, ou visitez la salle publique pour parler de tout ce qui concerne le code.

FCCAN est une plateforme pour vous aider à porter vos relations avec vos camarades Campeurs au niveau supérieur.

Mais pour réaliser pleinement cette vision, nous avons besoin de vous, les Campeurs, pour nous accompagner dans cette aventure. Nous vous invitons à visiter l'application et à consulter notre page à propos. Si vous êtes intrigué, inscrivez-vous et voyez de quoi il s'agit !

Notre nouvelle adresse est [www.fcc-alumni.com](http://www.fcc-alumni.com).

Il y a toujours place à l'amélioration, mais nous sommes assez satisfaits du MVP que nous avons, et nous espérons que vous le serez aussi.

Dans l'esprit de freeCodeCamp et des logiciels open source, ce projet est 100 % open source. Nous vous encourageons à consulter [le dépôt](https://github.com/FCC-Alumni/alumni-network) et à explorer la base de code.

Le développement actif de ce projet se poursuivra, donc si vous trouvez un bug ou avez une suggestion pour une fonctionnalité, n'hésitez pas à [ouvrir une issue](https://github.com/FCC-Alumni/alumni-network/issues/new). Si vous êtes intéressé à contribuer, nous avons déjà recueilli [quelques suggestions](https://github.com/FCC-Alumni/alumni-network/issues) de notre équipe et de nos bêta-testeurs pour lesquelles nous aimerions de l'aide ! Veuillez consulter nos [directives de contribution](https://github.com/FCC-Alumni/alumni-network/blob/master/CONTRIBUTING.md) si vous souhaitez en savoir plus.

Maintenant que vous avez vu le projet (et créé un profil totalement génial !), j'espère que vous resterez pour entendre notre histoire.

Il y a trois mois, je pensais que coder quelque chose de ce niveau était quelque chose que je ne pourrais jamais faire. Un sentiment que je sais que beaucoup de Campeurs peuvent comprendre.

Alors si vous êtes intrigué, continuez à lire pour en savoir plus sur **le** **Réseau des Anciens de freeCodeCamp** et comment deux anciens de freeCodeCamp ont développé une application web full-stack complexe en seulement deux mois.

J'ai commencé à coder il y a un peu plus d'un an, et mon parcours a été celui d'un apprentissage complètement autodidacte. Tout au long de cette courte histoire, je me suis presque entièrement appuyé sur [freeCodeCamp](https://freecodecamp.com/) pour aiguiser mes compétences.

Pendant cette période, j'ai acquis quelques compétences de base en JavaScript, React, HTML5, CSS3 et Sass. Vous reconnaîtrez peut-être ces compétences comme étant parmi les compétences de base prônées dans le programme actuel de freeCodeCamp.

Et bien que j'aie accompli beaucoup de choses, j'ai constaté que j'avais atteint une sorte de plateau. Ce qui semblait être un progrès rapide pour mon cerveau totalement non orienté vers la technologie, ne me positionnait en réalité que comme un programmeur de niveau débutant.

Je savais que j'avais besoin d'un arsenal de compétences beaucoup plus solide. Mais, passer de projets front-end de base au développement d'applications full-stack de niveau production à partir de zéro semblait être un fossé que je ne pourrais jamais combler. Mais, je savais que je devais somehow, alors j'ai commencé à explorer de nouvelles avenues.

Une chose que j'ai découverte, c'est que j'apprenais beaucoup plus et beaucoup plus vite lorsque je travaillais avec d'autres programmeurs. Alors j'ai contacté [Chance McAlister](https://medium.com/@tropicalchancer) (aka [Chance Taken](https://www.freecodecamp.org/news/the-freecodecamp-alumni-network-a-homegrown-mentorship-network-for-fcc-alumni-529e4531c34f/undefined)), le père et organisateur des [Chingu Cohorts](https://chingu-cohorts.github.io/chingu-directory/). Chance défend régulièrement les projets de groupe au sein des Cohorts, et il m'a mis en contact avec une équipe qui venait de terminer un projet de leur propre.

Le projet était Campfire Stories (une application centrée sur freeCodeCamp qui raconte les histoires des campeurs), et ils avaient besoin d'un peu d'aide pour maintenir et améliorer [leur base de code héritée](https://github.com/mmhansen/campers-of-fcc). Alors j'ai eu un appel avec l'un des créateurs pour me mettre à jour. Et wow... la complexité et l'architecture de l'application étaient tout simplement trop pour que je puisse suivre.

Même si j'étais principalement familier avec leur technologie, la structure et les paradigmes de codage semblaient totalement étrangers pour moi. J'étais encore plus en retard que je ne l'avais réalisé, et j'ai quitté cet appel en me sentant un peu découragé. Toute la confiance que j'avais acquise au cours des derniers mois avait presque disparu.

Comment allais-je jamais apprendre tout cela ? Le back-end était complètement intimidant, je comprenais à peine la gestion d'état, et les vues complexes étaient plus que je ne pouvais gérer.

Cela m'a pris quelques jours, mais j'ai finalement surmonté mon défaitisme. Aussi confondu que j'étais par la complexité de la base de code de Campfire Stories, j'en suis sorti en me sentant plus motivé que jamais pour accomplir le travail. C'était juste mon approche qui était fausse.

La recette de mon succès, je m'en suis rendu compte, était de construire et de définir l'architecture à partir de zéro. Ainsi, je pourrais suivre le processus de zéro à complexe à chaque étape.

![Image](https://cdn-media-1.freecodecamp.org/images/1*tIGNCZfGqd0h5XobGRLrJQ.jpeg)

Alors, après cette première tentative ratée, j'ai décidé que le moment était venu d'essayer une idée à moi.

Inspiré par Campfire Stories, je voulais aussi construire une application liée à freeCodeCamp. L'une de mes choses préférées à propos de freeCodeCamp est les histoires de succès que j'entends souvent, sur les personnes "diplômées" de freeCodeCamp, et obtenant des emplois de codage dans le monde réel.

Ces histoires sont une partie importante du succès des autres campeurs. Savoir qu'il y a un pot d'or au bout de l'arc-en-ciel est une énorme motivation !

Avec cela en tête, j'ai imaginé un endroit où les campeurs pourraient venir pour se connecter et suivre les accomplissements des uns et des autres. L'idée changerait un peu avec le temps, mais c'était assez pour lancer le projet. Je l'ai présenté à Chance, qui m'a aidé à [développer l'idée un peu plus](https://docs.google.com/document/d/1NbBddbO3xeOdsQv8rIRgJJ6QDiC-gpJxGMSWmMcup9E/edit?usp=sharing), et peu après, nous avions formé une équipe.

J'étais assez excité, c'était exactement le genre de projet dont j'avais besoin pour faire passer mes compétences là où je les voulais ! Une fois que nous avions défini à quoi ressemblerait notre produit minimum viable (MVP), il était clair que ce projet allait être plutôt ambitieux pour quelques programmeurs de niveau débutant. Nous aurions besoin de :

* Une inscription/utilisateur fonctionnelle
* Une base de données pour stocker les données utilisateur
* Une interface pour que les utilisateurs puissent entrer, éditer et maintenir les données personnelles
* Un moyen pour les utilisateurs de communiquer entre eux au sein de l'application
* Une fonction de recherche pour que les utilisateurs puissent se trouver les uns les autres
* Un routage efficace d'une vue à l'autre
* Une gestion d'état pour gérer l'état complexe de l'application

Et cela n'était que pour nous lancer ! Mon vœu se réalisait — cela s'annonçait comme le projet le plus complexe et le plus difficile que j'aie jamais entrepris.

Nous avons défini notre stack technologique et nous nous sommes mis au travail. Nous avons opté pour le classique freeCodeCamp, et choisi ReactJS comme framework JavaScript, et en embrassant pleinement ce choix, Redux et React-Redux étaient des ajouts naturels au mélange pour la gestion d'état. Une base de données MongoDB, et un back-end Express/NodeJS complétaient le cœur de notre application. Nous avons démarré notre projet avec Create-React-App, apporté quelques ajustements pour la prise en charge de Sass, installé une armée de packages NPM, et nous étions en route.

Jusqu'à ce point, j'avais fait assez de recherches pour savoir ce que chacune de ces technologies était. Mais à part React et Sass, je n'avais jamais touché à une seule d'entre elles. Inutile de dire que cela allait être un défi pour moi.

Pourtant, grâce à un peu de programmation en binôme et en travaillant très étroitement avec mon coéquipier, [Sean Smith](https://github.com/bonham000/), j'ai pu surmonter chaque obstacle technologique que j'ai rencontré.

Après avoir configuré Create-React-App pour qu'il fonctionne avec un serveur proxy, notre première étape a été de mettre en œuvre l'authentification et l'inscription des utilisateurs. Cela a été un défi de taille — nous voulions découpler l'inscription de l'application elle-même (moins de données sensibles à gérer pour nous, moins de noms d'utilisateur et de mots de passe pour vous). Ainsi, activer la connexion basée sur GitHub via PassportJS semblait être la voie à suivre.

Cependant, nous devions également mettre en œuvre un processus de vérification des utilisateurs, car nous voulions imposer que les membres soient réellement des anciens de freeCodeCamp (c'est-à-dire des campeurs qui ont obtenu au moins un certificat). Après avoir mis au point une [technique de redirection de point de terminaison](https://github.com/FCC-Alumni/alumni-network/blob/master/server/routes/user.js#L36) pour vérifier les certificats des utilisateurs en utilisant [Axios](https://github.com/mzabriskie/axios), nous étions enfin sur la bonne voie !

C'était ma toute première introduction à la programmation back-end, et une étape majeure pour l'application. Maintenant que nous pouvions nous connecter et nous déconnecter avec succès, le vrai travail pouvait commencer.

![Image](https://cdn-media-1.freecodecamp.org/images/1*9QmAYefRENjR3y5coJrsZg.gif)
_Notre première itération réussie de connexion et d'inscription des utilisateurs (mention spéciale à la Cohorte Chingu Penguins !)._

![Image](https://cdn-media-1.freecodecamp.org/images/1*CfSrNSx-PBOmkF-Nl1vtBg.gif)
_Nous avons parcouru un long chemin : Un aperçu de notre processus actuel d'authentification des utilisateurs._

Ensuite, nous avons abordé la gestion d'état. Par exemple, pour créer la page de profil utilisateur, le cœur de l'expérience utilisateur FCCAN, nous devions implémenter la fonctionnalité CRUD, ou Create, Read, Update, et Delete.

La page des préférences est hautement éditable — plus d'une douzaine de champs rend l'état assez compliqué, trop complexe pour que React puisse le gérer seul. C'était un travail pour Redux. Cela signifiait que nous gérions l'état sur 3 niveaux séparés couvrant les deux extrémités de la pile : avec React, au niveau du Composant, avec Redux au niveau du Store, et avec MongoDB au niveau de la base de données.

Découvrir comment manipuler et gérer efficacement un objet d'état complexe s'est avéré un défi de taille. Pourtant, une fois que nous l'avons maîtrisé, nous avons pu réutiliser ce même paradigme encore et encore tout au long de l'application.

Voici un autre excellent exemple, qui, contrairement à notre exemple CRUD, utilise uniquement React et Redux (voir le gif ci-dessous) :

![Image](https://cdn-media-1.freecodecamp.org/images/1*D7iyuTifOZpvuOrRppK7_g.gif)

Remarquez que même si j'ai navigué loin de la page de recherche, lorsque je reviens, l'état existe exactement comme il était lorsque je suis parti.

L'état géré localement par React est effacé dès qu'un composant est démonté, mais transmettre cet état à Redux nous permet de préserver cet état au-delà du cycle de vie d'un composant React, et le transmettre à la base de données si nécessaire nous permet de préserver cet état au-delà du cycle de vie d'un store Redux, qui existe intrinsèquement seulement aussi longtemps qu'une session utilisateur est persistée.

L'implémentation la plus complexe de la fonctionnalité CRUD dans l'application FCCAN est notre fonctionnalité de chat. Bien que cela ne semble pas être une implémentation typique de CRUD, les principes de base sont exactement les mêmes.

En gros, la base de données est notre seule source de vérité. Pour toute action CRUD, nous envoyons une requête POST à une route qui gère cette action. Si, et seulement si, nous obtenons une réponse réussie du serveur (indiquant que la base de données est à jour avec cette action), nous diffusons ensuite une mise à jour en temps réel via Socket.IO. Simultanément, nous envoyons une action qui effectue une mise à jour de l'UI via Redux, où les données de chat sont persistées en utilisant des structures de données ImmutableJS.

De cette manière, nous ne montrons une mise à jour à un utilisateur que si nous avons réellement mis à jour les données dans la base de données en premier. En utilisant ce modèle, nous avons pu implémenter certaines fonctionnalités de chat de base, y compris les likes, l'édition et la suppression de messages, et juste pour le plaisir, quelques emojis plutôt cool !

Tout en continuant à cocher les cases de notre liste de fonctionnalités MVP, nous devions prendre en compte la conception à chaque étape. De cette perspective, notre décision précoce d'adapter Semantic-UI comme bibliothèque CSS s'est avérée judicieuse. Nous l'avons largement utilisé et avons été très satisfaits de son style élégant et facile à travailler, de ses options de mise en page, de son intégration Semantic-UI-React, et de ses capacités de conception réactive bien pensées. En ce qui concerne ce dernier point, nous avons parfois complété Semantic avec [React-Screen-Size](https://github.com/eloytoro/react-screen-size), lorsque les points de rupture et les requêtes média par défaut n'étaient pas suffisants.

Pour un contrôle plus granulaire du style, nous avons complété Semantic avec quelques feuilles de style Sass personnalisées et [Styled-Components](https://github.com/styled-components/styled-components). Styled-Components est un package CSS/JavaScript plus récent pour React qui permet un CSS plus intuitif et rendu conditionnellement, écrit directement dans vos fichiers de composants. Je vous recommande vivement de le vérifier.

Une fois que nous avions notre fonctionnalité de base en place, nous étions prêts pour notre prochaine grande étape : le déploiement.

Je n'avais jamais déployé d'application auparavant, et j'ai rapidement découvert que cela apportait avec lui un tout nouveau ensemble de défis.

Nous avons configuré Heroku, souscrit à des instances hébergées dans le cloud de MongoDB et Redis, et après des heures de dépannage et 19 commits plus tard, nous avions atteint un autre jalon majeur. Une version bêta de FCCAN était enfin en ligne !

![Image](https://cdn-media-1.freecodecamp.org/images/1*P2gSJFQiYiNF2GUL2veUMQ.png)
_Le déploiement a l'air amusant ? Ce n'était pas le cas._

Bien que cela n'ait pas été aussi glorieux que je l'avais espéré. Une fois l'application en ligne, de nouvelles préoccupations ont immédiatement été mises en lumière. Pour une chose, nous avions besoin d'une UI mobile beaucoup plus robuste (que nous n'avions pas pu tester de manière fiable jusqu'à ce point). Et, bien sûr, la compatibilité multi-appareils était un problème majeur.

Mais, nous étions dans la ligne droite. Presque arrivés, nous étions tous les deux extrêmement motivés à voir ce projet jusqu'à son achèvement.

![Image](https://cdn-media-1.freecodecamp.org/images/1*ShBpywHAjcX3lF6198AGuA.png)
_Célébrant notre 100ème PR !_

Au cours des semaines suivantes, nous avons été occupés à mettre les dernières touches à notre application. Sans parler de la résolution de quelques bugs majeurs. Par exemple, ce fut un choc de découvrir que si quelqu'un se laissait distraire pendant la connexion et ne tentait jamais de "vérifier" son compte, toute l'application plantait !

En guise de touche finale, nous avons décidé de nous éloigner du thème Semantic-UI par défaut, qui ne semblait pas assez élégant. De plus, nous voulions que les Campeurs se sentent immédiatement chez eux, même dès leur première visite. Nous avons pensé que la meilleure façon d'y parvenir serait de recréer le thème freeCodeCamp aussi fidèlement que possible, sans avoir à revenir en arrière et à compromettre les choix stylistiques que nous avions déjà faits.

Ainsi, au lieu d'importer Semantic via CDN, nous avons utilisé leurs outils de construction Gulp et leurs capacités de thématisation personnalisée et intégré le package directement dans notre projet. Les résultats étaient fantastiques. Le site est passé d'un bleu-vert kitsch et peu professionnel à un vert freeCodeCamp vif et distingué.

![Image](https://cdn-media-1.freecodecamp.org/images/1*aQwdPH3WZs-zXqirhJDsPw.png)
_Avant la thématisation personnalisée (ci-dessus), et après (ci-dessous). Quelle différence !_

![Image](https://cdn-media-1.freecodecamp.org/images/1*XDKP_SkG__Ocqch9HhnKjg.png)

Après 60 jours de développement et environ 20 à 30 heures par semaine, nous avions presque tout terminé. Nous avons mené une courte série de tests bêta avec des utilisateurs en direct, et maintenant, alors que j'écris cet article, nous sommes enfin prêts pour notre lancement officiel !

Cela s'est avéré être l'expérience quintessentielle que je recherchais. Tout au long de ce processus, à mesure que les choses devenaient de plus en plus complexes, l'architecture et le fonctionnement interne d'une application web moderne sur une seule page sont devenus clairs pour moi. À mesure que la base de code grandissait, j'étais là à chaque étape, soit en contribuant du code, soit en examinant et en comprenant le code que je n'avais pas écrit.

Maintenant que nous avons terminé, je ne peux pas répéter assez de fois à quel point cette expérience a été enrichissante pour moi. Le point clé à retenir est le suivant : parfois, faire des petits pas ne suffit plus. Si vous vous sentez frustré par le rythme de votre progression, ou si vous avez l'impression d'avoir atteint un plateau, ne abandonnez pas.

Au lieu de cela, sortez et trouvez quelque chose qui est deux ou trois fois plus difficile que tout ce que vous avez jamais fait auparavant.

Cela **sera** difficile, et cela peut sembler impossible à certains moments. Mais la récompense de finalement relever le défi, et la valeur des connaissances que vous acquerrez en cours de route sont inestimables !

Que 1 ou 100 personnes rejoignent le Réseau des Anciens de freeCodeCamp, tout cela en aura valu la peine. Si vous pouvez vous identifier à l'état d'esprit que j'avais avant de commencer le développement de ce projet, je vous encouragerais à réfléchir à ce qui représente votre prochain plus grand défi, à l'attaquer et à vous l'approprier ! J'espère que vous vous amuserez autant que moi.