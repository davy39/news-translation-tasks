---
title: Choses que j'aurais aimé qu'on me dise quand j'apprenais à coder
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2013-11-22T18:42:54.000Z'
originalURL: https://freecodecamp.org/news/things-i-wish-someone-had-told-me-when-i-was-learning-how-to-code-565fc9dcb329
coverImage: https://cdn-media-2.freecodecamp.org/w1280/5f9cb9ef740569d1a4caf515.jpg
tags:
- name: education
  slug: education
- name: learning
  slug: learning
- name: General Programming
  slug: programming
- name: 'self-improvement '
  slug: self-improvement
- name: 'tech '
  slug: tech
seo_title: Choses que j'aurais aimé qu'on me dise quand j'apprenais à coder
seo_desc: 'By Cecily Carver

  And what I’ve learned from teaching others

  Before you learn to code, think about what you want to code

  Knowing how to code is mostly about building things, and the path is a lot clearer
  when you have a sense of the end goal. If your ...'
---

Par Cecily Carver

#### Et ce que j'ai appris en enseignant aux autres

### **Avant d'apprendre à coder, réfléchissez à _ce que_ vous voulez coder**

Savoir coder, c'est surtout construire des choses, et le chemin est beaucoup plus clair quand vous avez une idée de l'objectif final. Si votre objectif est "apprendre à coder", sans une idée claire des types de programmes que vous allez écrire et de la manière dont ils vont améliorer votre vie, vous trouverez probablement cela frustrant.

J'ai un peu honte d'admettre que une partie de ma motivation pour étudier l'informatique était que je voulais prouver que j'étais intelligente, et que je voulais pouvoir obtenir des emplois de "Personne Intelligente". J'aimais aussi réfléchir sur les maths et la théorie ([ce livre](http://www.amazon.ca/Godel-Escher-Bach-Eternal-Golden/dp/0465026567) m'a marqué à un âge impressionnable) et le programme était un bon choix. Mais ce n'était pas suffisant pour me motiver longtemps, jusqu'à ce que je trouve des moyens de connecter la technologie aux choses que j'aimais vraiment, comme la musique et la littérature.

Alors, que voulez-vous coder ? Des sites web ? Des jeux ? Des applications pour iPhone ? Une startup qui vous rendra riche ? De l'art interactif ? Voulez-vous impressionner votre patron ou automatiser une tâche fastidieuse pour pouvoir passer plus de temps à regarder des images de loutres ? Peut-être voulez-vous simplement être plus employable, ajouter un mot à la mode à votre CV, ou répondre aux exigences de votre programme éducatif. Tous ces objectifs sont louables. Assurez-vous de savoir lequel est le vôtre, et étudiez en conséquence.

### **Il n'y a rien de mystique là-dedans**

Coder est une compétence comme une autre. Comme l'apprentissage des langues, il y a une grammaire et un vocabulaire à acquérir. Comme les maths, il y a des processus à suivre pour résoudre des types spécifiques de problèmes. Comme tous les types d'artisanat et de création artistique, il y a des techniques, des outils et des bonnes pratiques que les gens ont développés au fil du temps, spécialisés pour différentes tâches, que vous êtes libre d'utiliser, de modifier ou de rejeter.

[Ce type](http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html) (un type très intelligent ! Dont les autres écrits je apprécie et avec lesquels je suis souvent d'accord !) soutient qu'il y a une ligne de démarcation nette entre les personnes ayant le Vrai Esprit d'un Programmeur et les autres, qui manquent de la capacité intellectuelle nécessaire pour réussir dans le domaine. Cette ligne de démarcation consiste, selon lui, en les pointeurs et la récursivité (il y a des primers [ici](http://alumni.cs.ucr.edu/~pdiloren/C++_Pointers/) et [ici](http://inventwithpython.com/blog/2011/08/11/recursion-explained-with-the-flood-fill-algorithm-and-zombies-and-cats/) pour les curieux).

J'ai appris les pointeurs et la récursivité à l'école, et quand je les ai compris, cela a été un choc délicieux pour mon cerveau — le genre de plaisir intellectuel qui m'a donné envie d'étudier l'informatique en premier lieu. Mais, en dehors des exercices de classe, le nombre de fois où j'ai dû être familière avec l'un ou l'autre concept pour faire des choses a été relativement faible. Et en aidant les autres à apprendre, encore et encore, j'ai vu des gens compléter des projets intéressants et gratifiants sans rien savoir sur l'un ou l'autre.

Il n'y a pas de raison d'être intimidé ou de se demander si vous êtes Assez Intelligent. Bien sûr, plus votre tâche est complexe et ésotérique, plus le niveau de maîtrise dont vous aurez besoin pour la compléter sera élevé. Mais cela est vrai dans absolument tous les autres domaines. À moins que vous ne prévoyiez de gagner votre vie entièrement par votre code, il est probable que vous n'ayez pas besoin d'être un génie compréhensif de la récursivité pour faire la chose que vous voulez faire.

### **Ça ne fonctionne jamais du premier coup**

#### **Et probablement pas du deuxième ou du troisième coup non plus**

Quand vous commencez à apprendre à coder, vous allez très rapidement vous heurter à cette expérience particulière : vous pensez avoir tout configuré comme vous êtes censé le faire, vous l'avez vérifié et revérifié, et ça ne. marche. toujours. pas. Vous n'avez aucune idée par où commencer à essayer de le réparer, et le message d'erreur (si vous avez la chance d'en avoir un) pourrait aussi bien dire "putain de merde". Vous pourriez être tenté d'abandonner à ce stade, pensant que vous ne comprendrez jamais, que vous n'êtes pas fait pour ça. J'ai eu ce sentiment la première fois que j'ai essayé d'écrire un programme en C++, que je l'ai exécuté, et que j'ai obtenu seulement les mots "segmentation fault" pour ma peine.

Mais cette expérience est si commune pour les programmeurs de tous niveaux de compétence qu'elle ne dit absolument rien sur votre intelligence, votre savoir-faire technologique ou votre aptitude pour la vie de codeur. Cela vous arrivera en tant que débutant, mais cela vous arrivera aussi en tant que programmeur expérimenté. La principale différence sera dans la manière dont vous y répondrez.

J'ai trouvé qu'une grande différence entre les nouveaux codeurs et les codeurs expérimentés est la foi : la foi que les choses vont mal pour une raison logique et décelable, la foi que les problèmes sont réparables, la foi qu'il y a un moyen d'atteindre l'objectif. Le chemin de "ne pas fonctionner" à "fonctionner" peut ne pas être évident, mais avec de la patience, vous pouvez généralement le trouver.

### **Quelqu'un vous dira toujours que vous faites ça de travers**

[Les accolades doivent aller à la ligne suivante](http://theprofoundprogrammer.com/page/17). [Les accolades doivent aller sur la même ligne](http://programmers.stackexchange.com/a/2782). [Utilisez des tabulations pour l'indentation](http://derkarl.org/why_to_tabs.html). [Mais les tabulations sont le mal](http://www.emacswiki.org/emacs/TabsAreEvil). Vous devriez [utiliser des procédures stockées](http://mysqlstoredprocedure.com/index.php?option=com_content&view=article&id=51&Itemid=40), mais en fait [vous ne devriez pas les utiliser](http://www.tonymarston.co.uk/php-mysql/stored-procedures-are-evil.html). Vous devriez [toujours commenter votre code](http://www.lanoie.net/classes/DHTML/programming/lectures/lecture.html). Mais [un bon code n'a pas besoin de commentaires](http://visualstudiomagazine.com/articles/2013/06/01/roc-rocks.aspx).

Il y a presque toujours de nombreuses approches différentes à un problème particulier, sans qu'il y ait une seule "bonne" façon. Beaucoup de programmeurs deviennent très bons pour défendre leur façon préférée, mais cela ne signifie pas que c'est le Chemin Unique et Vrai. Affronter des gens qui me disaient que j'avais Tort, et essayer de déterminer s'ils avaient raison, était l'un des aspects les plus stressants de mes débuts de carrière.

Si vous codez en équipe avec d'autres personnes, quelqu'un prendra presque certainement en grippe quelque chose que vous faites. Parfois, ils auront absolument raison, et il est toujours utile d'examiner si vous faites vraiment ça de travers. Mais parfois, ils seront pleins de conneries, ou réenactent une ancienne et sans importance dispute où il serait préférable de simplement suivre un guide de style et d'oublier le reste.

D'un autre côté, si vous êtes du genre à aimer les anciennes mais sans importance disputes (les amateurs de grammaire, je vous regarde), vous êtes au bon endroit.

### **Quelqu'un vous dira toujours que vous n'êtes pas un vrai codeur**

[HTML n'est pas un vrai codage](http://www.cs.tut.fi/~jkorpela/prog.html). [Si vous n'utilisez pas vi, vous n'êtes pas vraiment sérieux](http://the-shaolin.blogspot.ca/2007/12/why-vi-only-true-programmers-editor.html). [Les vrais programmeurs connaissent C](http://www.ericsink.com/entries/c_morse_code.html). [Les vrais codeurs n'utilisent pas Windows.](http://www.zazzle.ca/real_coders_dont_do_windows_tees-235789605999466863) [Certaines personnes ne pourront jamais l'apprendre](http://www.codinghorror.com/blog/2006/07/separating-programming-sheep-from-non-programming-goats.html). [Vous ne devriez pas apprendre à coder](http://www.codinghorror.com/blog/2012/05/please-dont-learn-to-code.html). [Vous n'êtes pas un programmeur informatique (mais moi si)](http://fullcomment.nationalpost.com/2013/08/21/chase-felker-youre-not-a-computer-programmer-and-thats-ok/).

"Coder" signifie beaucoup de choses différentes pour beaucoup de gens différents, et cela diffère de ce que c'était auparavant. Et, de manière amusante, les outils et les packages et les frameworks qui rendent les choses plus rapides et plus faciles pour les nouveaux venus ou même les développeurs formés à construire des choses sont les plus susceptibles d'être qualifiés de "pas pour les VRAIS codeurs". (Voir : "[Return of the Real Programmer](http://blog.enfranchisedmind.com/2009/04/return-of-the-real-programmer/)")

Derrière tout cela se cache la peur que [si "n'importe qui" peut se prétendre programmeur, le titre deviendra sans valeur](http://fullcomment.nationalpost.com/2013/08/21/chase-felker-youre-not-a-computer-programmer-and-thats-ok/). Mais je pense que cette garde est destructrice.

Utilisez les outils qui rendent les choses les plus faciles à construire. Si cela signifie que votre jeu a été fait dans Stencyl ou GameMaker plutôt que écrit à partir de zéro, c'est très bien. Si votre première incursion dans le codage est HTML ou des macros Excel, c'est très bien. Travaillez avec quelque chose que vous sentez que vous pouvez continuer.

À mesure que vous vous sentez plus à l'aise, vous commencez naturellement à trouver ces outils limitants plutôt qu'utiles et à chercher des outils plus puissants. Mais la plupart du temps, peu de gens regarderont même votre code ou demanderont ce que vous avez utilisé — C'est ce que vous faites avec qui compte.

### **S'inquiéter du "geek cred" vous tuera lentement**

Voir ci-dessus. J'avais l'habitude de m'inquiéter beaucoup, surtout à l'école, de savoir si je m'identifiais comme "pas une vraie geek" (et donc moins digne d'être incluse dans les communautés technologiques) à travers mes vêtements, ma présentation, mon choix de matériel de lecture et même mes choix de personnalisation de logiciels. C'était une perte d'énergie terrible et je suis devenue beaucoup plus fonctionnelle après avoir pris la décision de tout laisser tomber.

Vous devez internaliser ceci : votre capacité à devenir bon en codage n'a _rien_ à voir avec la manière dont vous vous intégrez dans les diverses sous-cultures geek. Cela est encore plus vrai si vous savez au fond de vous que vous ne vous intégrerez jamais vraiment. L'énergie que vous dépensez à vous prouver devrait être utilisée pour faire des choses à la place. Et, si vous êtes un geek indéniable avec du "cred" qui vous sort par les yeux, gardez cela à l'esprit lorsque vous évaluez le niveau de "cred" de quelqu'un d'autre. Cela peut ne pas signifier ce que vous pensez.

### **Persévérer est plus important que la méthode**

Il n'y a pas de pénurie d'articles sur la "bonne" ou "meilleure" façon d'apprendre à coder, et il existe de nombreuses approches potentielles. Vous pouvez apprendre les concepts [à partir d'un livre](http://pine.fm/LearnToProgram/) ou en [complétant des exercices interactifs](http://www.codecademy.com/) ou en [déboguant des choses que d'autres ont écrites](http://learnpythonthehardway.org/book/intro.html). Et, bien sûr, il existe de nombreuses langues que vous pourriez choisir comme première à apprendre, avec des défenseurs pour chacune.

Une plainte courante concernant les programmes et ateliers "apprenez à coder" est que vous allez rapidement à travers le matériel pour débutants et que vous allez ensuite rencontrer une courbe abrupte où les choses deviennent plus difficiles très rapidement. Vous savez comment imprimer quelques lignes de texte sur une page mais vous ne savez pas par où commencer pour travailler sur un projet "réel" et utile. Vous pourriez avoir l'impression de simplement suivre des instructions sans vraiment comprendre, et blâmer les matériaux d'apprentissage.

Quand vous atteignez ce stade, la plupart des tutoriels et des ressources en ligne disponibles pour vous sont beaucoup moins utiles car ils supposent que vous êtes déjà un programmeur expérimenté et à l'aise. La difficulté est encore aggravée par le fait que "vous ne savez pas ce que vous ne savez pas". Même essayer de déterminer ce qu'il faut apprendre ensuite est un casse-tête en soi.

Vous allez rencontrer ce mur peu importe quel programme "apprendre à coder" vous suivez, et la seule façon de le surmonter est de persévérer. Cela signifie que vous continuez à essayer de nouvelles choses, à apprendre plus d'informations, et à déterminer, pièce par pièce, comment construire votre projet. Vous avez beaucoup plus de chances de réussir à la fin si vous avez une idée claire de pourquoi vous apprenez à coder en premier lieu.

Si vous continuez à empiler des briques les unes sur les autres, cela peut prendre beaucoup de temps, mais éventuellement vous aurez un mur. C'est là que la foi dont je parlais plus tôt devient utile. Si vous croyez qu'avec le temps et la patience vous pouvez comprendre toute la chose du codage, alors avec le temps vous le ferez presque certainement.