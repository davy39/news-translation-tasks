---
title: Comment mettre en place une boucle de r√©troaction courte en tant que d√©veloppeur
  solo
subtitle: ''
author: Victoria Drake
co_authors: []
series: null
date: '2018-07-13T21:30:46.000Z'
originalURL: https://freecodecamp.org/news/how-to-set-up-a-short-feedback-loop-as-a-solo-coder-67709cba21e0
coverImage: https://cdn-media-1.freecodecamp.org/images/1*pmBhfr3r0VgXfvG_9Uu1pQ.png
tags:
- name: goal-setting
  slug: goal-setting
- name: Life lessons
  slug: life-lessons
- name: General Programming
  slug: programming
- name: software development
  slug: software-development
- name: 'tech '
  slug: tech
seo_title: Comment mettre en place une boucle de r√©troaction courte en tant que d√©veloppeur
  solo
seo_desc: I‚Äôve spent the last couple years as a solo freelance developer. Comparing
  this experience to previously working in companies, I‚Äôve noticed that those of us
  who work alone can have fewer iterative opportunities for improvement than developers
  who work...
---

J'ai pass√© les derni√®res ann√©es en tant que d√©veloppeur freelance solo. En comparant cette exp√©rience √† mon travail pr√©c√©dent en entreprise, j'ai remarqu√© que ceux d'entre nous qui travaillent seuls peuvent avoir moins d'opportunit√©s it√©ratives d'am√©lioration que les d√©veloppeurs qui travaillent en √©quipe.

Pour avoir l'opportunit√© de s'am√©liorer, nous devons adopter le concept de boucle de r√©troaction courte. Il s'agit d'un processus d'incorporation continue de nouveaux apprentissages issus de l'observation et de l'exp√©rience pr√©c√©dente sur une courte p√©riode. Ce processus doit √™tre **cr√©√©** par les personnes travaillant principalement seules, au lieu d'√™tre **adopt√©**, comme c'est souvent le cas, lorsque l'on rejoint une √©quipe.

Dans cet article, j'esp√®re partager ce que j'ai appris sur la mise en place pour s'am√©liorer rapidement et continuellement en tant que d√©veloppeur solo.

### √Ä propos des boucles de r√©troaction

Le colonel John Boyd de l'US Air Force a d√©velopp√© le concept de la [boucle OODA](https://en.wikipedia.org/wiki/OODA_loop), OODA √©tant l'acronyme de **observer, s'orienter, d√©cider, agir**. Dans les op√©rations militaires, cela illustre un processus de prise de d√©cision bas√© sur l'ingestion constante de nouvelles informations :

**Observer** : Obtenir des informations brutes sur les circonstances en √©volution et l'environnement actuel.

**S'orienter** : Mettre les observations brutes en contexte. Tenir compte de la pertinence par rapport √† la situation actuelle et des connaissances et de l'expertise pr√©c√©demment acquises.

**D√©cider** : √âlaborer un plan pour atteindre son objectif.

**Agir** : Ex√©cuter le plan.

Puisqu'il s'agit d'une boucle, l'√©tape **agir** m√®ne directement √† l'√©tape **observer**. C'est le concept critique de "r√©troaction" qui permet des it√©rations de plus en plus r√©ussies. Il est largement applicable au-del√† des op√©rations militaires ‚Äî vous pouvez le reconna√Ætre comme l'origine de la m√©thode [PDCA](https://en.wikipedia.org/wiki/PDCA) (plan-do-check-act).

J'aime la boucle OODA, car c'est une illustration succincte d'une boucle de r√©troaction g√©n√©rale. De nombreux concepts et m√©thodes de travail s'appuient sur l'id√©e de boucles de r√©troaction, y compris les m√©thodes [DevOps](https://en.wikipedia.org/wiki/DevOps) et de [d√©veloppement agile](https://en.wikipedia.org/wiki/Agile_software_development).

### Boucle de r√©troaction de l'√©quipe de d√©veloppement

Examinons √† quoi pourraient ressembler certains composants d'une boucle de r√©troaction pour un d√©veloppeur au sein d'une √©quipe :

1. Directives des propri√©taires de produits ou retours des utilisateurs
2. Daily scrum/standup avec toute l'√©quipe
3. Priorisation avec l'√©quipe de d√©veloppeurs
4. Codage et tests individuels
5. Revue de code par les pairs
6. D√©ploiement et surveillance des performances

Implicitement, ces √©tapes supposent le soutien des coll√®gues et de la direction ‚Äî en d'autres termes, quelqu'un √† qui rendre des comptes. Comment un d√©veloppeur freelance solo peut-il cr√©er un environnement similaire de responsabilit√© ?

### Boucle de r√©troaction du d√©veloppeur solo

Voici quelques √©tapes possibles qu'un d√©veloppeur freelance individuel peut mettre en ≈ìuvre pour cr√©er une boucle de r√©troaction courte :

1. Construire la discipline
2. Clarifier les objectifs concrets de haut niveau
3. Prioriser et planifier les objectifs de niveau interm√©diaire et bas
4. Automatiser votre travail
5. Bloquer du temps pour la revue de code
6. Bloquer du temps pour la revue de processus
7. Mettre √† jour vos objectifs et processus avec les r√©sultats de vos revues

Je vais d√©tailler chacune de ces √©tapes ci-dessous.

#### Construire la discipline

Plus un pr√©requis qu'une √©tape en soi, construire la discipline est ce qui permet √† notre boucle de r√©troaction courte de fonctionner. Rien d'autre dans cet article ne sera utile si nous n'avons pas la capacit√© de faire quelque chose que nous ne voulons pas faire. La discipline est certainement une comp√©tence. Elle peut √™tre apprise, entra√Æn√©e et am√©lior√©e comme toute autre.

Pourquoi la discipline est-elle si importante ? Parce que lorsque nous sommes en train de finaliser un projet ce vendredi soir, nous n'aurons pas envie d'√©crire un bon message de commit. Nous n'aurons pas envie de nettoyer les commentaires du code. Nous voulons juste voir le projet partir, _Bonjour, git push -f_.

C'est dans ces moments que la discipline nous permet de ne pas manquer une opportunit√© de pratiquer, d'apprendre et d'am√©liorer notre processus de travail. La discipline nous aide √† √©viter les commits de vendredi soir qui se transforment en `git reset --hard` de lundi matin.

#### Clarifier les objectifs concrets de haut niveau

![Image](https://cdn-media-1.freecodecamp.org/images/FSBRpf7OG7Jq2t0heAlZu4PLkFgpWIk3sW6p)

Que nous travaillions pour un client ou que nous d√©veloppions notre propre meilleure application, nous ne pourrons pas mesurer nos progr√®s ou nos am√©liorations sans quelque chose √† quoi les mesurer.

Lorsque je discute d'un nouveau projet avec un client, je parle toujours en termes de r√©alisations concr√®tes. Cela peut prendre la forme de la r√©alisation d'une fonctionnalit√© sp√©cifique √† une certaine date, ou de la d√©cision de ce √† quoi ressemble le MVP pour un utilisateur. Cela est autant pour mon b√©n√©fice que pour celui de mon client. En convenant, par √©crit, **ce qui** sera r√©alis√© et **quand**, mon client et moi avons clairement d√©fini des objectifs de haut niveau et pouvons tous deux √©valuer comment le projet progresse.

Lorsque je travaille pour moi-m√™me, je me traite comme je traiterais un client. Je prends un engagement, par √©crit, d√©crivant ce qui sera r√©alis√©, et quand. Cela peut √™tre quelque chose d'aussi simple qu'une liste d'objectifs pour la semaine, ou aussi d√©taill√© qu'un tableau kanban.

Le but d'avoir un objectif concret, cependant, n'est pas de s'y tenir √† tout prix. Il est important de fixer une attente, avec nous-m√™mes et avec nos clients, que les objectifs seront r√©examin√©s √† des dates mutuellement convenues au cours du projet. Cela permet la partie si importante de "r√©troaction" de la boucle.

#### Prioriser et planifier les objectifs de niveau interm√©diaire et bas

![Image](https://cdn-media-1.freecodecamp.org/images/ne08OzeVcFueWzqHi5iS5spqEzuVgL6Vzhhc)

Peu d'objectifs sont atteints en une seule √©tape. M√™me le simple processus de pr√©paration d'un sandwich au beurre de cacahu√®te et √† la gel√©e (un exemple d'enseignement favori en [programmation informatique](https://www.youtube.com/watch?v=y62zj9ozPOM&t=1016s)) peut √™tre d√©compos√© en instructions successivement plus petites et plus pr√©cises. Bien que nous, humains, n'ayons peut-√™tre pas besoin de la granularit√© qu'un programme informatique exige, les objectifs qui sont divis√©s en √©tapes r√©alisables et limit√©es dans le temps sont beaucoup plus faciles √† assimiler. üí°

Commencez par les objectifs de niveau interm√©diaire, et rendez chaque √©tape concr√®te. Si l'objectif est de lancer une nouvelle application web open source, par exemple, les √©tapes pourraient ressembler √† ceci :

1. Compl√©ter le JavaScript de l'application
2. Cr√©er le front end et la feuille de style
3. Effectuer des tests locaux
4. Configurer le serveur cloud
5. D√©ployer l'application sur le cloud
6. Effectuer des tests
7. Ajouter le d√©p√¥t √† GitHub
8. Publier sur Hacker News
9. Profit !!!

Chacun des exemples ci-dessus encapsule de nombreux objectifs plus petits, de bas niveau ‚Äî nous pouvons penser √† ceux-ci comme √† nos √©l√©ments de liste de t√¢ches. Par exemple, "Configurer le serveur cloud" pourrait impliquer :

1. Rechercher les fournisseurs de cloud
2. D√©cider du service et s'inscrire
3. Configurer le serveur/instance
4. Ajouter des int√©grations
5. Tester le d√©ploiement

Nos param√®tres pour les tailles de morceaux et ce qui constitue une "√©tape" peuvent √™tre diff√©rents les uns des autres, et changeront probablement de projet en projet. Si vos √©tapes de niveau interm√©diaire et bas d√©finissent clairement un chemin concret pour atteindre les objectifs de haut niveau que vous avez fix√©s, alors vous √™tes en bonne voie. Plus tard, en √©valuant le processus de d√©cision qui nous a conduits √† ces objectifs de niveau interm√©diaire et bas, nous pouvons boucler notre boucle de r√©troaction.

#### Automatiser votre travail

![Image](https://cdn-media-1.freecodecamp.org/images/YQiux-ArUTRIoqGGcNSAY7W1cyjyG1SiHTJG)

J'ai r√©cemment lu un excellent article intitul√© [Le travail manuel est un bug](https://queue.acm.org/detail.cfm?id=3197520). Il discute d'un processus par lequel les d√©veloppeurs r√©ussis documentent et finissent par automatiser leur travail. La beaut√© de cette id√©e r√©side dans sa simplicit√©. En √©crivant les choses que nous faisons manuellement, nous sommes en mesure de corriger et d'affiner nos processus. En affinant nos processus, nous pouvons plus facilement les traduire en extraits de code et en scripts. Avec une collection de scripts que nous pouvons encha√Æner, nous pouvons automatiser notre travail.

Automatiser le travail ne consiste pas seulement √† gagner du temps. Cela r√©duit les erreurs de type "je n'ai pas encore bu mon caf√©", minimise la charge cognitive en laissant plus de place √† la cr√©ativit√©, et permet √† nos processus d'√™tre reproductibles entre collaborateurs et projets. Cela aide √† raccourcir notre boucle de r√©troaction en garantissant que nous ne faisons pas la m√™me chose trois fois de trois mani√®res diff√©rentes.

Nous pouvons commencer √† automatiser en cr√©ant notre propre wiki personnel. Si nous prenons l'habitude d'√©crire chaque chose manuelle que nous faisons, peu importe √† quel point elle peut sembler basique √† ce moment-l√†, nous nous donnons plus d'opportunit√©s de rep√©rer des motifs, et ainsi des int√©grations et am√©liorations possibles.

La premi√®re fois que nous faisons quelque chose manuellement, nous √©crivons les √©tapes. La deuxi√®me fois, nous suivons les √©tapes. Cela nous donne l'opportunit√© de les corriger et de les affiner en fonction de ce que nous avons appris depuis la premi√®re fois.

Au fil des it√©rations successives, nous pourrions remplacer des parties de commandes manuelles par des variables. Nous pourrions trouver des extraits pratiques de scripts bash qui automatisent juste une partie de notre t√¢che. Tant que nous continuons √† r√©viser et √† am√©liorer notre wiki personnel, nous progressons vers l'automatisation.

#### Bloquer du temps pour la revue de code

![Image](https://cdn-media-1.freecodecamp.org/images/j0xWdQE2By2JGa9VFfRjL88NWz7ERedqY21F)

Il est trop facile de commiter du code d√©sordonn√© lorsque nous travaillons seuls. Nous pensons, _qui va le voir ? Je le corrigerai plus tard._ Chaque fois que cela se produit, cependant, nous construisons une habitude. C'est une mauvaise habitude.

Travailler seul signifie qu'il n'y a personne pour donner des retours sur nos commits lorsque nous faisons quelque chose qui n'a pas de sens, ou qui pourrait √™tre am√©lior√©. Au lieu de cela, nous devons activement chercher des opportunit√©s de nous am√©liorer. Les communaut√©s open source sont incroyables pour cela. Il y a une richesse d'informations disponibles pour nous en termes de styles de codage, d'exemples de code refactoris√©, et un smorgasbord d'extraits qui r√©alisent cette-chose-que-nous-essayions-de-faire mais en moins de lignes. Nous pouvons apprendre tout ce que nous voulons, si nous bloquons simplement le temps pour le faire.

Planifiez votre propre revue de code √† un moment qui a du sens pour vous et le projet sur lequel vous travaillez. Cela pourrait √™tre chaque fois que vous terminez une correction ou une fonctionnalit√©, ou √† des intervalles r√©guliers quotidiens ou hebdomadaires. Si vous avez quelqu'un qui peut vous aider, r√©servez-le. Il y a aussi [des salons de discussion remplis de personnes](https://victoria.dev/verbose/top-free-resources-for-developing-coding-superpowers/) heureuses de pr√™ter main forte.

Faites quelques recherches sur les meilleures pratiques de base pour ce sur quoi vous travaillez. Fixez-vous une limite de temps, cependant, et prenez ce que vous lisez avec un grain de sel. Il y a beaucoup de terriers de lapin dans ce domaine. En tant que point de d√©part, je recommanderais d'apprendre sur le code DRY, et de regarder [Uncle Bob exiger du professionnalisme dans le d√©veloppement logiciel](https://www.youtube.com/watch?v=p0O1VVqRSK0&feature=youtu.be&t=330).

#### Liste de contr√¥le pour la revue de code

Voici ma liste de contr√¥le personnelle pour la revue de code, bas√©e sur quelques bonnes pratiques g√©n√©rales. N'h√©sitez pas √† l'utiliser comme point de d√©part pour la v√¥tre !

> **_L'Extravaganza de la Revue de Code de Victoria !_**

>  _- [ ] Cela r√©sout un √©l√©ment de haute priorit√©._  
>  _- [ ] Il s'agit d'une impl√©mentation compl√®te qui suit la sp√©cification._  
>  _- [ ] Les modifications hors sujet n'ont pas √©t√© incluses et ont √©t√© ajout√©es au backlog._  
>  _- [ ] Les noms de variables sont significatifs et il n'y a pas de nombres magiques._  
>  _- [ ] Des messages d'erreur corrects et utiles sont retourn√©s √† chaque opportunit√©._  
>  _- [ ] Aucune instruction d'impression de d√©bogage n'a √©t√© laiss√©e._  
>  _- [ ] Ce code est DRY et modulaire._  
>  _- [ ] Ce code est s√©curis√©. Le code priv√© et public sont bien s√©par√©s._  
>  _- [ ] Ce code est sa propre documentation, ou la documentation est √† jour._  
>  _- [ ] Un enfant de cinq ans pourrait suivre cela, s√©rieusement c'est si lisible._  
>  _- [ ] Les tests unitaires passent avec succ√®s._  
>  _- [ ] Master a √©t√© fusionn√© dans la branche et test√©._  
>  _- [ ] La mise en forme suit les directives de style._  
>  _- [ ] Je ne peux pas trouver d'autres cas limites ou d√©fauts connus._  
>  _- [ ] Je serais heureux si ce code m'√©tait publiquement attribu√©._  
>  _- [ ] Je comprends pleinement ce que le code fait et l'impact des modifications que j'ai apport√©es._  
> -  _[ ] J'ai r√©ellement v√©rifi√© qu'il fait r√©ellement ce que j'ai dit qu'il faisait._

[Voici un excellent exemple](https://dev.to/gonedark/writing-clean-code) de nettoyage de code en gardant √† l'esprit certains des points ci-dessus.

#### Bloquer du temps pour la revue de processus

![Image](https://cdn-media-1.freecodecamp.org/images/Nvgdg9nCzq5Rrtlq29-FF564MtsGginnwJnU)

Tout comme nous apprenons en r√©visant notre code, nous affinons nos processus en les r√©visant √©galement. La revue de processus est la plus b√©n√©fique lorsqu'elle est effectu√©e √† intervalles r√©guliers tout au long du projet, et pas seulement apr√®s l'ach√®vement du projet.

Pour les projets √† court terme, un bon point de d√©part pour la planification des revues de processus est √† chaque mi-parcours ‚Äî une fois √† mi-chemin, et √† nouveau apr√®s l'ach√®vement. Les projets √† long terme peuvent avoir des revues √† chaque quart de parcours.

#### Questions pour la revue de processus

La revue de processus peut √™tre aussi simple qu'une courte liste de questions :

1. Quels √©taient mes objectifs de haut niveau pour cette p√©riode ? Les ai-je atteints ?
2. Quels √©taient mes objectifs de niveau interm√©diaire et bas pour cette p√©riode ? Les ai-je atteints ?
3. Aurais-je √©t√© mieux servi avec des objectifs diff√©rents ou plus sp√©cifiques ? Pourquoi ?
4. Ai-je r√©ussi √† supprimer ou √† automatiser les obstacles ?
5. Ai-je respect√© mon calendrier de revue de code ? Pourquoi ou pourquoi pas ?
6. Comment pourrais-je supprimer les obstacles la prochaine fois ?

Mettre de c√¥t√© du temps d√©di√© pour notre revue de processus peut nous aider √† r√©pondre √† des questions comme celles-ci de mani√®re r√©fl√©chie et honn√™te. Cela nous permet de tirer le meilleur parti de notre revue, aidant √† raccourcir notre boucle de r√©troaction.

#### Mettre √† jour vos objectifs et processus avec les r√©sultats de vos revues

![Image](https://cdn-media-1.freecodecamp.org/images/RCd2DfPOTP3j7UoMT1M9-UCuLeNO7SQRkKDo)

Toutes les donn√©es de performance du monde ne nous sont d'aucune utilit√© si nous ne les mettons pas en pratique. Avec chaque revue de code successive, nous pouvons affiner et ajouter √† notre liste de contr√¥le. Avec ce que nous apprenons de chaque revue de processus, nous pouvons affiner et am√©liorer nos processus. Plus nous pouvons inventer des moyens concrets et observables de mettre en ≈ìuvre notre apprentissage, plus nous aurons de succ√®s.

Faire un effort conscient pour utiliser et pratiquer les choses que nous avons apprises est le dernier composant vital de notre boucle de r√©troaction. Plus nous incorporons souvent de nouveaux apprentissages, plus notre boucle devient courte, nous permettant de nous am√©liorer encore plus rapidement.