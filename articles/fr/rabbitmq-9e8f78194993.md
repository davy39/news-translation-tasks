---
title: Une introduction à RabbitMQ, un courtier qui gère les messages
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2019-04-05T20:42:10.000Z'
originalURL: https://freecodecamp.org/news/rabbitmq-9e8f78194993
coverImage: https://cdn-media-1.freecodecamp.org/images/1*HCpBJmTd_sELllvhVOaevg.jpeg
tags:
- name: message broker
  slug: message-broker
- name: General Programming
  slug: programming
- name: queue
  slug: queue
- name: rabbitmq
  slug: rabbitmq
- name: technology
  slug: technology
seo_title: Une introduction à RabbitMQ, un courtier qui gère les messages
seo_desc: 'By Chandrabhan Singh

  An introduction to RabbitMQ, message broker, AMQP model and more.

  In distributed systems, communication between various applications plays an important
  role. Effectively passing messages between applications was always a crucial ...'
---

Par Chandrabhan Singh

#### Une introduction à RabbitMQ, courtier de messages, modèle AMQP et plus.

Dans les systèmes distribués, la communication entre diverses applications joue un rôle important. Transmettre efficacement des messages entre les applications a toujours été une décision cruciale dans la conception des systèmes. L'une des solutions élégantes pour transmettre des messages dans votre système distribué est un courtier de messages.

Dans les systèmes distribués, la communication entre diverses applications joue un rôle important. Transmettre efficacement des messages entre les applications a toujours été une décision cruciale dans la conception des systèmes. L'une des solutions élégantes pour transmettre des messages dans votre système distribué est un courtier de messages.

Ils apportent un découplage entre les applications et fournissent un moyen efficace de communiquer. Avec les courtiers de messages, une application n'a pas besoin de connaître à l'avance ses destinataires pour communiquer.

Cependant, qu'est-ce que RabbitMQ ? Comment RabbitMQ s'intègre-t-il dans ce tableau ? De plus, qu'est-ce que AMQP ?

À la fin de cet article, nous serons en mesure de répondre à ces questions. J'ai également ajouté quelques animations afin que vous puissiez visualiser les concepts de RabbitMQ.

Alors, êtes-vous excité ? Moi oui ! Si vous avez déjà eu des difficultés à comprendre les courtiers de messages, comme moi, alors cet article est le bon endroit pour commencer votre voyage. Restez avec moi ?

# Courtier de messages

En général, un courtier est une personne qui facilite les transactions entre un acheteur et un vendeur. Un exemple pourrait être un agent immobilier ou un courtier en bourse.

De même, si nous voulons échanger des messages entre deux composants logiciels distribués, nous avons besoin d'un médiateur. Ce médiateur est connu sous le nom de courtier de messages. Il reçoit les messages entrants d'un expéditeur et les envoie à un destinataire. De cette façon, l'expéditeur et le destinataire peuvent être totalement isolés.

Une autre analogie pour un courtier de messages peut être un bureau de poste (voir Figure 1). Prenons un scénario où vous allez envoyer une lettre à votre cousin vivant dans une autre ville. Alors selon cette analogie, vous êtes un producteur, votre cousin est un consommateur, et le bureau de poste est un courtier de messages.

![Image](https://cdn-media-1.freecodecamp.org/images/1*nUaJxRXwLbgZyM4KWwDfig.png?q=20)
_Figure 1 : Analogie pour un courtier de messages_

# RabbitMQ en tant que courtier de messages

Maintenant, nous savons que le but d'un courtier de messages est d'acheminer les messages d'un producteur à un consommateur. Examinons un tel courtier de messages — RabbitMQ. C'est l'un des courtiers de messages les plus utilisés ces jours-ci.

La manière dont RabbitMQ achemine les messages dépend du protocole de messagerie qu'il implémente. RabbitMQ prend en charge plusieurs protocoles de messagerie. Cependant, celui qui nous intéresse est AMQP. C'est un acronyme pour Advanced Message Queuing Protocol.

Alors sans plus tarder, examinons de plus près le modèle de protocole AMQP.

# Advanced Message Queuing Protocol

Le modèle conceptuel de AMQP est assez simple et direct. Il a trois entités :

1. File d'attente
2. Liaison
3. Échange

Lorsque qu'un éditeur pousse un message vers RabbitMQ, il arrive d'abord à un échange. L'échange distribue ensuite des copies de ces messages à diverses files d'attente connectées. Enfin, les consommateurs reçoivent ces messages.

Considérez un message comme un morceau de données. Il s'agit nécessairement d'un paquet avec une charge utile et quelques méta-données. La charge utile contient les données complètes tandis que les méta-données sont des propriétés utilisées par RabbitMQ.

La Figure 2 représente une représentation graphique du modèle AMQP.

![Image](https://cdn-media-1.freecodecamp.org/images/1*F1NaCmmz72StUZZHfRfpvw.png?q=20)
_Figure 2 : Modèle AMQP_

AMQP est un protocole programmable. Les programmeurs ont la liberté d'utiliser des bibliothèques pour configurer les entités (échange, liaison et file d'attente) selon leurs propres besoins. Un administrateur RabbitMQ n'a aucun rôle dans la configuration de ces entités.

Il existe de nombreuses bibliothèques disponibles pour travailler avec RabbitMQ. Vous pouvez choisir parmi [Nodejs](http://www.squaremobius.net/amqp.node/), [Python](https://pypi.org/project/pika/), .[Net](https://github.com/rabbitmq/rabbitmq-dotnet-client), [Java](https://github.com/rabbitmq/rabbitmq-java-client/), et bien d'autres.

# Files d'attente

Ces files d'attente sont quelque peu similaires aux files d'attente de nos cours de structures de données. Les files d'attente RabbitMQ suivent également la méthodologie FIFO — First-In-First-Out. Une file d'attente est un endroit où RabbitMQ stocke les messages/données.

Les programmeurs peuvent configurer les files d'attente via les bibliothèques de programmation disponibles. Vous pouvez rendre une file d'attente durable (avec la propriété `Durability`) pour protéger vos données en cas de panne du courtier. Vous pouvez également fournir un nom (avec la propriété `Name`) à une file d'attente. En plus de `Name` et `Durability`, une file d'attente a quelques autres propriétés comme auto-delete, exclusive et arguments.

Avant d'aller plus loin, il est important de comprendre qui est un consommateur direct de ces files d'attente. De plus, combien de façons un utilisateur peut-il consommer des messages à partir d'une file d'attente ?

# Consommateurs

Les consommateurs sont ceux qui vont utiliser les messages stockés dans une file d'attente. Il est possible de connecter plus d'un consommateur à une file d'attente à la fois. Les consommateurs peuvent soit tirer le message de la file d'attente en le regroupant, soit les files d'attente peuvent même pousser le message vers divers consommateurs connectés.

# Liaisons

Les liaisons sont les règles qu'une file d'attente définit lors de l'établissement d'une connexion avec un échange. Vous pouvez avoir une file d'attente connectée à plusieurs échanges. Chaque file d'attente est également connectée à un échange par défaut. Un échange utilisera ces liaisons pour acheminer les messages vers les files d'attente.

# Échanges et leurs types

Un échange est une passerelle vers RabbitMQ pour vos messages. La distance que le message doit parcourir à l'intérieur de RabbitMQ dépend du type d'échange. Il existe principalement quatre types.

* Direct
* Fanout
* Topic
* Header

## Direct

Le nom explique tout ! — Un échange direct livre un message directement aux files d'attente qui satisfont la condition ci-dessous :

```
Clé de routage == Clé de liaison 

```

Une clé de routage est un attribut du message. D'autre part, une clé de liaison est quelque chose que vous spécifiez lors de la création d'une liaison entre une file d'attente et un échange.

La Figure 3 est une explication visuelle de la façon dont les messages circulent lors de l'utilisation d'un échange direct.

Un message provient d'un producteur (cercle vert) avec une clé de routage — `img.resize`. Une fois qu'il atteint l'échange (cercle orange), l'échange essaiera de trouver toutes les files d'attente avec la clé de liaison — `img.resize`. En cas de correspondance, le message est poussé vers toutes les files d'attente correspondantes (redimensionner dans notre cas). Si aucune correspondance n'est trouvée, le message peut être renvoyé au producteur ou même être rejeté. Nous avons de la chance d'avoir trouvé une correspondance dans notre exemple ?

[gif image]

Une fois que le message atteint la file d'attente souhaitée (redimensionner dans notre cas), ils sont distribués à la ronde à tous les consommateurs connectés (redimensionneur.1/redimensionneur.2 dans notre cas).

En distribuant les messages à la ronde, RabbitMQ s'assure que les messages sont équilibrés en charge.

Vous devez avoir remarqué que la file d'attente nommée **crop** ne reçoit aucun message. Parce que la clé de routage dans cet exemple est `img.resize`. Pour envoyer des messages à cette file d'attente, nous devons envoyer des messages avec une clé de routage qui correspondrait à la clé de liaison (par exemple `img.crop`).

## Fanout

Un échange Fanout ignore les clés de routage et distribue un message à toutes les files d'attente connectées. Pas étonnant qu'il soit appelé Fanout (soufflant des messages à toutes les files d'attente connectées ! ?).

L'un des cas d'utilisation de ce type d'échange est la diffusion de messages.

![Image](https://www.freecodecamp.org/news/content/images/2019/07/1_f4bddksBjxqZjYq3VDa3wg.gif)

Veuillez noter que RabbitMQ fera toujours un tour de rôle s'il y a plus d'un consommateur de la file d'attente.

## Topic

Un échange de topic achemine un message en faisant correspondre la clé de routage avec un motif dans la clé de liaison.

```
Clé de routage == Motif dans la clé de liaison.
```

RabbitMQ utilise deux caractères génériques pour la correspondance de motifs `*` et `#`. Utilisez un `*` pour correspondre à 1 mot et un `#` pour correspondre à 0 ou plusieurs mots.

La Figure 5 est une représentation visuelle d'un échange de topic. Les messages avec la clé de routage — `logs.error` correspondront aux motifs — `logs.error` et `logs.*`. Par conséquent, ces messages finiront dans les files d'attente — `only error` et `all logs`.

Alors que pour le producteur en bas à gauche, les messages avec la clé de routage — `logs.success` correspondront aux motifs de la clé de liaison `#success` et `logs.*`. Par conséquent, ces messages finiront dans les files d'attente — `all logs` et `only success`.

[gif]

Ce type d'échange a une vaste gamme de cas d'utilisation. Il peut être utilisé dans le modèle de publication-abonnement, en distribuant des données pertinentes à des processus de travailleurs désirants et bien plus encore.

# Header

Un header est un type particulier d'échange qui achemine les messages en fonction des clés présentes dans l'en-tête du message. Il néglige l'attribut de clé de routage du message.

Lors de la création de liaisons pour un échange de header, il est possible de lier une file d'attente pour correspondre à plus d'un header. Dans un tel cas, RabbitMQ doit savoir du producteur s'il doit correspondre à tous ou à l'un de ces clés.

Une application/producer peut faire cela en fournissant un drapeau supplémentaire appelé 'x-match'. 'x-match' peut avoir des valeurs `any` ou `all`. Le premier mandata que seule une valeur doit correspondre tandis que le second mandata que toutes doivent correspondre.

# Accusé de réception des messages

Une fois qu'un message atteint sa destination, le courtier doit supprimer le message de la file d'attente. Cela est nécessaire car un débordement de file d'attente peut se produire s'il continue à accumuler des messages.

Avant de supprimer un message, le courtier doit avoir un accusé de réception de livraison. Il existe deux façons possibles d'accuser réception de la livraison du message.

1. Accusé de réception automatique : Une fois qu'un consommateur reçoit le message
2. Accusé de réception explicite : Lorsqu'un consommateur envoie un accusé de réception

Dans la plupart des cas, l'accusé de réception explicite est utilisé car il garantit que le consommateur a consommé le message sans aucun basculement.

# Qu'est-ce qui suit

RabbitMQ est un produit très mature et utile. Cet article n'est qu'une introduction de haut niveau à RabbitMQ. J'ai simplifié les concepts pour vous fournir un point de référence afin d'aller plus loin. Visitez le site [RabbitMQ](https://www.rabbitmq.com/) pour des sujets plus complexes.

J'espère que vous avez aimé l'article. N'oubliez pas d'applaudir (ou d'applaudir ?). Suivez pour lire mes prochaines histoires. Jusqu'à la prochaine fois, continuez à faire la queue.