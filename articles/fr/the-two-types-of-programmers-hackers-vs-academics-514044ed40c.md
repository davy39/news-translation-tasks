---
title: Êtes-vous le hacker ou l'académique ?
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2017-01-17T10:33:37.000Z'
originalURL: https://freecodecamp.org/news/the-two-types-of-programmers-hackers-vs-academics-514044ed40c
coverImage: https://cdn-media-1.freecodecamp.org/images/1*cIXQJZ7avw6mfzsN6Kaf0w.jpeg
tags:
- name: Life lessons
  slug: life-lessons
- name: General Programming
  slug: programming
- name: software development
  slug: software-development
- name: startup
  slug: startup
- name: 'tech '
  slug: tech
seo_title: Êtes-vous le hacker ou l'académique ?
seo_desc: 'By Alex Ewerlöf

  During my 18 year career as a programmer, I’ve worked on dozens of different projects,
  from robotics to finance to healthcare and telecom. And I’ve had the opportunity
  to work with hundreds of programmers from all sorts of backgrounds...'
---

Par Alex Ewerlöf

Au cours de ma carrière de 18 ans en tant que programmeur, j'ai travaillé sur des dizaines de projets différents, allant de la robotique à la finance, en passant par la santé et les télécommunications. J'ai eu l'opportunité de travailler avec des centaines de programmeurs issus de tous horizons, chacun avec ses propres habitudes et attitudes.

J'ai appris que, peu importe d'où ils viennent ou ce qu'ils font, tous les programmeurs se situent quelque part sur ce spectre :

![Image](https://cdn-media-1.freecodecamp.org/images/1*_c_trxMd8nI4tQc5ZjRvhQ.png)

### L'académique

À une extrémité du spectre se trouvent les programmeurs qui excellent en théorie. Ils adorent apprendre, lire, explorer et innover. Pour eux, chaque ligne de code ressemble à une contribution au monde, *un héritage pour l'avenir* même. S'il y a un défaut dans le code, c'est parce qu'ils ne savent pas faire mieux **pour l'instant**.

Dans leur monde, le code doit être *parfait*, *sans bug* et *conforme aux meilleures pratiques*. Ils apprécient les façons intelligentes de faire les choses et adorent [se tenir au courant des dernières technologies](https://medium.com/@alexewerlof/how-i-learn-new-tech-cb79db19c818).

Malheureusement, *l'académique* s'ennuiera lorsque l'apprentissage s'arrêtera et cherchera d'autres projets, voire changera de travail :

![Image](https://cdn-media-1.freecodecamp.org/images/1*VMLuirSQh-LvZJ3IJklrfw.png)

L'inconvénient de cette façon de travailler est que les projets progressent lentement. Lorsque vous apprenez quelque chose, vous avez tendance à tomber sur autre chose que vous aimeriez apprendre. Et ce cycle de descente dans des terriers peut durer un certain temps avant que des fonctionnalités significatives ne soient livrées :

![Image](https://cdn-media-1.freecodecamp.org/images/1*1bx5HPzhezXUgq-_ZB9azA.png)

Mais ce n'est pas tout mauvais. Lorsque le produit doit répondre à des *normes élevées*, *l'académique* est en fait le bon type de programmeur.

Par exemple, pour les logiciels de santé, la sécurité des patients est extrêmement importante. Vous voulez que vos programmeurs prennent leur temps et apprennent leur métier avant de pousser du code dans l'environnement de "production" qu'est la vie des gens.

[Même un petit bug peut être fatal](http://royal.pingdom.com/2009/03/19/10-historical-software-bugs-with-extreme-consequences/).

Un autre exemple est le secteur financier, où une simple erreur peut coûter très cher. Cela est également vrai pour la plupart des logiciels de sécurité ou exigeant une grande fiabilité, où la réputation de l'entreprise est souvent en jeu.

### Le hacker

À l'autre extrémité du spectre se trouve *le hacker*, qui est le "travailleur du savoir" idéal selon [Deep Work de Cal Newport](https://www.amazon.com/Deep-Work-Focused-Success-Distracted/dp/1455586692). Les hackers apprennent vite et (idéalement) livrent des résultats à un rythme constant. Ils disent rarement "non" à une demande de fonctionnalité et la glisseront dans le code d'une manière ou d'une autre.

Mais après un certain temps, le code devient bancal. Le processus se bloque à un point tel que l'ajout de nouvelles fonctionnalités peut casser d'autres parties du code qui devraient autrement fonctionner :

![Image](https://cdn-media-1.freecodecamp.org/images/1*oZ49hivIWoNpiW4T1x3_Rw.png)

La dette technique s'accumule et nuit à l'entreprise à long terme.

Ces programmeurs sont les candidats parfaits pour les *emplois de consultant*, où le projet est du type *coup et fuite*. Ils peuvent même être payés pour corriger les défauts qu'ils ont eux-mêmes introduits dans le code ! Bon pour la société de conseil, mauvais pour votre entreprise. À moins, bien sûr, que vous ne soyez dans la phase de *prototypage* ou de *preuve de concept* du développement de produit, et qu'une grande partie du code doive être réécrite.

*Le hacker* est idéal pour les startups qui en sont aux premières étapes du développement du [Produit Minimum Viable](https://en.wikipedia.org/wiki/Minimum_viable_product). *Le hacker* peut générer rapidement des résultats. Ils offrent le meilleur rapport qualité-prix (en termes d'argent et de temps). Dans ces situations, *l'académique* paralyserait le développement.

### Conclusion

Il y a une blague qui dit :

![Image](https://cdn-media-1.freecodecamp.org/images/1*PPERc9mHwTQ-9wcG08wdQg.png)

Mais en réalité, il existe deux types de faiseurs :

![Image](https://cdn-media-1.freecodecamp.org/images/1*6QVQW84x9W02ntC13YhD0w.png)
*Le hacker*

*Le hacker* peut faire le travail rapidement et à moindre coût, avec [peu d'attention portée à la qualité](https://medium.com/@alexewerlof/what-is-shitty-code-handwriting-ae7c00708b). Cela ne sera pas bon marché à long terme, compte tenu de tous les coûts de maintenance.

*L'académique* se concentre sur la qualité, mais les choses avanceront très lentement, et cela coûte certainement plus cher jusqu'à ce que vous obteniez des résultats tangibles. De plus, lorsqu'ils s'ennuient, ils peuvent imposer un coût supplémentaire au projet en partant, ou pire, en restant et en ne se sentant plus passionnés par leur travail.

![Image](https://cdn-media-1.freecodecamp.org/images/1*jIsjf83WgXUKi7uzZjlG1w.png)
*L'académique*

*Le hacker* et *l'académique* sont deux extrêmes du spectre, et en réalité, la plupart des programmeurs se situent quelque part entre les deux. Il est important de choisir les bons développeurs pour votre projet et le type spécifique de logiciel que vous construisez.

Idéalement, vous pouvez commencer un projet avec *le hacker*, tandis que *l'académique* peut suivre dans le siège arrière, aiguisant ses épées pour quand le produit deviendra un succès et nécessitera une refonte importante.

De plus, les gens ne sont pas fabriqués en usine. Ils peuvent changer. Certains des développeurs les plus intelligents que j'ai rencontrés peuvent passer de *hacker* à *académique* en fonction de l'étape du projet. C'est une compétence précieuse que de nombreux développeurs cultivent au fil des années d'expérience.

Si vous ❤️ ce que vous lisez, veuillez le partager et me suivre pour rester à jour avec les derniers essais. Consultez également mes deux autres essais populaires :

* [Qu'est-ce que l'écriture de code terrible ?](https://medium.com/@alexewerlof/what-is-shitty-code-handwriting-ae7c00708b)
* [La programmation est le meilleur métier du monde](https://medium.com/@alexewerlof/what-s-cool-about-being-a-programmer-5a1e58efeee6)

Avis de non-responsabilité : toutes les opinions sont les miennes, je ne représente aucune entreprise ou société.

Mise à jour : après avoir partagé cet article, j'ai reçu quelques bons commentaires qui valent la peine d'être partagés :

> L'« académique » apprendra une fois [mais] l'appliquera plusieurs fois. Le « hacker » n'apprendra jamais. Donc le graphique pour les « fonctionnalités livrées » ne s'applique que lorsqu'on est confronté à une plateforme/pile/framework. La deuxième fois, l'« académique » laissera le « hacker » dans la poussière.

> Je suis très d'accord avec votre séparation entre les académiques plus axés sur la « justesse » et les hackers se concentrant sur le « faire avancer les choses ». Je me situe plus près du deuxième groupe et j'ai eu une collaboration extrêmement productive avec un collègue plus orienté vers le côté académique. Moi seul, je peux accomplir beaucoup de choses, mais cela ne signifie pas que c'est du beau code. Lui, d'un autre côté, peut encore accomplir beaucoup, mais prendra réellement le temps de le rendre bon également. Je vois aussi une différence dans la façon d'aborder les problèmes : il lirait des solutions connexes avant de concevoir la solution, alors que moi, au lieu de lire, j'expérimenterais avec différentes solutions. Ma méthode donne des résultats plus rapides, tandis que la sienne aboutit à de meilleures solutions. La combinaison de ces choses rend la journée de travail très productive et intéressante.