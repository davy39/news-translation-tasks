---
title: La question que j'aurais dû poser avant d'apprendre à programmer
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2018-11-29T16:38:34.000Z'
originalURL: https://freecodecamp.org/news/the-one-question-i-shouldve-asked-before-learning-to-program-17b6d3a629b7
coverImage: https://cdn-media-1.freecodecamp.org/images/1*15Ck9QYmcclxb_ofhM_AaA.jpeg
tags:
- name: education
  slug: education
- name: learning
  slug: learning
- name: General Programming
  slug: programming
- name: Python
  slug: python
- name: 'tech '
  slug: tech
seo_title: La question que j'aurais dû poser avant d'apprendre à programmer
seo_desc: 'By Amy M Haddad

  There’s one question I wish I’d taken the time to think about when I began to program.
  I was reminded of it recently at a Python meetup in Boston.

  I had just sat down at the “beginners table” when a young, energetic man in a green
  swe...'
---

Par Amy M Haddad

Il y a une question que j'aurais aimé prendre le temps de réfléchir lorsque j'ai commencé à programmer. Je me suis rappelée récemment lors d'une rencontre Python à Boston.

Je venais de m'asseoir à la "table des débutants" lorsqu'un jeune homme énergique en pull vert s'est présenté avec enthousiasme. Il m'a immédiatement demandé depuis combien de temps je programmais.

"Quelques mois", ai-je répondu. C'était la réponse qu'il attendait. Il avait commencé à programmer la semaine précédente, donc à ses yeux, j'étais une Pythoniste expérimentée (même si j'ai clarifié que j'étais toujours débutante). Il a croisé les bras, s'est penché sur la table et m'a demandé quelles ressources j'utilisais pour apprendre Python.

J'ai hésité. Au lieu de réciter une liste de ressources, je voulais lui poser une question : "Comment apprenez-vous le mieux ?"

Mais cela aurait initié une conversation approfondie quelques minutes avant le début de la rencontre. Au lieu de cela, j'ai simplement mentionné quelques livres et sites web que j'avais trouvés utiles et j'ai laissé tomber.

En rétrospective, j'aurais dû me poser cette même question lorsque j'ai commencé à programmer. Apprendre à programmer est difficile. C'est encore plus difficile lorsque le style d'enseignement de votre instructeur ne correspond pas à votre style d'apprentissage.

J'ai appris cette leçon à la dure. Si j'avais pris le temps de réfléchir à la manière dont j'apprends, j'aurais sélectionné différentes ressources dès le début et je me serais épargné beaucoup de temps et d'énergie dans le processus.

### Comment apprenez-vous le mieux ?

J'étais nouvelle en programmation et impatiente de commencer, alors j'ai naïvement suivi la recommandation d'un livre Python d'un ingénieur logiciel. Je n'ai pas fait beaucoup de recherches pour évaluer la source — j'ai juste pris sa parole. C'était une erreur, bien que je ne m'en sois pas rendu compte à l'époque.

J'ai commencé mon auto-apprentissage en mars, et la frustration a été presque immédiate. J'ai persévéré, mais chaque leçon était une lutte, principalement en raison de la manière dont le matériel était présenté. Les exemples étaient abstraits, les explications étaient peu claires, et il y avait trop peu de problèmes pratiques.

Après quelques leçons, je suis retournée voir le même ingénieur logiciel pour demander une autre recommandation. "Il doit y avoir une meilleure façon — une façon plus claire — d'apprendre Python", lui ai-je dit.

Il a recommandé une autre source avec une approche différente de la programmation : la mémorisation par cœur. Cette source était problématique dès le début. Je me suis retrouvée à mémoriser comment écrire une fonction, mais je n'avais aucune idée de pourquoi j'écrivais une fonction en premier lieu ou quand j'en utiliserais une. J'ai suivi les leçons, mais je n'ai jamais eu l'impression de comprendre pleinement le matériel.

Par un coup de chance, pendant cette période de frustration extrême, j'ai écouté un podcast qui a changé tout. L'animateur Shane Parrish a interviewé Barbara Oakley, une professeure d'ingénierie et auteure. Le sujet était "apprendre à apprendre".

Intriguée par le podcast, j'ai lu l'un des livres d'Oakley, _A Mind for Numbers_. Il détaille des stratégies pour apprendre les mathématiques et les sciences, mais ses suggestions peuvent être appliquées à d'autres sujets, y compris la programmation.

J'ai eu un moment "aha". Pas une fois dans mes années de scolarité un enseignant n'a expliqué comment apprendre efficacement. Il ne m'est pas non plus venu à l'esprit d'évaluer comment j'apprenais avant de commencer mes efforts de programmation.

Mais il n'était pas trop tard, puisque l'apprentissage ne s'arrête jamais avec la programmation. Plus tôt je pourrais comprendre comment j'apprenais le mieux — surtout comment j'apprenais les sujets techniques — mieux ce serait.

### Apprendre, de la bonne manière

La solution n'a pas été immédiate. Pendant plusieurs semaines, j'ai lu des livres et regardé des conférences en ligne sur la manière d'apprendre. J'ai également évalué mon propre style d'apprentissage et les ressources de programmation que j'avais utilisées, tant en termes de ce qu'elles offraient que de ce qui leur manquait. L'effort a porté ses fruits. Ce dont j'avais besoin d'une ressource est devenu abondamment clair.

Je n'avais pas d'expérience en programmation. Donc, j'avais besoin d'explications simples des principaux concepts de programmation, comme les boucles, les fonctions et les conditionnelles. Je voulais que la source se concentre sur la compréhension, et non sur la mémorisation. Je voulais de nombreux exemples concrets avec de nombreux problèmes pratiques. Une telle ressource existait-elle ?

C'était un samedi soir chaud en juin et mon mari et moi avons marché jusqu'à la MIT Coop, une librairie à Cambridge. J'avais l'embarras du choix parmi les livres qui promettaient de m'apprendre Python, mais le livre d'Eric Matthes, _Python Crash Course_, a attiré mon attention.

Alors que je parcourais divers chapitres et problèmes pratiques, j'étais confiante que le livre de Matthes m'apprendrait ce que je devais savoir d'une manière qui correspondait à mon style d'apprentissage. Alors je l'ai essayé, et j'ai immédiatement remarqué une différence.

Les sujets que Matthes couvre sont simples à apprendre et à retenir, en grande partie parce qu'il divise l'information en morceaux.

"Le découpage en morceaux vous aide à unir des bits d'information ensemble à travers le sens", écrit Oakley dans _A Mind for Numbers_.

Elle utilise un puzzle comme analogie. Un nouveau concept est comme un tas de pièces de puzzle éparpillées. "Se contenter de mémoriser un fait... sans compréhension ou contexte ne vous aide pas à comprendre ce qui se passe vraiment, ou comment le concept s'assemble avec les autres concepts que vous apprenez."

Cela explique pourquoi la deuxième ressource que j'ai utilisée n'a jamais fonctionné. Elle manquait de la compréhension que le découpage en morceaux offre.

Le découpage en morceaux rassemble les pièces du puzzle pour former une image. "Acquérir du contexte" fait partie du processus de découpage en morceaux qui vous aide à voir le tableau d'ensemble. Avec le contexte "vous voyez non seulement comment, mais aussi _quand_ utiliser ce morceau", écrit Oakley (emphase d'Oakley).

Matthes semble partager une vision similaire. Il commence le chapitre sur les fonctions, comme beaucoup d'autres, avec du contexte. Il décrit _ce que_ sont les fonctions et _quand_ en utiliser une. Tout au long du chapitre, des exemples concrets de fonctions efficaces sont présentés.

De plus, il tisse ensemble des sujets précédemment étudiés avec le nouveau sujet en question. Son chapitre sur les fonctions explique comment utiliser une fonction pour retourner un dictionnaire et modifier une liste, par exemple. Cela a encore renforcé ma base de connaissances.

Matthes aide le programmeur en herbe à construire une compréhension solide des fondamentaux importants de la programmation. Son approche a lancé mon processus de découpage en morceaux, mais je ne me suis pas contentée de lire passivement un chapitre et de "comprendre".

En fait, je travaille encore dur pour renforcer mes morceaux de programmation. Ils prennent du temps à construire. L'objectif est de construire des morceaux de programmation efficaces, afin que je puisse activement rappeler le meilleur à utiliser lors de la résolution d'un problème.

Une partie du processus de découpage en morceaux implique la réalisation de problèmes pratiques, à la fois ceux liés et non liés au morceau que j'essaie de construire. De cette façon, Oakley suggère, "vous voyez non seulement quand utiliser le morceau, mais aussi quand _ne pas_ l'utiliser" (emphase d'Oakley). Pour construire un morceau de "boucle for", par exemple, je compléterai des problèmes qui utilisent une boucle for et ceux qui n'en utilisent pas.

C'est pourquoi j'avais besoin d'une ressource qui offrait beaucoup de pratique. Là aussi, le livre de Matthes a répondu à mes attentes. Chaque chapitre se compose de plusieurs leçons, chacune avec plusieurs questions qui approfondissent un concept.

Cependant, la réalisation de problèmes pratiques non liés à un morceau que j'essaie de construire, comme le suggère Oakley, a été principalement de mon ressort et implique souvent la résolution de problèmes au hasard.

Importamment, Matthes ne fournit pas les solutions aux problèmes. Cela peut sembler un inconvénient, mais j'ai constaté que lorsque les réponses vous sont données immédiatement, vous êtes privé de la lutte. Le cycle d'essayer, échouer, réessayer, échouer encore plus de fois, et persévérer. C'est essentiel au processus d'apprentissage et c'est ce qui rend la programmation si gratifiante.

Sur le moment, la lutte peut être fastidieuse et frustrante. Mais cela en vaut la peine. J'apprends le plus lorsque je lutte le plus. De plus, l'apprentissage reste avec moi longtemps après avoir terminé un problème.

Après environ trois mois de bidouillage avec plusieurs ressources, Python a enfin commencé à faire sens avec le livre de Matthes. Mais ce n'était qu'une partie de la solution.

### Une stratégie d'apprentissage

Est-ce que je comprenais vraiment les fonctions ? Et les conditionnelles et les classes ?

Pour le découvrir, je voulais mettre à l'épreuve les connaissances que je gagnais du livre de Matthes. J'ai donc élaboré un plan d'apprentissage global qui impliquait beaucoup de pratique à partir d'autres ressources.

Voici comment cela fonctionnait : j'étudiais un chapitre dans le livre de Matthes et complétais les problèmes pratiques. Ensuite, je me tournais vers le livre de Brian Hogan, _Exercises for Programmers_, qui me donnait plus de pratique et consolidait les concepts que j'apprenais à ce moment-là.

De plus, le livre de Hogan était en phase avec mon style d'apprentissage. Il s'agissait de problèmes pratiques et concrets (sans réponses) et organisés principalement par concept, bien que les problèmes varient en difficulté. Les deux sources se complétaient.

Le livre de Matthes fournissait des connaissances fondamentales sur Python. Le livre de Hogan mettait ces connaissances au défi et me poussait hors de ma zone de confort. Certains des problèmes dans le livre de Hogan m'ont pris des heures, voire des jours à résoudre. J'ai expérimenté. J'ai échoué. J'ai réessayé. J'ai recherché de nouvelles techniques et réétudié celles que j'avais apprises dans le livre de Matthes.

En utilisant ces ressources en tandem, je n'ai pas seulement amélioré mes connaissances en programmation, mais aussi affûté mes compétences en résolution de problèmes.

Une grande partie de ma stratégie d'apprentissage globale est ce que j'appelle la "répétition aléatoire".

L'aléatoire est un moyen de tester mes connaissances — pour voir si je peux me rappeler comment et quand utiliser une liste plutôt qu'un dictionnaire. Et la répétition aide à consolider les concepts.

Après avoir complété les exercices dans le livre de Hogan, je les ai faits une fois de plus, mais cette fois-ci de manière aléatoire. Je testais mes connaissances en sélectionnant aléatoirement des exercices que j'avais complétés dans le livre de Matthes également. L'application Anki a également été une bouée de sauvetage, car elle vérifie mes connaissances sur une gamme de sujets de programmation. C'est un rappel constant de ce que je sais, mais, plus important encore, de ce que je ne sais pas.

### Réflexions finales

Comprendre comment apprendre efficacement a rendu mon entrée dans la programmation beaucoup plus efficace et agréable. En fait, le nombre d'opportunités d'apprentissage est l'un des aspects qui m'a attirée vers la programmation en premier lieu.

Maintenant, je réalise comment je peux apprendre mieux. J'ai depuis passé à une nouvelle phase d'apprentissage avec de nouveaux matériaux et un nouvel objectif et stratégie d'apprentissage. Au début, j'ai pris quelques jours pour "tester" des sources potentielles. J'ai identifié celles qui m'aideraient à atteindre mes objectifs beaucoup plus rapidement cette fois-ci.

Sachant ce que je sais maintenant, j'aurais donné à ce jeune homme à la rencontre Python une réponse différente.

Plus tôt vous prenez le contrôle et comprenez comment vous apprenez le mieux, mieux c'est. Le domaine de la programmation évolue rapidement. Il y a une vaste quantité d'informations à apprendre, des multiples langages aux bases de données en passant par les tests.

Apprendre les fondements d'un langage de programmation n'est que le début d'une carrière d'apprentissage.

_Je écris sur la technologie, la productivité et l'art ([amymhaddad.com](http://amymhaddad.com))._