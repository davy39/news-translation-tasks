---
title: The one question I should’ve asked before learning to program
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2018-11-29T16:38:34.000Z'
originalURL: https://freecodecamp.org/news/the-one-question-i-shouldve-asked-before-learning-to-program-17b6d3a629b7
coverImage: https://cdn-media-1.freecodecamp.org/images/1*15Ck9QYmcclxb_ofhM_AaA.jpeg
tags:
- name: education
  slug: education
- name: learning
  slug: learning
- name: General Programming
  slug: programming
- name: Python
  slug: python
- name: 'tech '
  slug: tech
seo_title: null
seo_desc: 'By Amy M Haddad

  There’s one question I wish I’d taken the time to think about when I began to program.
  I was reminded of it recently at a Python meetup in Boston.

  I had just sat down at the “beginners table” when a young, energetic man in a green
  swe...'
---

By Amy M Haddad

There’s one question I wish I’d taken the time to think about when I began to program. I was reminded of it recently at a Python meetup in Boston.

I had just sat down at the “beginners table” when a young, energetic man in a green sweater enthusiastically introduced himself. He promptly asked how long I’d been programming.

“A few months,” I said. That was the answer he was looking for. He had begun to program the week before, so in his eyes I was a seasoned Python-ista (even though I clarified that I was still a beginner). He crossed his arms, leaned across the table, and asked what resources I used to learn Python.

I hesitated. Instead of rattling off a list of resources, I wanted to ask him a question: “How do you learn best?”

But that would’ve initiated an in-depth conversation minutes before the meetup was to begin. Instead, I just mentioned a few books and websites that I found useful and let it go.

In retrospect, I should’ve asked myself that same question when I began to program. Learning to program is hard. It’s even harder when your instructor’s teaching style doesn’t mesh with your learning style.

I learned that lesson the hard way. If I’d taken the time to think about how I learn, I would’ve selected different resources from the start and saved myself a ton of time and energy in the process.

### How do you learn best?

I was brand-new to programming and eager to start, so I naively took a Python book recommendation from a software engineer. I didn’t do much of my own research to evaluate the source — I just took his word. That was a mistake, though I didn’t realize it at the time.

I began my self-study in March, and the frustration was almost immediate. I persisted but each lesson was a struggle, mostly due to how the material was presented. The examples were abstract, the explanations were unclear, and there were too few practice problems.

After a few lessons, I went back to the same software engineer to ask for another recommendation. “There has to be a better way — a clearer way — to learn Python,” I told him.

He recommended another source with a different approach to programming: rote memorization. This source was problematic from the start. I found myself memorizing how to write a function, but I had no idea why I was writing a function in the first place or when I’d use one. I got through the lessons, but never felt like I fully understood the material.

By a stroke of luck, during this time of extreme frustration, I listened to a podcast that changed everything. Host Shane Parrish interviewed Barbara Oakley, an engineering professor and author. The topic was “learning how to learn.”

Intrigued by the podcast, I picked up one of Oakley’s books, _A Mind for Numbers_. It details strategies for learning math and science, but her suggestions can be applied to other subjects, including programming.

I had an “aha” moment. Not once in my years of schooling did a teacher explain how to learn effectively. Nor did it occur to me to evaluate how I learn before starting my programming endeavors.

But it wasn’t too late, since the learning never stops with programming. The sooner I could figure out how I learned best — especially how I learned technical topics — the better.

### Learning, the right way

The solution wasn’t immediate. For several weeks, I read books and watched lectures online about how to learn. I also evaluated my own learning style and the programming resources I’d used, both in terms of what they offered and what they lacked. The effort paid off. What I needed from a resource became abundantly clear.

I didn’t have programming experience. So, I needed straightforward explanations of major programming concepts, like loops, functions, and conditionals. I wanted the source to focus on understanding, not memorizing. I wanted many real-world examples with many practice problems. Did such a resource exist?

It was a warm Saturday evening in June and my husband and I walked to the MIT Coop, a bookstore in Cambridge. I had my pick of books that promised to teach me Python, but Eric Matthes’s book _Python Crash Course_ caught my eye.

As I scanned various chapters and practice problems, I felt confident Matthes’s book would teach me what I needed to know in a way that fit with my learning style. So I gave it a try, and instantly noticed a difference.

The topics Matthes covers are simple to learn and remember, largely because he chunks information.

“Chunking helps you unite bits of information together through meaning,” Oakley writes in _A Mind for Numbers_.

She uses a puzzle as an analogy. A new concept is like a bunch of scattered puzzle pieces. “Just memorizing a fact… without understanding or context doesn’t help you understand what’s really going on, or how the concept fits together with the other concepts you are learning.”

This explains why the second resource I used never clicked. It lacked the understanding that chunking offers.

Chunking brings the puzzle pieces together to form an image. “Gaining context” is part of the chunking process that helps you see the bigger picture. With context “you see not just how, but also _when_ to use this chunk,” writes Oakley (emphasis Oakley).

Matthes seems to share a similar view. He begins the functions chapter, much like his others, with context. He describes _what_ functions are and _when_ to use one. Sprinkled throughout are real-world examples of effective functions.

Plus, he weaves previously studied topics together with the new topic at hand. His functions chapter explains how to use a function to return a dictionary and modify a list, for instance. This further enhanced my knowledge base.

Matthes helps the budding programmer build a solid understanding of important programming fundamentals. His approach spearheaded my chunking process, but I didn’t just passively read a chapter and “get it.”

In fact, I’m still working hard to strengthen my programming chunks. They take time to build. The aim is to build effective programming chunks, so I can actively recall the best one to use when solving a problem.

Part of the chunking process involves completing practice problems, both those related and unrelated to the chunk that I’m trying to build. That way, Oakley suggests, “you see not only when to use the chunk, but [also] when _not_ to use it” (emphasis Oakley). To build a “for loop” chunk, for example, I’ll complete problems that use a for loop and those that don’t.

This is why I needed a resource that offered a lot of practice. Here, too, Matthes’s book came through. Each chapter consists of several lessons, each with multiple questions that drill a concept.

However, completing practice problems unrelated to a chunk that I’m trying to build, as Oakley suggests, has been mostly up to me and often involves resolving problems at random.

Importantly, Matthes doesn’t provide the solutions to the problems. That may seem like a detriment, but I’ve found that when you’re given the answers immediately, you’re deprived of the struggle. The cycle of trying, failing, trying again, failing many more times, and persevering. That’s essential to the learning process and that makes programming so rewarding.

In the moment, the struggle can be tedious and frustrating. But it’s worth it. I learn the most when I struggle the most. Plus, the learning stays with me long after I’ve completed a problem.

After about three months of tinkering with multiple resources, Python finally started to click with Matthes’s book. But that was only part of the solution.

### A learning strategy

Did I really understand functions? What about conditionals and classes?

To find out, I wanted to put the knowledge I was gaining from Matthes’s book to the test. So I devised an overall learning plan that involved a lot of practice from other resources.

This is how it worked: I studied a chapter in Matthes’s book and completed the practice problems. Then I turned to Brian Hogan’s book _Exercises for Programmers_, which gave me more practice and solidified the concepts I was learning about at the time.

Plus, Hogan’s book was in sync with my learning style. It was practical, real-world problems (without answers) and organized mostly by concept, though the problems range in difficulty. The two sources complemented each other.

Matthes’s book provided foundational Python knowledge. Hogan’s book challenged that knowledge and pushed me outside of my comfort zone. Some of the problems in Hogan’s book took me hours, even days to solve. I experimented. I failed. I tried again. I researched new techniques, and re-studied ones I had learned about in Matthes’s book.

By using these resources in tandem, I not only enhanced my programming knowledge, but sharpened my problem-solving skills.

A big part of my overall learning strategy is what I call “random repetition.”

Randomness is a way to test my knowledge — to see if I can recall how and when to use a list as opposed to a dictionary. And repetition helps consolidate concepts.

After I completed the exercises in Hogan’s book, I did them once more, but this time at random. I’d test my knowledge by randomly selecting exercises that I’d completed in Matthes’s book as well. The Anki app has also been a lifesaver, since it checks my knowledge on a range of programming topics. It’s a constant reminder of what I know, but, more importantly, of what I don’t.

### Final thoughts

Understanding how to learn effectively has made my entry into programming much more effective and enjoyable. In fact, the number of learning opportunities is one aspect that attracted me to programming in the first place.

Now I realize how I can learn better. I’ve since moved onto a new learning phase with new materials and a new learning goal and strategy. At the start I took a few days to “test drive” potential sources. I identified the ones that would help me achieve my goals much quicker this time around.

Knowing what I know now, I would have given that young man at the Python meetup a different answer.

The earlier you take control and figure out how you learn best, the better. The field of programming is evolving quickly. There’s a vast amount of information to learn about, from multiple languages to databases to testing.

Learning the foundations of a programming language is just the beginning of a career of learning.

_I write about technology, productivity, and art ([amymhaddad.com](http://amymhaddad.com))._

