---
title: Top Ways Hackers Exploit Web Applications (and How to Prevent Them)
subtitle: ''
author: Manish Shivanandhan
co_authors: []
series: null
date: '2025-05-13T14:18:45.581Z'
originalURL: https://freecodecamp.org/news/how-hackers-exploit-web-applications-and-how-to-prevent-them
coverImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1747060147180/03146ca3-bc12-4d00-bdde-985817a0893c.png
tags:
- name: Security
  slug: security
- name: cybersecurity
  slug: cybersecurity
seo_title: null
seo_desc: 'Every website that takes user input is a potential target for an attacker.

  You might think your app is too small or too new to get noticed, but attackers use
  tools to scan the web for common security mistakes.

  If your site is online and has a login f...'
---

Every website that takes user input is a potential target for an attacker.

You might think your app is too small or too new to get noticed, but attackers use tools to scan the web for common security mistakes.

If your site is online and has a login form, a search box, or a database, it’s already being tested.

But here’s the good news: you don’t need to be a cybersecurity expert to protect your app. You just need to understand how these attacks work and write safer code.

Let’s go through ten of the most common ways hackers break into web apps—and how to fix each one, with clear examples.

### Here’s what we’ll cover:

1. [SQL Injection](#heading-sql-injection)
    
2. [Cross-Site Scripting (XSS)](#heading-cross-site-scripting-xss)
    
3. [Cross-Site Request Forgery (CSRF)](#heading-cross-site-request-forgery-csrf)
    
4. [Broken or Weak Authentication](#heading-broken-or-weak-authentication)
    
5. [Insecure Direct Object References (IDOR)](#heading-insecure-direct-object-references-idor)
    
6. [Security Misconfiguration](#heading-security-misconfiguration)
    
7. [Sensitive Data Exposure](#heading-sensitive-data-exposure)
    
8. [Using Outdated Libraries](#heading-using-outdated-libraries)
    
9. [Broken Access Control](#heading-broken-access-control)
    
10. [No Logging or Monitoring](#heading-no-logging-or-monitoring)
    
11. [Conclusion](#heading-conclusion)
    

## SQL Injection

Hackers exploit this when your app lets them send raw SQL commands directly to your database. Here’s an insecure example in PHP:

```php
$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
```

If a user enters this as the username:

```plaintext
' OR 1=1 --
```

The query becomes:

```sql
SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = '';
```

This returns all users – because `1=1` is always true. That means anyone can log in without knowing a password.

This is called *string-building*, where user input is directly inserted into the SQL command. It treats the input as part of the code, not just data.

### **The fix: use prepared statements**

Prepared statements separate code from data. The SQL command is defined once, and user values are passed separately – so they can’t break the logic.

Here’s the same query using PHP with PDO:

```php
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->execute([$username, $password]);
```

This makes your code immune to SQL injection – even if a user tries to inject malicious input.

## Cross-Site Scripting (XSS)

Let’s say your site shows comments. If someone posts this:

```html
<script>alert('Gotcha!');</script>
```

And your site displays it as-is, every visitor sees a popup. That’s a basic XSS attack. A real attacker could do much worse – like stealing session cookies or redirecting users to fake login pages.

### **The fix: escape what you show**

Escaping means converting special characters like `<` and `>` into harmless text.

In PHP:

```php
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');
```

In JavaScript, you can use libraries like DOMPurify:

```js
const safeHTML = DOMPurify.sanitize(userInput);
```

Never trust user input – especially when putting it back into your HTML.

## Cross-Site Request Forgery (CSRF)

CSRF tricks a logged-in user’s browser into making an unwanted request to your site – without their knowledge.

Here’s how it works: a user logs into your app and then visits a malicious site. That site contains code like:

```html
<img src="https://yourapp.com/delete-account" />
```

Since the user is already logged in, their browser sends the request – with cookies and all. If your app doesn’t check for CSRF, it assumes the user wanted to delete their account.

### **The fix: use CSRF tokens**

These are unique, secret values included in forms:

```html
<input type="hidden" name="csrf_token" value="abc123">
```

Your server must check this token on every request. If it’s missing or incorrect, reject the request. Most frameworks (like Laravel or Django) do this automatically.

## Broken or Weak Authentication

If your login system is too simple, it’s an easy target.

**Common mistake:** storing passwords in plain text:

```php
file_put_contents('users.txt', "$username:$password\n");
```

If this file leaks, all user accounts are exposed.

### **The fix: hash passwords**

```php
$hash = password_hash($password, PASSWORD_DEFAULT);
```

And to check them later:

```php
if (password_verify($password, $storedHash)) {
    // Login success
}
```

Other critical fixes:

* **Rate limit login attempts:** Block or delay after 5 failed tries.
    
* **Add multi-factor authentication (MFA):** Send a one-time code via email or app.
    
* **Use strong password policies:** Require longer passwords with a mix of characters.
    

Each step makes brute-force attacks harder and protects user accounts.

## Insecure Direct Object References (IDOR)

Suppose your site has this URL:

```plaintext
/invoice?id=123
```

A hacker tries:

```plaintext
/invoice?id=124
```

Suddenly, they can see someone else’s invoice.

### **The fix: verify ownership**

```php
$stmt = $pdo->prepare("SELECT * FROM invoices WHERE id = ? AND user_id = ?");
$stmt->execute([$invoiceId, $loggedInUserId]);
```

Always confirm the logged-in user owns the data they’re trying to access.

## Security Misconfiguration

This refers to using insecure default settings or forgetting to disable things that shouldn't be public.

**Examples include:**

* Leaving error messages on in production (`display_errors = 1`)
    
* Exposing admin panels or debug tools
    
* Using default passwords or outdated software
    

These aren’t bugs in your code – but they’re just as dangerous.

### **The fix:** disable detailed error reporting in production:

```php
ini_set('display_errors', 0);
```

And secure admin tools with passwords, IP allowlists, or move them behind a VPN or private path.

## Sensitive Data Exposure

If you send user data over HTTP instead of HTTPS, anyone on the network can read it – like passwords or credit card numbers.

**Example of unsafe code:**

```php
file_put_contents('logs.txt', "User: $username, Password: $password");
```

If that log file is exposed, all passwords are leaked.

**Fixes:**

* Use HTTPS everywhere. Tools like [Let’s Encrypt](https://letsencrypt.org/) make it free and easy.
    
* Never store passwords in logs.
    
* Encrypt sensitive data at rest, especially if it’s personally identifiable info (PII) or financial data.
    

## Using Outdated Libraries

Most apps use external libraries. If one has a known vulnerability, attackers can exploit it – even if your code is perfect.

**To protect yourself:**

* Regularly update dependencies. In Node.js:
    

```bash
npm audit fix
```

* In PHP:
    

```bash
composer update
```

* Replace unmaintained libraries with safer alternatives.
    

## Broken Access Control

Some apps try to control access just by hiding buttons on the UI.

**Example:** A user isn’t shown the “delete post” button – but they manually send a request like:

```http
POST /delete-post?id=5
```

If the backend doesn’t check permissions, the request goes through.

### **The fix: enforce access control on the backend**

```php
if ($user->role !== 'admin') {
    http_response_code(403);
    exit;
}
```

Don’t rely on the front-end to block actions. The server must check every request and confirm the user is allowed to perform the action.

## No Logging or Monitoring

If something suspicious happens and you don’t have logs, you’ll never know.

**Example log entry (in Laravel):**

```php
Log::info('User login', ['user_id' => $user->id]);
```

Set up alerts for suspicious behavior – like 100 failed logins in 10 minutes. Use monitoring tools like Sentry, Datadog, or ELK Stack to watch your app in real time.

If you don’t track what’s happening, you can’t stop it when things go wrong.

## Conclusion

Hackers don’t need advanced tools. Most just look for easy wins – unescaped forms, plaintext passwords, outdated libraries, or exposed admin areas.

If you follow the basics in this guide, you’ll block 90% of those attacks.

You don’t need to fix everything today. Start with one item. Escape user input. Use HTTPS. Add CSRF protection. Each fix makes your app a little safer.

**Want to learn more?** Get strong basics in offensive security—take the [*Security Starter* course](https://start.stealthsecurity.sh/).
