---
title: Mythbusting Competitive Programming – You Don't Need to Learn It
subtitle: ''
author: freeCodeCamp
co_authors: []
series: null
date: '2020-06-27T20:30:00.000Z'
originalURL: https://freecodecamp.org/news/mythbusting-competitive-programming
coverImage: https://www.freecodecamp.org/news/content/images/2020/06/cp.jpg
tags:
- name: Competitive programming
  slug: competitive-programming
seo_title: null
seo_desc: 'By Mehul Mohan

  Now that I have your attention with the post title, let me go in-depth on my views
  of competitive programming.

  What is competitive programming?

  Competitive programming is a sport. You have to solve a problem with code that is
  fast, con...'
---

By Mehul Mohan

Now that I have your attention with the post title, let me go in-depth on my views of competitive programming.

## What is competitive programming?

Competitive programming is a sport. You have to solve a problem with code that is fast, consumes the minimum amount of memory, and is often _practically unreadable._ 

It is super popular among university students and those trying to get into big companies, primarily because it helps them get placed in those companies. Unfortunately, millions of people are hired because of some knowledge they would never use in their jobs.

## The system is broken

![Image](https://www.freecodecamp.org/news/content/images/2020/06/Screenshot-2020-06-27-at-6.46.26-PM.png)

Here's another example from [Hen-Wen](https://twitter.com/Nienhuys/status/1276044242855624704):

![Image](https://www.freecodecamp.org/news/content/images/2020/06/Screenshot-2020-06-27-at-6.52.17-PM.png)

There are tons of examples out there I can think of. 

The creator of homebrew – a package manager used by almost everyone running macOS? Rejected. The creator of WhatsApp? Rejected by Facebook and Twitter. 

So what is happening here? Are these people not qualified enough to work in these MNCs?

No, the answer is that these guys can develop useful tools and write great software with top-notch code quality, but they probably fail to (re)invent an algorithm to invert a binary tree in a 30-minute time limit. 

Some of the best code written ever was not written in 30 minutes. Some of the best algorithms written in Linux kernel used even today were not written in 30 minutes by Linus. Some of the best UIs like Stripe was not designed in 30 minutes. 

So how can some random HR person in some random company decide your worth in 30 minutes?

This is how companies judge your "feasibility" – by seeing if you can solve a toy problem completely unrelated to any work you might have done in the past, or you might do in the future.

### Can this be fixed?

I don't know. I can complain and yell all I want, but I honestly don't know how companies can evaluate a person applying for a job quickly and correctly. 

If you want quick, you'll lose a lot of good candidates like the ones mentioned above. If you want to lose no good candidates, the interview might last for way too long – much longer than the company can afford.

## Competitive Programming !== Real World Programming

Interviews for companies are more of an exam where you have to memorize and learn about things you won't use after getting the job. 

You think you might need to learn Dijkstra's algorithm to work on Google Maps, but seriously, do you think Google is going to hand over one of their core products to someone new to the company? Do you think you'll get no help whatsoever from your peers?

You will probably be working on the interface for the product, or distributed systems rather than working on one of Google's cor algorithms. This means all of your "competitive programming" knowledge is of no use.

You'll find almost no use for competitive programming in the real world. No algorithm running on production Microsoft servers is written in unreadable code, with short and meaningless variable names, undocumented and optimized only for speed and not readability or maintenance.

Minifying and performance improvement comes later on, with automated tools a lot of the time. Chances are, if you are a competitive coder, you developed the bad habit of writing ugly code. 

Anyone can write code for machines. The question is, can you write code for humans?

## But there's hope

Sitting for interviews like this and hoping you can solve a toy question you prepared for 3-5 months learning just DSA and competitive programming is one way. 

There's another way – it'll work with fewer companies and people, but you'll enjoy it, and learn a lot of real-world things along the way. You'll also be more useful than those people who only learn "competitive coding" for the sake of it.

Build something. Anything. And then build more on top of that. Have a strong portfolio. Have a complete skillset which is useful for companies. Have mastery with a tech stack – own it. Have projects, blogs, experience to show that you are what is in your resume. Build connections, network with people, ask for their recommendations. 

In a lot of places, competitive coding is not the only way to clear an interview – there are all kinds of people running all kinds of companies. A person who agrees with my PoV, and is running a company would not be hiring people on their "competitive" knowledge alone.

Your work can take you places you couldn't imagine. The easiest way is to always follow the crowd. But nothing good comes easy, at least if you're ambitious enough. Mixing just the right amount of ambition and courage can do wonders. 

The world needs great programmers to progress, to move humanity forward, not people who can get hired.

## Don't confuse DSA with Competitive Programming

I did not want to write this section initially, but I knew too many people will confuse this. DSA - Data Structures and Algorithms is something different. Heap, Maps, Arrays, Vectors, Linked Lists, .etc, all these are super helpful in real-world programming too.

The fun part is you can develop that understanding with experience, too. I never explicitly learned about "heap" using some big 50-hour DSA course. And if you are learning to program, you don't need a very very deep understanding of that too. 

DSA in depth is required when you want to learn computer science, not programming. Understand the difference, computer science is the theory – programming is practical.

Be **aware** of things that exist, algorithms that exist, and data structures that exist. You don't need to learn or memorize them all. It sounds insanely stupid to me to memorize or learn something which is rarely used when I can get it with a bit of help from colleagues and the internet.

## My story

I'm **not** a competitive coder, probably the only CS undergrad in my university who never touched competitive coding in **college**. 

Why? Because I tried it 4-5 years ago and hated it. Why? Because I could see myself spending 3-5 hours of my day, every day, solving problems that got me nothing. I knew a thing or two more about approaching the next question, but was that enough to make an impact? Was that enough to stand out from the crowd?

What good was I doing? It felt like I was wasting time on questions that were already solved. It might be different for everyone, but I am happy when I see other people using the things I programmed (I started as a web developer by then). 

I just couldn't stand wasting my time learning something I would never use in the real world. I used to participate in Google's Code Jam and Facebook's Hacker Cup back in the day. But soon I got bored and frustrated, for the lack of a better word, and never really got back to it. Getting a job or internship didn't concern me, it never did.

I sat for Google interviews once on campus. They had a resume shortlisting round as the first round, unlike all the other companies where the first round was, wait for it, **competitive coding round.** Well there went the 7 years of web development and systems experience down the drain. 

Anyway, for Google, I was the only person to be shortlisted with a GPA of 7.5 (the highest GPA is 10 in India). The rest of the 10-15 people were above 8.5 or 9. 

I didn't get past the competitive round again, but that taught me that it was possible to break into the first round of a company like Google with just your resume. Therefore, it's important to work on that.

## Conclusion

TL;DR – You don't need to learn competitive coding to succeed in life. You need to learn something you like so much that you master it, and you're unbeatable in your field. That's all. 

Have views and opinions? Connect with me on [Twitter](https://twitter.com/mehulmpt) and [Instagram](https://instagram.com/mehulmpt) and let's talk!

